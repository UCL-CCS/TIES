{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>TIES is a python library for the relative binding free energy (RBFE) calculations.</p> <p>TIES superimposes ligands and prepares the input  files for molecular dynamics simulations.  These simulations can be carried out with  either NAMD or OpenMM using the package TIES_MD.</p> <p>For the details about the protocol and its validation please refer to the following publications</p> <p>Mateusz K. Bieniek, Agastya P. Bhati, Shunzhou Wan, and Peter V. Coveney. Ties 20: relative binding free energy with a flexible superimposition algorithm and partial ring morphing. Journal of Chemical Theory and Computation, 17(2):1250\u20131265, 2021. PMID: 33486956. doi:10.1021/acs.jctc.0c01179.</p>"},{"location":"installation/","title":"Installation","text":"<p>The easiest way to start is to use the latest  published conda-forge package. Create a new  environment and use: </p> <pre><code>conda install ties\n</code></pre>"},{"location":"installation/#development-version","title":"Development version","text":"<p>Whereas most of the dependancies can be installed with pip,  ambertools has to be either compiled.  The easiest way is to use the conda-forge environment:   </p> <pre><code>mamba env create -f environment.yml\nconda activate ties \npip install --no-deps . \n</code></pre>"},{"location":"publications/","title":"Publications","text":"<p>We list here a list of publication that utilised  the software for carrying our RBFE calculations. </p> <p>Mateusz K Bieniek, Alexander D Wade, Agastya P Bhati, Shunzhou Wan, and Peter V Coveney. TIES 2.0: A Dual-Topology Open Source Relative Binding Free Energy Builder with Web Portal. Journal of Chemical Information and Modeling, 63(3):718\u2013724, 2023. URL: https://doi.org/10.1021/acs.jcim.2c01596, doi:10.1021/acs.jcim.2c01596.0</p> <p>Mateusz K Bieniek, Alexander D Wade, Agastya P Bhati, Shunzhou Wan, and Peter V Coveney. TIES 2.0: A Dual-Topology Open Source Relative Binding Free Energy Builder with Web Portal. Journal of Chemical Information and Modeling, 63(3):718\u2013724, 2023. URL: https://doi.org/10.1021/acs.jcim.2c01596, doi:10.1021/acs.jcim.2c01596.</p>"},{"location":"superimposition/","title":"Superimposition","text":"<p>superimposition</p>"},{"location":"theory/","title":"TIES Protocol","text":""},{"location":"theory/#superimposition-and-defining-the-alchemical-region","title":"Superimposition and defining the alchemical region","text":"<p>Any two pairs are superimposed using a recursive joint traversal of two molecules starting from any two pairs.</p> <p>A heuristics (on by default) reduces the search space by selecting the rarer atoms that are present across the two molecules as the starting points for the traversal, decreasing substantially the computational cost.</p>"},{"location":"theory/#charge-treatment","title":"Charge treatment","text":"<p>TIES 20 supports the transformation between ligands that have the same net charge.</p> <p>We employ a dual topology approach which divides the atoms in each transformation into three groups:</p> <ol> <li>Joint region. This is the region of the molecule where    the atoms are the same    meaning that they are shared across the two ligands in the    transformation.</li> <li>Disappearing region. Atoms present only in the starting ligand    of the transformation which are fully represented    at lambda=0 and which will be scaled accordingly during the    lambda progression.</li> <li>Appearing region. Atoms present only in the ending ligand    of the transformation and therefore not present at    lambda=0. These atoms start appearing during the    lambda progression and are fully represented at    lambda=1.</li> </ol> <p>When the two ligands in a transformation are superimposed together, the treatment of charges depends on which group they belong to.</p>"},{"location":"theory/#joint-region-matched-atoms-and-their-charges","title":"Joint region: matched atoms and their charges","text":"<p>In the joint region of the transformation, first --q-pair-tolerance is used to determine whether the two original atoms are truly the same atoms. If their charges differ by more than this value (default 0.1e), then the two atoms will be added to the alchemical regions (Disappearing and appearing).</p> <p>It is possible that a lot of matched atoms in the joint region, with each pair being within 0.1e of each other, cumulatively have rather different charges between the starting and the ending ligand. For this reason, TIES 20 sums the differences between the starting and the ending atoms in the joint region, and if the total is larger than -netqtol (default 0.1e) then we further expand the alchemical region until the \"appearing\" and \"disappearing\" regions in the joint region are of a sufficiently similar net charge.</p> <p>Abiding by -netqtol rule has the further effect that, inversely, the alchemical regions (disappearing and appearing regions), will have very similar net charges - which is a necessary condition for the calculation of the partial derivative of the potential energy with respect to the lambda.</p> <p>If -netqtol rule is violated, different schemes for the removal of the matched atoms in the joint region are tried to satisfy the net charge limit. The scheme that removes fewest matched pairs, is used. In other words, TIES 20 is trying to use the smallest alchemical region possible while satisfying the rule.</p> <p>Note that we are not summing together the absolute differences in charges in the joint region. This means that if one atom pair has 0.02e charge difference, and another pair has -0.02e charge difference, then their total is zero. In other words, we are not worried about the distribution of the differences in charges in the joint region.</p> <p>The hydrogen charges are considered by absorbing them into the heavy atoms.</p> <p>The charges in the joint region for each pair are averaged.</p> <p>The last step is <code>redistribution</code>, where the final goal is that the net charge is the same in the Appearing and in the Disappearing alchemical region. After averaging the charges in the joint region, its overall charge summed with the charge of each alchemical region should be equal to the whole molecule net charge: :math:<code>q_{joint} + q_{appearing} == q_{joint} + q_{disappearing} == q_{molecule}</code>. Therefore, after averaging the charges, :math:<code>q_{molecule} - q_{joint} - q_{appearing}</code> is distributed equally in the region :math:<code>q_{appearing}</code>. The same rule is applied in :math:<code>q_{disappearing}</code>.</p>"},{"location":"api/config/","title":"Config","text":""},{"location":"api/config/#ties.Config","title":"Config","text":"<pre><code>Config(**kwargs)\n</code></pre> <p>The configuration with parameters that can be used to define the entire protocol. The settings can be overridden later in the actual classes.</p> <p>The settings are stored as properties in the object and can be overwritten.</p> <p>Methods:</p> <ul> <li> <code>get_serializable</code>             \u2013              <p>Get a JSON serializable structure of the config.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>workdir</code>           \u2013            <p>Working directory for antechamber calls.</p> </li> <li> <code>protein</code>           \u2013            <p>Path to the protein</p> </li> <li> <code>ligand_files</code>           \u2013            <p>A list of ligand filenames.</p> </li> <li> <code>ambertools_home</code>           \u2013            <p>Ambertools HOME path. If not configured, the env variable AMBERHOME as AMBER_PREFIX will be checked.</p> </li> <li> <code>ambertools_antechamber</code>           \u2013            <p>Antechamber path based on the .ambertools_home</p> </li> <li> <code>ambertools_parmchk2</code>           \u2013            <p>Parmchk2 path based on the .ambertools_home</p> </li> <li> <code>ambertools_tleap</code>           \u2013            <p>Tleap path based on the .ambertools_home</p> </li> <li> <code>antechamber_dr</code>           \u2013            <p>Whether to use -dr setting when calling antechamber.</p> </li> <li> <code>ligand_net_charge</code>           \u2013            <p>The ligand charge. If not provided, neutral charge is assumed.</p> </li> <li> <code>coordinates_file</code>           \u2013            <p>A file from which coordinate can be taken.</p> </li> <li> <code>atom_pair_q_atol</code>           \u2013            <p>It defines the maximum difference in charge</p> </li> <li> <code>net_charge_threshold</code>           \u2013            <p>Defines how much the superimposed regions can, in total, differ in charge.</p> </li> <li> <code>ignore_charges_completely</code>           \u2013            <p>Ignore the charges during the superimposition. Useful for debugging.</p> </li> <li> <code>allow_disjoint_components</code>           \u2013            <p>Defines whether there might be multiple superimposed areas that are</p> </li> <li> <code>use_element_in_superimposition</code>           \u2013            <p>Use element rather than the actual atom type for the superimposition</p> </li> <li> <code>align_molecules_using_mcs</code>           \u2013            <p>After determining the maximum common substructure (MCS),</p> </li> <li> <code>use_original_coor</code>           \u2013            <p>Antechamber when assigning charges can modify the charges slightly.</p> </li> <li> <code>ligands_contain_q</code>           \u2013            <p>If not provided, it tries to deduce whether charges are provided.</p> </li> <li> <code>superimposition_starting_pairs</code>           \u2013            <p>Set a starting pair for the superimposition to narrow down the MCS search.</p> </li> <li> <code>manually_matched_atom_pairs</code>           \u2013            <p>Either a list of pairs or a file with a list of pairs of atoms</p> </li> <li> <code>manually_mismatched_pairs</code>           \u2013            <p>A path to a file with a list of a pairs that should be mismatched.</p> </li> <li> <code>protein_ff</code>           \u2013            <p>The protein forcefield to be used by ambertools for the protein parameterisation.</p> </li> <li> <code>md_engine</code>           \u2013            <p>The MD engine, with the supported values NAMD2.13, NAMD2.14, NAMD3 and OpenMM</p> </li> <li> <code>ligand_ff</code>           \u2013            <p>The forcefield for the ligand.</p> </li> <li> <code>ligand_ff_name</code>           \u2013            <p>Either GAFF or GAFF2</p> </li> <li> <code>redistribute_q_over_unmatched</code>           \u2013            <p>The superimposed and matched atoms have every slightly different charges.</p> </li> <li> <code>use_hybrid_single_dual_top</code>           \u2013            <p>Hybrid single dual topology (experimental). Currently not implemented.</p> </li> <li> <code>ligand_tleap_in</code>           \u2013            <p>The name of the tleap input file for ambertools for the ligand.</p> </li> <li> <code>complex_tleap_in</code>           \u2013            <p>The tleap input file for the complex.</p> </li> <li> <code>prep_dir</code>           \u2013            <p>Path to the <code>prep</code> directory. Currently in the <code>workdir</code></p> </li> <li> <code>pair_morphfrcmods_dir</code>           \u2013            <p>Path to the .frcmod files for the morph.</p> </li> <li> <code>pair_morphfrmocs_tests_dir</code>           \u2013            <p>Path to the location where a test is carried out with .frcmod</p> </li> <li> <code>pair_unique_atom_names_dir</code>           \u2013            <p>Location of the morph files with unique filenames.</p> </li> <li> <code>lig_unique_atom_names_dir</code>           \u2013            <p>Directory location for files with unique atom names.</p> </li> <li> <code>lig_frcmod_dir</code>           \u2013            <p>Directory location with the .frcmod created for each ligand.</p> </li> <li> <code>lig_acprep_dir</code>           \u2013            <p>Directory location where the .ac charges are converted into the .mol2 format.</p> </li> <li> <code>lig_dir</code>           \u2013            <p>Directory location with the .mol2 files.</p> </li> </ul> Source code in <code>ties/config.py</code> <pre><code>def __init__(self, **kwargs):\n    # set the path to the scripts\n    self.code_root = pathlib.Path(os.path.dirname(__file__))\n\n    # scripts/input files,\n    # these are specific to the host\n    self.script_dir = self.code_root / \"scripts\"\n    self.namd_script_dir = self.script_dir / \"namd\"\n    self.ambertools_script_dir = self.script_dir / \"ambertools\"\n    self.tleap_check_protein = self.ambertools_script_dir / \"check_prot.in\"\n    self.vmd_vis_script = self.script_dir / \"vmd\" / \"vis_morph.vmd\"\n    self.vmd_vis_script_sh = self.script_dir / \"vmd\" / \"vis_morph.sh\"\n\n    self.unique_atom_names = False\n\n    self._workdir = None\n    self._antechamber_dr = False\n    self._ambertools_home = None\n\n    self._protein = None\n\n    self._ligand_net_charge = None\n    self._atom_pair_q_atol = 0.1\n    self._net_charge_threshold = 0.1\n    self._redistribute_q_over_unmatched = True\n    self._allow_disjoint_components = False\n    # use only the element in the superimposition rather than the specific atom type\n    self._use_rdkit_mcs = True\n    self._use_element_in_superimposition = True\n    self._partial_ring_allowed = False\n    self.starting_pairs_heuristics = True\n    # weights in choosing the best MCS, the weighted sum of \"(1 - MCS fraction) and RMSD\".\n    self.weights_ratio = [1, 0]\n\n    # coordinates\n    self._align_molecules_using_mcs = False\n    self.align_add_removed_mcs = False\n    self._use_original_coor = False\n    self._coordinates_file = None\n\n    self._ligand_files = set()\n    self._manually_matched_atom_pairs = None\n    self._manually_mismatched_pairs = None\n    self._ligands_contain_q = None\n\n    self._ligand_tleap_in = None\n    self._complex_tleap_in = None\n\n    self._superimposition_starting_pairs = None\n    self._superimposition_starting_heuristic = 0.6\n\n    self._protein_ff = None\n    self._ligand_ff = \"leaprc.gaff\"\n    self._ligand_ff_name = \"gaff\"\n\n    # MD/NAMD production input file\n    self._md_engine = \"namd\"\n    # default to modern CPU version\n    self.namd_version = \"2.14\"\n    self._lambda_rep_dir_tree = False\n\n    # experimental\n    self._use_hybrid_single_dual_top = False\n    self._ignore_charges_completely = False\n\n    self.ligands = None\n\n    # if True, do not allow ligands with the same ligand name\n    self.uses_cmd = False\n\n    # assign all the initial configuration values\n    self.set_configs(**kwargs)\n\n    # logging\n    self.logging_breakdown = False\n    self.logging_formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n    self.logging_level = logging.INFO\n</code></pre>"},{"location":"api/config/#ties.Config.workdir","title":"workdir  <code>property</code> <code>writable</code>","text":"<pre><code>workdir\n</code></pre> <p>Working directory for antechamber calls. If None, a temporary directory in /tmp/ will be used.</p> <p>:return: Work dir :rtype: str</p>"},{"location":"api/config/#ties.Config.protein","title":"protein  <code>property</code> <code>writable</code>","text":"<pre><code>protein\n</code></pre> <p>Path to the protein</p> <p>:return: Protein filename :rtype: str</p>"},{"location":"api/config/#ties.Config.ligand_files","title":"ligand_files  <code>property</code> <code>writable</code>","text":"<pre><code>ligand_files\n</code></pre> <p>A list of ligand filenames. :return:</p>"},{"location":"api/config/#ties.Config.ambertools_home","title":"ambertools_home  <code>property</code> <code>writable</code>","text":"<pre><code>ambertools_home\n</code></pre> <p>Ambertools HOME path. If not configured, the env variable AMBERHOME as AMBER_PREFIX will be checked.</p> <p>:return: ambertools path</p>"},{"location":"api/config/#ties.Config.ambertools_antechamber","title":"ambertools_antechamber  <code>property</code>","text":"<pre><code>ambertools_antechamber\n</code></pre> <p>Antechamber path based on the .ambertools_home</p> <p>:return:</p>"},{"location":"api/config/#ties.Config.ambertools_parmchk2","title":"ambertools_parmchk2  <code>property</code>","text":"<pre><code>ambertools_parmchk2\n</code></pre> <p>Parmchk2 path based on the .ambertools_home :return:</p>"},{"location":"api/config/#ties.Config.ambertools_tleap","title":"ambertools_tleap  <code>property</code>","text":"<pre><code>ambertools_tleap\n</code></pre> <p>Tleap path based on the .ambertools_home :return:</p>"},{"location":"api/config/#ties.Config.antechamber_dr","title":"antechamber_dr  <code>property</code> <code>writable</code>","text":"<pre><code>antechamber_dr\n</code></pre> <p>Whether to use -dr setting when calling antechamber.</p> <p>:return:</p>"},{"location":"api/config/#ties.Config.ligand_net_charge","title":"ligand_net_charge  <code>property</code> <code>writable</code>","text":"<pre><code>ligand_net_charge\n</code></pre> <p>The ligand charge. If not provided, neutral charge is assumed. The charge is necessary for calling antechamber (-nc).</p> <p>:return:</p>"},{"location":"api/config/#ties.Config.coordinates_file","title":"coordinates_file  <code>property</code> <code>writable</code>","text":"<pre><code>coordinates_file\n</code></pre> <p>A file from which coordinate can be taken.</p> <p>:return:</p>"},{"location":"api/config/#ties.Config.atom_pair_q_atol","title":"atom_pair_q_atol  <code>property</code> <code>writable</code>","text":"<pre><code>atom_pair_q_atol\n</code></pre> <p>It defines the maximum difference in charge between any two superimposed atoms a1 and a2. If the two atoms differ in charge more than this value, they will be unmatched and added to the alchemical regions.</p> <p>:return: default (0.1e) :rtype: float</p>"},{"location":"api/config/#ties.Config.net_charge_threshold","title":"net_charge_threshold  <code>property</code> <code>writable</code>","text":"<pre><code>net_charge_threshold\n</code></pre> <p>Defines how much the superimposed regions can, in total, differ in charge. If the total exceeds the thresholds, atom pairs will be unmatched until the threshold is met.</p> <p>:return: default (0.1e) :rtype: float</p>"},{"location":"api/config/#ties.Config.ignore_charges_completely","title":"ignore_charges_completely  <code>property</code> <code>writable</code>","text":"<pre><code>ignore_charges_completely\n</code></pre> <p>Ignore the charges during the superimposition. Useful for debugging. :return: default (False) :rtype: bool</p>"},{"location":"api/config/#ties.Config.allow_disjoint_components","title":"allow_disjoint_components  <code>property</code> <code>writable</code>","text":"<pre><code>allow_disjoint_components\n</code></pre> <p>Defines whether there might be multiple superimposed areas that are separated by alchemical region.</p> <p>:return: default (False) :rtype: bool</p>"},{"location":"api/config/#ties.Config.use_element_in_superimposition","title":"use_element_in_superimposition  <code>property</code> <code>writable</code>","text":"<pre><code>use_element_in_superimposition\n</code></pre> <p>Use element rather than the actual atom type for the superimposition during the joint-traversal of the two molecules.</p> <p>:return: default (False) :rtype: bool</p>"},{"location":"api/config/#ties.Config.align_molecules_using_mcs","title":"align_molecules_using_mcs  <code>property</code> <code>writable</code>","text":"<pre><code>align_molecules_using_mcs\n</code></pre> <p>After determining the maximum common substructure (MCS), use it to align the coordinates of the second molecule to the first.</p> <p>:return: default (False) :rtype: bool</p>"},{"location":"api/config/#ties.Config.use_original_coor","title":"use_original_coor  <code>property</code> <code>writable</code>","text":"<pre><code>use_original_coor\n</code></pre> <p>Antechamber when assigning charges can modify the charges slightly. If that's the case, use the original charges in order to correct this slight divergence in coordinates.</p> <p>:return: default (?) :rtype: bool</p>"},{"location":"api/config/#ties.Config.ligands_contain_q","title":"ligands_contain_q  <code>property</code> <code>writable</code>","text":"<pre><code>ligands_contain_q\n</code></pre> <p>If not provided, it tries to deduce whether charges are provided. If all charges are set to 0, then it assumes that charges are not provided.</p> <p>If set to False explicitly, charges are ignored and computed again.</p> <p>:return: default (None) :rtype: bool</p>"},{"location":"api/config/#ties.Config.superimposition_starting_pairs","title":"superimposition_starting_pairs  <code>property</code> <code>writable</code>","text":"<pre><code>superimposition_starting_pairs\n</code></pre> <p>Set a starting pair for the superimposition to narrow down the MCS search. E.g. \"C2-C12\"</p> <p>:rtype: str</p>"},{"location":"api/config/#ties.Config.manually_matched_atom_pairs","title":"manually_matched_atom_pairs  <code>property</code> <code>writable</code>","text":"<pre><code>manually_matched_atom_pairs\n</code></pre> <p>Either a list of pairs or a file with a list of pairs of atoms that should be superimposed/matched.</p> <p>:return:</p>"},{"location":"api/config/#ties.Config.manually_mismatched_pairs","title":"manually_mismatched_pairs  <code>property</code> <code>writable</code>","text":"<pre><code>manually_mismatched_pairs\n</code></pre> <p>A path to a file with a list of a pairs that should be mismatched.</p>"},{"location":"api/config/#ties.Config.protein_ff","title":"protein_ff  <code>property</code> <code>writable</code>","text":"<pre><code>protein_ff\n</code></pre> <p>The protein forcefield to be used by ambertools for the protein parameterisation.</p> <p>:return: default (leaprc.ff19SB) :rtype: string</p>"},{"location":"api/config/#ties.Config.md_engine","title":"md_engine  <code>property</code> <code>writable</code>","text":"<pre><code>md_engine\n</code></pre> <p>The MD engine, with the supported values NAMD2.13, NAMD2.14, NAMD3 and OpenMM</p> <p>:return: NAMD2.13, NAMD2.14, NAMD3 and OpenMM :rtype: string</p>"},{"location":"api/config/#ties.Config.ligand_ff","title":"ligand_ff  <code>property</code>","text":"<pre><code>ligand_ff\n</code></pre> <p>The forcefield for the ligand.</p>"},{"location":"api/config/#ties.Config.ligand_ff_name","title":"ligand_ff_name  <code>property</code> <code>writable</code>","text":"<pre><code>ligand_ff_name\n</code></pre> <p>Either GAFF or GAFF2</p> <p>:return:</p>"},{"location":"api/config/#ties.Config.redistribute_q_over_unmatched","title":"redistribute_q_over_unmatched  <code>property</code> <code>writable</code>","text":"<pre><code>redistribute_q_over_unmatched\n</code></pre> <p>The superimposed and matched atoms have every slightly different charges. Taking an average charge between any two atoms introduces imbalances in the net charge of the alchemical regions, due to the different charge distribution.</p> <p>:return: default(True)</p>"},{"location":"api/config/#ties.Config.use_hybrid_single_dual_top","title":"use_hybrid_single_dual_top  <code>property</code> <code>writable</code>","text":"<pre><code>use_hybrid_single_dual_top\n</code></pre> <p>Hybrid single dual topology (experimental). Currently not implemented.</p> <p>:return: default(False).</p>"},{"location":"api/config/#ties.Config.ligand_tleap_in","title":"ligand_tleap_in  <code>property</code>","text":"<pre><code>ligand_tleap_in\n</code></pre> <p>The name of the tleap input file for ambertools for the ligand.</p> <p>:return: Default ('leap_ligand.in') :rtype: string</p>"},{"location":"api/config/#ties.Config.complex_tleap_in","title":"complex_tleap_in  <code>property</code>","text":"<pre><code>complex_tleap_in\n</code></pre> <p>The tleap input file for the complex.</p> <p>:return: Default 'leap_complex.in' :type: string</p>"},{"location":"api/config/#ties.Config.prep_dir","title":"prep_dir  <code>property</code>","text":"<pre><code>prep_dir\n</code></pre> <p>Path to the <code>prep</code> directory. Currently in the <code>workdir</code></p> <p>:return: Default (workdir/prep)</p>"},{"location":"api/config/#ties.Config.pair_morphfrcmods_dir","title":"pair_morphfrcmods_dir  <code>property</code>","text":"<pre><code>pair_morphfrcmods_dir\n</code></pre> <p>Path to the .frcmod files for the morph.</p> <p>:return: Default (workdir/prep/morph_frcmods)</p>"},{"location":"api/config/#ties.Config.pair_morphfrmocs_tests_dir","title":"pair_morphfrmocs_tests_dir  <code>property</code>","text":"<pre><code>pair_morphfrmocs_tests_dir\n</code></pre> <p>Path to the location where a test is carried out with .frcmod</p> <p>:return: Default (workdir/prep/morph_frcmods/tests)</p>"},{"location":"api/config/#ties.Config.pair_unique_atom_names_dir","title":"pair_unique_atom_names_dir  <code>property</code>","text":"<pre><code>pair_unique_atom_names_dir\n</code></pre> <p>Location of the morph files with unique filenames.</p> <p>:return: Default (workdir/prep/morph_unique_atom_names)</p>"},{"location":"api/config/#ties.Config.lig_unique_atom_names_dir","title":"lig_unique_atom_names_dir  <code>property</code>","text":"<pre><code>lig_unique_atom_names_dir\n</code></pre> <p>Directory location for files with unique atom names.</p> <p>:return: Default (workdir/prep/unique_atom_names)</p>"},{"location":"api/config/#ties.Config.lig_frcmod_dir","title":"lig_frcmod_dir  <code>property</code>","text":"<pre><code>lig_frcmod_dir\n</code></pre> <p>Directory location with the .frcmod created for each ligand.</p> <p>:return: Default (workdir/prep/ligand_frcmods)</p>"},{"location":"api/config/#ties.Config.lig_acprep_dir","title":"lig_acprep_dir  <code>property</code>","text":"<pre><code>lig_acprep_dir\n</code></pre> <p>Directory location where the .ac charges are converted into the .mol2 format.</p> <p>:return: Default (workdir/prep/acprep_to_mol2)</p>"},{"location":"api/config/#ties.Config.lig_dir","title":"lig_dir  <code>property</code>","text":"<pre><code>lig_dir\n</code></pre> <p>Directory location with the .mol2 files.</p> <p>:return: Default (workdir/mol2)</p>"},{"location":"api/config/#ties.Config.get_serializable","title":"get_serializable","text":"<pre><code>get_serializable()\n</code></pre> <p>Get a JSON serializable structure of the config.</p> <p>pathlib.Path is not JSON serializable, so replace it with str</p> <p>todo - consider capturing all information about the system here, including each suptop.get_serializable() so that you can record specific information such as the charge changes etc.</p> <p>:return: Dictionary {key:value} with the settings :rtype: Dictionary</p> Source code in <code>ties/config.py</code> <pre><code>def get_serializable(self):\n    \"\"\"\n    Get a JSON serializable structure of the config.\n\n    pathlib.Path is not JSON serializable, so replace it with str\n\n    todo - consider capturing all information about the system here,\n    including each suptop.get_serializable() so that you can record\n    specific information such as the charge changes etc.\n\n    :return: Dictionary {key:value} with the settings\n    :rtype: Dictionary\n    \"\"\"\n\n    exclude = [\n        \"_workdir_tempdir\",  # exists (during runtime) for cleaning up purposes\n    ]\n\n    host_specific = [\n        \"code_root\",\n        \"script_dir0\",\n        \"namd_script_dir\",\n        \"ambertools_script_dir\",\n        \"tleap_check_protein\",\n        \"vmd_vis_script\",\n    ]\n\n    ser = {}\n    for k, v in self.__dict__.items():\n        if k in host_specific or k in exclude:\n            continue\n\n        if type(v) is logging.Formatter:\n            continue\n\n        if type(v) is pathlib.PosixPath:\n            v = str(v)\n\n        # account for the ligands being pathlib objects\n        if k == \"ligands\" and v is not None:\n            # a list of ligands, convert to strings\n            v = [str(lig) for lig in v]\n        if k == \"_ligand_files\":\n            continue\n\n        ser[k] = v\n\n    return ser\n</code></pre>"},{"location":"api/ligand/","title":"Ligand","text":""},{"location":"api/ligand/#ties.Ligand","title":"Ligand","text":"<pre><code>Ligand(ligand, config=None, save=True, use_general_type=True)\n</code></pre> <p>The ligand helper class. Helps to load and manage the different copies of the ligand file. Specifically, it tracks the different copies of the original input files as it is transformed (e.g. charge assignment).</p> <p>:param ligand: ligand filepath or RDKit molecule :type ligand: string :param config: Optional configuration from which the relevant ligand settings can be used :type config: :class:<code>Config</code> :param save: write a file with unique atom names for further inspection :type save: bool</p> <p>Methods:</p> <ul> <li> <code>antechamber_prepare_mol2</code>             \u2013              <p>Converts the ligand into a .mol2 format.</p> </li> <li> <code>generate_frcmod</code>             \u2013              <p>params</p> </li> <li> <code>correct_atom_names</code>             \u2013              <p>Ensure that each atom name:</p> </li> <li> <code>are_atom_names_correct</code>             \u2013              <p>Checks if atom names:</p> </li> </ul> Source code in <code>ties/ligand.py</code> <pre><code>def __init__(self, ligand, config=None, save=True, use_general_type=True):\n    \"\"\"Constructor method\"\"\"\n\n    self.save = save\n    # save workplace root\n    self.config = Config() if config is None else config\n\n    if isinstance(ligand, rdkit.Chem.Mol):\n        pmd_structure = parsing.pmd_structure_from_rdmol(ligand)\n        atoms, bonds = parsing.get_atoms_bonds_from_pmd_structure(pmd_structure)\n\n        # at the moment we rely on paths as well\n        # make this molecule available as a file\n        short_uuid = str(uuid.uuid4())[:8]\n        lig_path = self.config.workdir / f\"{short_uuid}.sdf\"\n        with rdkit.Chem.SDWriter(lig_path) as SD:\n            SD.write(ligand)\n\n        ligand = lig_path\n    else:\n        # fixme - move use_general_type parameter to config for later\n        atoms, bonds, pmd_structure = parsing.get_atoms_bonds_and_parmed_structure(\n            ligand, use_general_type=use_general_type\n        )\n\n    self.pmd_structure = pmd_structure\n    self.atoms = atoms\n    self.bonds = bonds\n\n    self.config.ligand_files = ligand\n\n    self.original_input = Path(ligand).absolute()\n\n    # internal name without an extension\n    self.internal_name = self.original_input.stem\n\n    # last used representative Path file\n    self.current = self.original_input\n\n    self._renaming_map = None\n    self.ligand_with_uniq_atom_names = None\n</code></pre>"},{"location":"api/ligand/#ties.Ligand.antechamber_prepare_mol2","title":"antechamber_prepare_mol2","text":"<pre><code>antechamber_prepare_mol2(**kwargs)\n</code></pre> <p>Converts the ligand into a .mol2 format.</p> <p>BCC charges are generated if missing or requested. It calls antechamber (the charge type -c is not used if user prefers to use their charges). Any DU atoms created in the antechamber call are removed.</p> <p>:param atom_type: Atom type bla bla :type atom_type: :param net_charge: :type net_charge: int</p> Source code in <code>ties/ligand.py</code> <pre><code>def antechamber_prepare_mol2(self, **kwargs):\n    \"\"\"\n    Converts the ligand into a .mol2 format.\n\n    BCC charges are generated if missing or requested.\n    It calls antechamber (the charge type -c is not used if user prefers to use their charges).\n    Any DU atoms created in the antechamber call are removed.\n\n    :param atom_type: Atom type bla bla\n    :type atom_type:\n    :param net_charge:\n    :type net_charge: int\n    \"\"\"\n    self.config.set_configs(**kwargs)\n\n    if self.config.ligands_contain_q or not self.config.antechamber_charge_type:\n        logger.info(\n            f\"Antechamber: User-provided atom charges will be reused ({self.current.name})\"\n        )\n\n    mol2_cwd = self.config.lig_dir / self.internal_name\n\n    # prepare the directory\n    mol2_cwd.mkdir(parents=True, exist_ok=True)\n    mol2_target = mol2_cwd / f\"{self.internal_name}.mol2\"\n\n    # do not redo if the target file exists\n    if not (mol2_target).is_file():\n        log_filename = mol2_cwd / \"antechamber.log\"\n        with open(log_filename, \"w\") as LOG:\n            try:\n                cmd = [\n                    self.config.ambertools_antechamber,\n                    \"-i\",\n                    self.current,\n                    \"-fi\",\n                    self.current.suffix[1:],\n                    \"-o\",\n                    mol2_target,\n                    \"-fo\",\n                    \"mol2\",\n                    \"-at\",\n                    self.config.ligand_ff_name,\n                    \"-nc\",\n                    str(self.config.ligand_net_charge),\n                    \"-dr\",\n                    str(self.config.antechamber_dr),\n                ] + self.config.antechamber_charge_type\n                subprocess.run(\n                    cmd,\n                    cwd=mol2_cwd,\n                    stdout=LOG,\n                    stderr=LOG,\n                    check=True,\n                    text=True,\n                    timeout=60 * 30,  # 30 minutes\n                )\n            except subprocess.CalledProcessError as ProcessError:\n                raise Exception(\n                    f\"Could not convert the ligand into .mol2 file with antechamber. \"\n                    f\"See the log and its directory: {log_filename} . \"\n                    f\"Command used: {' '.join(map(str, cmd))}\"\n                ) from ProcessError\n        logger.debug(\n            f\"Converted {self.original_input} into .mol2, Log: {log_filename}\"\n        )\n    else:\n        logger.info(f\"File {mol2_target} already exists. Skipping. \")\n\n    self.antechamber_mol2 = mol2_target\n    self.current = mol2_target\n\n    # remove any DUMMY DU atoms in the .mol2 atoms\n    self._removeDU_atoms()\n</code></pre>"},{"location":"api/ligand/#ties.Ligand.generate_frcmod","title":"generate_frcmod","text":"<pre><code>generate_frcmod(**kwargs)\n</code></pre> <p>params  - parmchk2  - atom_type</p> Source code in <code>ties/ligand.py</code> <pre><code>def generate_frcmod(self, **kwargs):\n    \"\"\"\n    params\n     - parmchk2\n     - atom_type\n    \"\"\"\n    self.config.set_configs(**kwargs)\n\n    logger.debug(f\"INFO: frcmod for {self} was computed before. Not repeating.\")\n    if hasattr(self, \"frcmod\"):\n        return\n\n    # fixme - work on the file handles instaed of the constant stitching\n    logger.debug(f\"Parmchk2: generate the .frcmod for {self.internal_name}.mol2\")\n\n    # prepare cwd\n    cwd = self.config.lig_frcmod_dir / self.internal_name\n    if not cwd.is_dir():\n        cwd.mkdir(parents=True, exist_ok=True)\n\n    target_frcmod = f\"{self.internal_name}.frcmod\"\n    log_filename = cwd / \"parmchk2.log\"\n    with open(log_filename, \"w\") as LOG:\n        try:\n            subprocess.run(\n                [\n                    self.config.ambertools_parmchk2,\n                    \"-i\",\n                    self.current,\n                    \"-o\",\n                    target_frcmod,\n                    \"-f\",\n                    \"mol2\",\n                    \"-s\",\n                    self.config.ligand_ff_name,\n                ],\n                stdout=LOG,\n                stderr=LOG,\n                check=True,\n                text=True,\n                cwd=cwd,\n                timeout=20,  # 20 seconds\n            )\n        except subprocess.CalledProcessError as E:\n            raise Exception(\n                f\"GAFF Error: Could not generate FRCMOD for file: {self.current} . \"\n                f\"See more here: {log_filename}\"\n            ) from E\n\n    logger.debug(f\"Parmchk2: created frcmod: {target_frcmod}\")\n    self.frcmod = cwd / target_frcmod\n</code></pre>"},{"location":"api/ligand/#ties.Ligand.correct_atom_names","title":"correct_atom_names","text":"<pre><code>correct_atom_names()\n</code></pre> Ensure that each atom name <ul> <li>is unique</li> <li>has letter followed by digits</li> <li>has max 4 characters</li> </ul> <p>E.g. C17, NX23</p> <p>:param self.save: if the path is provided, the updated file     will be saved with the unique names and a handle to the new file (ParmEd) will be returned.</p> Source code in <code>ties/ligand.py</code> <pre><code>def correct_atom_names(self):\n    \"\"\"\n    Ensure that each atom name:\n     - is unique\n     - has letter followed by digits\n     - has max 4 characters\n    E.g. C17, NX23\n\n    :param self.save: if the path is provided, the updated file\n        will be saved with the unique names and a handle to the new file (ParmEd) will be returned.\n    \"\"\"\n    if self.are_atom_names_correct():\n        return\n\n    logger.debug(f\"Ligand {self.internal_name} will have its atom names renamed. \")\n\n    ligand = parmed.load_file(str(self.current), structure=True)\n\n    logger.debug(\n        f\"Atom names in the molecule ({self.original_input}/{self.internal_name}) are either not unique \"\n        f\"or do not follow NameDigit format (e.g. C15). Renaming\"\n    )\n    _, renaming_map = get_new_atom_names(ligand.atoms)\n    self._renaming_map = renaming_map\n    logger.debug(f\"Rename map: {renaming_map}\")\n\n    # save the output here\n    os.makedirs(self.config.lig_unique_atom_names_dir, exist_ok=True)\n\n    ligand_with_uniq_atom_names = self.config.lig_unique_atom_names_dir / (\n        self.internal_name + self.current.suffix\n    )\n    if self.save:\n        ligand.save(str(ligand_with_uniq_atom_names))\n\n    self.ligand_with_uniq_atom_names = ligand_with_uniq_atom_names\n    self.parmed = ligand\n    # this object is now represented by the updated ligand\n    self.current = ligand_with_uniq_atom_names\n</code></pre>"},{"location":"api/ligand/#ties.Ligand.are_atom_names_correct","title":"are_atom_names_correct","text":"<pre><code>are_atom_names_correct()\n</code></pre> Checks if atom names <ul> <li>are unique</li> <li>have a correct format \"LettersNumbers\" e.g. C17</li> </ul> Source code in <code>ties/ligand.py</code> <pre><code>def are_atom_names_correct(self):\n    \"\"\"\n    Checks if atom names:\n     - are unique\n     - have a correct format \"LettersNumbers\" e.g. C17\n    \"\"\"\n    ligand = parmed.load_file(str(self.current), structure=True)\n    atom_names = [a.name for a in ligand.atoms]\n\n    are_uniqe = len(set(atom_names)) == len(atom_names)\n\n    return are_uniqe\n</code></pre>"},{"location":"api/pair/","title":"Pair","text":""},{"location":"api/pair/#ties.Pair","title":"Pair","text":"<pre><code>Pair(ligA, ligB, config=None, **kwargs)\n</code></pre> <p>Facilitates the creation of morphs. It offers functionality related to a pair of ligands (a transformation).</p> <p>:param ligA: The ligand to be used as the starting state for the transformation. :type ligA: :class:<code>Ligand</code> or string :param ligB: The ligand to be used as the ending point of the transformation. :type ligB: :class:<code>Ligand</code> or string :param config: The configuration object holding all settings. :type config: :class:<code>Config</code></p> <p>fixme - list all relevant kwargs here</p> <pre><code>param ligand_net_charge: integer, net charge of each ligand (has to be the same)\n</code></pre> <p>Methods:</p> <ul> <li> <code>superimpose</code>             \u2013              <p>Please see :class:<code>Config</code> class for the documentation of kwargs. The passed kwargs overwrite the config</p> </li> <li> <code>set_suptop</code>             \u2013              <p>Attach a SuperimposedTopology object along with the ParmEd objects for the ligA and ligZ.</p> </li> <li> <code>make_atom_names_unique</code>             \u2013              <p>Ensure that each that atoms across the two ligands have unique names.</p> </li> <li> <code>check_json_file</code>             \u2013              <p>Performance optimisation in case TIES is rerun again. Return the first matched atoms which</p> </li> <li> <code>merge_frcmod_files</code>             \u2013              <p>Merges the .frcmod files generated for each ligand separately, simply by adding them together.</p> </li> <li> <code>overlap_fractions</code>             \u2013              <p>Calculate the size of the common area.</p> </li> </ul> Source code in <code>ties/pair.py</code> <pre><code>def __init__(self, ligA, ligB, config=None, **kwargs):\n    \"\"\"\n    Please use the Config class for the documentation of the possible kwargs.\n    Each kwarg is passed to the config class.\n\n    fixme - list all relevant kwargs here\n\n        param ligand_net_charge: integer, net charge of each ligand (has to be the same)\n    \"\"\"\n\n    # create a new config if it is not provided\n    self.config = ties.config.Config() if config is None else config\n\n    # channel all config variables to the config class\n    self.config.set_configs(**kwargs)\n\n    # tell Config about the ligands if necessary\n    if self.config.ligands is None:\n        self.config.ligands = [ligA, ligB]\n\n    # create ligands if they're just paths\n    if isinstance(ligA, ties.ligand.Ligand):\n        self.ligA = ligA\n    else:\n        self.ligA = ties.ligand.Ligand(ligA, self.config)\n\n    if isinstance(ligB, ties.ligand.Ligand):\n        self.ligB = ligB\n    else:\n        self.ligB = ties.ligand.Ligand(ligB, self.config)\n\n    # initialise the filepaths to the molecules that morph\n    self.current_ligA = self.ligA.current\n    self.current_ligB = self.ligB.current\n\n    self.internal_name = f\"{self.ligA.internal_name}_{self.ligB.internal_name}\"\n    self.mol2 = None\n    self.pdb = None\n    self.summary = None\n    self.suptop = None\n    self.mda_l1 = None\n    self.mda_l2 = None\n    self.distance = None\n</code></pre>"},{"location":"api/pair/#ties.Pair.superimpose","title":"superimpose","text":"<pre><code>superimpose(**kwargs)\n</code></pre> <p>Please see :class:<code>Config</code> class for the documentation of kwargs. The passed kwargs overwrite the config object passed in the constructor.</p> <p>fixme - list all relevant kwargs here</p> Source code in <code>ties/pair.py</code> <pre><code>def superimpose(self, **kwargs):\n    \"\"\"\n    Please see :class:`Config` class for the documentation of kwargs. The passed kwargs overwrite the config\n    object passed in the constructor.\n\n    fixme - list all relevant kwargs here\n    \"\"\"\n    self.config.set_configs(**kwargs)\n\n    self.ligA.use_element(self.config._use_element_in_superimposition)\n    self.ligB.use_element(self.config._use_element_in_superimposition)\n\n    # extract data from the ligands\n    ligA_atoms = self.ligA.atoms\n    ligA_pmd_structure = self.ligA.pmd_structure\n\n    ligB_atoms = self.ligB.atoms\n    ligB_pmd_structure = self.ligB.pmd_structure\n\n    # TODO - check that these atoms exist, use indices instead of names, ideally C:7 (Element:Idx)\n    new_mismatch_names = []\n    for a, z in self.config.manually_mismatched_pairs:\n        raise NotImplementedError(\"renamed not needed\")\n        new_names = (self.ligA.rev_renaming_map[a], self.ligB.rev_renaming_map[z])\n        logger.debug(\n            f\"Selecting mismatching atoms. The mismatch {(a, z)}) was renamed to {new_names}\"\n        )\n        new_mismatch_names.append(new_names)\n\n    # fixme - this should be moved out of here,\n    #  ideally there would be a function in the main interface for this\n    manual_match = (\n        []\n        if self.config.manually_matched_atom_pairs is None\n        else self.config.manually_matched_atom_pairs\n    )\n    starting_node_pairs = []\n    for l_aname, r_aname in manual_match:\n        # find the starting node pairs, ie the manually matched pair(s)\n        found_left_node = None\n        for atom in ligA_atoms:\n            if l_aname == atom.name:\n                found_left_node = atom\n        if found_left_node is None:\n            raise ValueError(\n                f'Manual Matching: could not find an atom name: \"{l_aname}\" in the left molecule'\n            )\n\n        found_right_node = None\n        for atom in ligB_atoms:\n            if r_aname == atom.name:\n                found_right_node = atom\n        if found_right_node is None:\n            raise ValueError(\n                f'Manual Matching: could not find an atom name: \"{r_aname}\" in the right molecule'\n            )\n\n        starting_node_pairs.append([found_left_node, found_right_node])\n\n    if starting_node_pairs:\n        logger.debug(f\"Starting nodes will be used: {starting_node_pairs}\")\n\n    logging_key = str(self)\n\n    # fixme - simplify to only take the ParmEd as input\n    suptop = superimpose_topologies(\n        ligA_atoms,\n        ligB_atoms,\n        disjoint_components=self.config.allow_disjoint_components,\n        net_charge_filter=True,\n        pair_charge_atol=self.config.atom_pair_q_atol,\n        net_charge_threshold=self.config.net_charge_threshold,\n        redistribute_charges_over_unmatched=self.config.redistribute_q_over_unmatched,\n        ignore_charges_completely=self.config.ignore_charges_completely,\n        ignore_bond_types=True,\n        ignore_coords=False,\n        partial_rings_allowed=self.config.partial_ring_allowed,\n        align_molecules=self.config.align_molecules_using_mcs,\n        use_general_type=self.config.use_element_in_superimposition,\n        # fixme - not the same ... use_element_in_superimposition,\n        use_only_element=False,\n        starting_pairs_heuristics=self.config.superimposition_starting_heuristic,  # fixme - add to config\n        force_mismatch=new_mismatch_names,\n        starting_node_pairs=starting_node_pairs,\n        parmed_ligA=ligA_pmd_structure,\n        parmed_ligB=ligB_pmd_structure,\n        starting_pair_seed=self.config.superimposition_starting_pairs,\n        logging_key=logging_key,\n        config=self.config,\n    )\n\n    self.set_suptop(suptop, ligA_pmd_structure, ligB_pmd_structure)\n    # attach the used config to the suptop\n\n    if suptop is not None:\n        suptop.config = self.config\n        # attach the morph to the suptop\n        suptop.morph = self\n\n    return suptop\n</code></pre>"},{"location":"api/pair/#ties.Pair.set_suptop","title":"set_suptop","text":"<pre><code>set_suptop(suptop, parmed_ligA, parmed_ligZ)\n</code></pre> <p>Attach a SuperimposedTopology object along with the ParmEd objects for the ligA and ligZ.</p> <p>:param suptop: :class:<code>SuperimposedTopology</code> :param parmed_ligA: An ParmEd for the ligA :param parmed_ligZ: An ParmEd for the ligZ</p> Source code in <code>ties/pair.py</code> <pre><code>def set_suptop(self, suptop, parmed_ligA, parmed_ligZ):\n    \"\"\"\n    Attach a SuperimposedTopology object along with the ParmEd objects for the ligA and ligZ.\n\n    :param suptop: :class:`SuperimposedTopology`\n    :param parmed_ligA: An ParmEd for the ligA\n    :param parmed_ligZ: An ParmEd for the ligZ\n    \"\"\"\n    self.suptop = suptop\n    self.parmed_ligA = parmed_ligA\n    self.parmed_ligZ = parmed_ligZ\n</code></pre>"},{"location":"api/pair/#ties.Pair.make_atom_names_unique","title":"make_atom_names_unique","text":"<pre><code>make_atom_names_unique(out_ligA_filename=None, out_ligZ_filename=None, save=True)\n</code></pre> <p>Ensure that each that atoms across the two ligands have unique names.</p> <p>While renaming atoms, start with the element (C, N, ..) followed by  the count so far (e.g. C1, C2, N1).</p> <p>Resnames are set to \"INI\" and \"FIN\", this is useful for the hybrid dual topology.</p> <p>:param out_ligA_filename: The new filenames for the ligands with renamed atoms. If None, the default     naming convention is used. :type out_ligA_filename: string or bool :param out_ligZ_filename: The new filenames for the ligands with renamed atoms. If None, the default     naming convention is used. :type out_ligZ_filename: string or bool :param save: Whether to save to the disk the ligands after renaming the atoms :type save: bool</p> Source code in <code>ties/pair.py</code> <pre><code>def make_atom_names_unique(\n    self, out_ligA_filename=None, out_ligZ_filename=None, save=True\n):\n    \"\"\"\n    Ensure that each that atoms across the two ligands have unique names.\n\n    While renaming atoms, start with the element (C, N, ..) followed by\n     the count so far (e.g. C1, C2, N1).\n\n    Resnames are set to \"INI\" and \"FIN\", this is useful for the hybrid dual topology.\n\n    :param out_ligA_filename: The new filenames for the ligands with renamed atoms. If None, the default\n        naming convention is used.\n    :type out_ligA_filename: string or bool\n    :param out_ligZ_filename: The new filenames for the ligands with renamed atoms. If None, the default\n        naming convention is used.\n    :type out_ligZ_filename: string or bool\n    :param save: Whether to save to the disk the ligands after renaming the atoms\n    :type save: bool\n    \"\"\"\n\n    # The A ligand is a template for the renaming\n    self.ligA.correct_atom_names()\n\n    # load both ligands\n    left = parmed.load_file(str(self.ligA.current), structure=True)\n    right = parmed.load_file(str(self.ligB.current), structure=True)\n\n    common_atom_names = {a.name for a in right.atoms}.intersection(\n        {a.name for a in left.atoms}\n    )\n    atom_names_overlap = len(common_atom_names) &gt; 0\n\n    if atom_names_overlap or not self.ligB.are_atom_names_correct():\n        logger.debug(\n            f\"Renaming ({self.ligA.internal_name}) molecule ({self.ligB.internal_name}) atom names are either reused or do not follow the correct format. \"\n        )\n        if atom_names_overlap:\n            logger.debug(f\"Common atom names: {common_atom_names}\")\n        name_counter_L_nodes = ties.helpers.get_atom_names_counter(left.atoms)\n        _, renaming_map = ties.helpers.get_new_atom_names(\n            right.atoms, name_counter=name_counter_L_nodes\n        )\n        self.ligB.renaming_map = renaming_map\n\n    # rename the residue names to INI and FIN\n    for atom in left.atoms:\n        atom.residue = \"INI\"\n    for atom in right.atoms:\n        atom.residue = \"FIN\"\n\n    # fixme - instead of using the save parameter, have a method pair.save(filename1, filename2) and\n    #  call it when necessary.\n    # prepare the destination directory\n    if not save:\n        return\n\n    if out_ligA_filename is None:\n        cwd = (\n            self.config.pair_unique_atom_names_dir\n            / f\"{self.ligA.internal_name}_{self.ligB.internal_name}\"\n        )\n        cwd.mkdir(parents=True, exist_ok=True)\n\n        self.current_ligA = cwd / (self.ligA.internal_name + \".mol2\")\n        self.current_ligB = cwd / (self.ligB.internal_name + \".mol2\")\n    else:\n        self.current_ligA = out_ligA_filename\n        self.current_ligB = out_ligZ_filename\n\n    # save the updated atom names\n    left.save(str(self.current_ligA))\n    right.save(str(self.current_ligB))\n</code></pre>"},{"location":"api/pair/#ties.Pair.check_json_file","title":"check_json_file","text":"<pre><code>check_json_file()\n</code></pre> <p>Performance optimisation in case TIES is rerun again. Return the first matched atoms which can be used as a seed for the superimposition.</p> <p>:return: If the superimposition was computed before, and the .json file is available,     gets one of the matched atoms. :rtype: [(ligA_atom, ligZ_atom)]</p> Source code in <code>ties/pair.py</code> <pre><code>def check_json_file(self):\n    \"\"\"\n    Performance optimisation in case TIES is rerun again. Return the first matched atoms which\n    can be used as a seed for the superimposition.\n\n    :return: If the superimposition was computed before, and the .json file is available,\n        gets one of the matched atoms.\n    :rtype: [(ligA_atom, ligZ_atom)]\n    \"\"\"\n    matching_json = (\n        self.config.workdir\n        / f\"fep_{self.ligA.internal_name}_{self.ligB.internal_name}.json\"\n    )\n    if not matching_json.is_file():\n        return None\n\n    return [list(json.load(matching_json.open())[\"matched\"].items())[0]]\n</code></pre>"},{"location":"api/pair/#ties.Pair.merge_frcmod_files","title":"merge_frcmod_files","text":"<pre><code>merge_frcmod_files(ligcom=None)\n</code></pre> <p>Merges the .frcmod files generated for each ligand separately, simply by adding them together.</p> <p>The duplication has no effect on the final generated topology parm7 top file.</p> <p>We are also testing the .frcmod here with the user's force field in order to check if the merge works correctly.</p> <p>:param ligcom: Either \"lig\" if only ligands are present, or \"com\" if the complex is present.     Helps with the directory structure. :type ligcom: string \"lig\" or \"com\"</p> Source code in <code>ties/pair.py</code> <pre><code>def merge_frcmod_files(self, ligcom=None):\n    \"\"\"\n    Merges the .frcmod files generated for each ligand separately, simply by adding them together.\n\n    The duplication has no effect on the final generated topology parm7 top file.\n\n    We are also testing the .frcmod here with the user's force field in order to check if\n    the merge works correctly.\n\n    :param ligcom: Either \"lig\" if only ligands are present, or \"com\" if the complex is present.\n        Helps with the directory structure.\n    :type ligcom: string \"lig\" or \"com\"\n    \"\"\"\n    ambertools_tleap = self.config.ambertools_tleap\n    ambertools_script_dir = self.config.ambertools_script_dir\n    if self.config.protein is None:\n        protein_ff = None\n    else:\n        protein_ff = self.config.protein_ff\n\n    ligand_ff = self.config.ligand_ff\n\n    frcmod_info1 = ties.helpers.parse_frcmod_sections(self.ligA.frcmod)\n    frcmod_info2 = ties.helpers.parse_frcmod_sections(self.ligB.frcmod)\n\n    cwd = self.config.workdir\n\n    # fixme: use the provided cwd here, otherwise this will not work if the wrong cwd is used\n    # have some conf module instead of this\n    if ligcom:\n        morph_frcmod = (\n            cwd\n            / f\"ties-{self.ligA.internal_name}-{self.ligB.internal_name}\"\n            / ligcom\n            / \"build\"\n            / \"hybrid.frcmod\"\n        )\n    else:\n        # fixme - clean up\n        morph_frcmod = (\n            cwd\n            / f\"ties-{self.ligA.internal_name}-{self.ligB.internal_name}\"\n            / \"build\"\n            / \"hybrid.frcmod\"\n        )\n    morph_frcmod.parent.mkdir(parents=True, exist_ok=True)\n    with open(morph_frcmod, \"w\") as FOUT:\n        FOUT.write(\"merged frcmod\\n\")\n\n        for section in [\"MASS\", \"BOND\", \"ANGLE\", \"DIHE\", \"IMPROPER\", \"NONBON\"]:\n            section_lines = frcmod_info1[section] + frcmod_info2[section]\n            FOUT.write(\"{0:s}\\n\".format(section))\n            for line in section_lines:\n                FOUT.write(\"{0:s}\".format(line))\n            FOUT.write(\"\\n\")\n\n        FOUT.write(\"\\n\\n\")\n\n    # this is our current frcmod file\n    self.frcmod = morph_frcmod\n\n    # as part of the .frcmod writing\n    # insert dummy angles/dihedrals if a morph .frcmod requires\n    # new terms between the appearing/disappearing atoms\n    # this is a trick to make sure tleap has everything it needs to generate the .top file\n    correction_introduced = self._check_hybrid_frcmod(\n        ambertools_tleap, ambertools_script_dir, protein_ff, ligand_ff\n    )\n    if correction_introduced:\n        # move the .frcmod which turned out to be insufficient according to the test\n        shutil.move(morph_frcmod, str(self.frcmod) + \".uncorrected\")\n        # now copy in place the corrected version\n        shutil.copy(self.frcmod, morph_frcmod)\n</code></pre>"},{"location":"api/pair/#ties.Pair.overlap_fractions","title":"overlap_fractions","text":"<pre><code>overlap_fractions()\n</code></pre> <p>Calculate the size of the common area.</p> <p>:return: Four decimals capturing: 1) the fraction of the common size with respect to the ligA topology,     2) the fraction of the common size with respect to the ligZ topology,     3) the percentage of the disappearing atoms in the disappearing molecule     4) the percentage of the appearing atoms  in the appearing molecule :rtype: [float, float, float, float]</p> Source code in <code>ties/pair.py</code> <pre><code>def overlap_fractions(self):\n    \"\"\"\n    Calculate the size of the common area.\n\n    :return: Four decimals capturing: 1) the fraction of the common size with respect to the ligA topology,\n        2) the fraction of the common size with respect to the ligZ topology,\n        3) the percentage of the disappearing atoms in the disappearing molecule\n        4) the percentage of the appearing atoms  in the appearing molecule\n    :rtype: [float, float, float, float]\n    \"\"\"\n\n    if self.suptop is None:\n        return 0, 0, float(\"inf\"), float(\"inf\")\n    else:\n        mcs_size = len(self.suptop.matched_pairs)\n\n    matched_fraction_left = mcs_size / float(len(self.suptop.top1))\n    matched_fraction_right = mcs_size / float(len(self.suptop.top2))\n    disappearing_atoms_fraction = (\n        (len(self.suptop.top1) - mcs_size) / float(len(self.suptop.top1)) * 100\n    )\n    appearing_atoms_fraction = (\n        (len(self.suptop.top2) - mcs_size) / float(len(self.suptop.top2)) * 100\n    )\n\n    return (\n        matched_fraction_left,\n        matched_fraction_right,\n        disappearing_atoms_fraction,\n        appearing_atoms_fraction,\n    )\n</code></pre>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#ties","title":"ties","text":"<p>Modules:</p> <ul> <li> <code>analysis</code>           \u2013            <p>Updated OOP approach to data analysis.</p> </li> <li> <code>bb</code>           \u2013            </li> <li> <code>cli</code>           \u2013            <p>Exposes a terminal interface to TIES 20.</p> </li> <li> <code>config</code>           \u2013            </li> <li> <code>docking</code>           \u2013            </li> <li> <code>generator</code>           \u2013            </li> <li> <code>helpers</code>           \u2013            <p>A list of functions with a clear purpose that does</p> </li> <li> <code>ligand</code>           \u2013            </li> <li> <code>ligandmap</code>           \u2013            </li> <li> <code>md</code>           \u2013            </li> <li> <code>namd_generator</code>           \u2013            <p>Load two ligands, run the topology superimposer, and then</p> </li> <li> <code>overlay</code>           \u2013            </li> <li> <code>pair</code>           \u2013            </li> <li> <code>parsing</code>           \u2013            </li> <li> <code>protein</code>           \u2013            </li> <li> <code>scripts</code>           \u2013            </li> <li> <code>topology_superimposer</code>           \u2013            <p>The main module responsible for the superimposition.</p> </li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> ties<ul> <li> analysis</li> <li> bb<ul> <li> atom</li> <li> bond</li> <li> gaff_atom_types</li> </ul> </li> <li> cli</li> <li> config</li> <li> docking<ul> <li> fit</li> <li> mol2sdf</li> <li> prep</li> <li> rdmcs</li> <li> score</li> <li> sdf2mol2</li> </ul> </li> <li> generator</li> <li> helpers</li> <li> ligand</li> <li> ligandmap</li> <li> md</li> <li> namd_generator</li> <li> overlay</li> <li> pair</li> <li> parsing</li> <li> protein</li> <li> topology_superimposer</li> </ul> </li> </ul>"},{"location":"reference/analysis/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> analysis","text":""},{"location":"reference/analysis/#ties.analysis","title":"analysis","text":"<p>Updated OOP approach to data analysis.</p> <p>Classes:</p> <ul> <li> <code>Replica</code>           \u2013            <p>Replica loads in and parses the actual information.</p> </li> <li> <code>Lambda</code>           \u2013            <p>Reflect the real lambda rather than the \"general\" lambda.</p> </li> <li> <code>Contribution</code>           \u2013            <p>Reflects one type of interactions. For example, appearing electrostatics, or dissapearing VDW.</p> </li> <li> <code>DGSystem</code>           \u2013            <p>Single step dG system.</p> </li> <li> <code>TCSystem</code>           \u2013            <p>Thermodynamics Cycle System.</p> </li> </ul>"},{"location":"reference/analysis/#ties.analysis.Replica","title":"Replica","text":"<p>Replica loads in and parses the actual information. Multiple replicas can work on the lambda. So replica is defined by lambda and by its directory path. This representation should contain all the details necessary.</p>"},{"location":"reference/analysis/#ties.analysis.Lambda","title":"Lambda","text":"<p>Reflect the real lambda rather than the \"general\" lambda. However, stores the information about the \"general\" lambda as well. This class contains at least 1 replica.</p>"},{"location":"reference/analysis/#ties.analysis.Contribution","title":"Contribution","text":"<p>Reflects one type of interactions. For example, appearing electrostatics, or dissapearing VDW. This class contains lambdas with their replicas. It can calculate the integral and plot different information relevant to each contribution.</p>"},{"location":"reference/analysis/#ties.analysis.DGSystem","title":"DGSystem","text":"<p>Single step dG system.</p> <p>Contains 4 contributions: disappearing and appearing electrostatics and vdw Uses contributions to calculate dG. Contains lots of dG analysis and plotting.</p>"},{"location":"reference/analysis/#ties.analysis.TCSystem","title":"TCSystem","text":"<p>Thermodynamics Cycle System.</p> <p>Contains 2 Systems, each providing one dG. This way it can provide the ddG. Contains lots of ddG analysis and plotting.</p>"},{"location":"reference/cli/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cli","text":""},{"location":"reference/cli/#ties.cli","title":"cli","text":"<p>Exposes a terminal interface to TIES 20.</p>"},{"location":"reference/config/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> config","text":""},{"location":"reference/config/#ties.config","title":"config","text":"<p>Classes:</p> <ul> <li> <code>Config</code>           \u2013            <p>The configuration with parameters that can be used to define the entire protocol.</p> </li> </ul>"},{"location":"reference/config/#ties.config.Config","title":"Config","text":"<pre><code>Config(**kwargs)\n</code></pre> <p>The configuration with parameters that can be used to define the entire protocol. The settings can be overridden later in the actual classes.</p> <p>The settings are stored as properties in the object and can be overwritten.</p> <p>Methods:</p> <ul> <li> <code>get_serializable</code>             \u2013              <p>Get a JSON serializable structure of the config.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>workdir</code>           \u2013            <p>Working directory for antechamber calls.</p> </li> <li> <code>protein</code>           \u2013            <p>Path to the protein</p> </li> <li> <code>ligand_files</code>           \u2013            <p>A list of ligand filenames.</p> </li> <li> <code>ambertools_home</code>           \u2013            <p>Ambertools HOME path. If not configured, the env variable AMBERHOME as AMBER_PREFIX will be checked.</p> </li> <li> <code>ambertools_antechamber</code>           \u2013            <p>Antechamber path based on the .ambertools_home</p> </li> <li> <code>ambertools_parmchk2</code>           \u2013            <p>Parmchk2 path based on the .ambertools_home</p> </li> <li> <code>ambertools_tleap</code>           \u2013            <p>Tleap path based on the .ambertools_home</p> </li> <li> <code>antechamber_dr</code>           \u2013            <p>Whether to use -dr setting when calling antechamber.</p> </li> <li> <code>ligand_net_charge</code>           \u2013            <p>The ligand charge. If not provided, neutral charge is assumed.</p> </li> <li> <code>coordinates_file</code>           \u2013            <p>A file from which coordinate can be taken.</p> </li> <li> <code>atom_pair_q_atol</code>           \u2013            <p>It defines the maximum difference in charge</p> </li> <li> <code>net_charge_threshold</code>           \u2013            <p>Defines how much the superimposed regions can, in total, differ in charge.</p> </li> <li> <code>ignore_charges_completely</code>           \u2013            <p>Ignore the charges during the superimposition. Useful for debugging.</p> </li> <li> <code>allow_disjoint_components</code>           \u2013            <p>Defines whether there might be multiple superimposed areas that are</p> </li> <li> <code>use_element_in_superimposition</code>           \u2013            <p>Use element rather than the actual atom type for the superimposition</p> </li> <li> <code>align_molecules_using_mcs</code>           \u2013            <p>After determining the maximum common substructure (MCS),</p> </li> <li> <code>use_original_coor</code>           \u2013            <p>Antechamber when assigning charges can modify the charges slightly.</p> </li> <li> <code>ligands_contain_q</code>           \u2013            <p>If not provided, it tries to deduce whether charges are provided.</p> </li> <li> <code>superimposition_starting_pairs</code>           \u2013            <p>Set a starting pair for the superimposition to narrow down the MCS search.</p> </li> <li> <code>manually_matched_atom_pairs</code>           \u2013            <p>Either a list of pairs or a file with a list of pairs of atoms</p> </li> <li> <code>manually_mismatched_pairs</code>           \u2013            <p>A path to a file with a list of a pairs that should be mismatched.</p> </li> <li> <code>protein_ff</code>           \u2013            <p>The protein forcefield to be used by ambertools for the protein parameterisation.</p> </li> <li> <code>md_engine</code>           \u2013            <p>The MD engine, with the supported values NAMD2.13, NAMD2.14, NAMD3 and OpenMM</p> </li> <li> <code>ligand_ff</code>           \u2013            <p>The forcefield for the ligand.</p> </li> <li> <code>ligand_ff_name</code>           \u2013            <p>Either GAFF or GAFF2</p> </li> <li> <code>redistribute_q_over_unmatched</code>           \u2013            <p>The superimposed and matched atoms have every slightly different charges.</p> </li> <li> <code>use_hybrid_single_dual_top</code>           \u2013            <p>Hybrid single dual topology (experimental). Currently not implemented.</p> </li> <li> <code>ligand_tleap_in</code>           \u2013            <p>The name of the tleap input file for ambertools for the ligand.</p> </li> <li> <code>complex_tleap_in</code>           \u2013            <p>The tleap input file for the complex.</p> </li> <li> <code>prep_dir</code>           \u2013            <p>Path to the <code>prep</code> directory. Currently in the <code>workdir</code></p> </li> <li> <code>pair_morphfrcmods_dir</code>           \u2013            <p>Path to the .frcmod files for the morph.</p> </li> <li> <code>pair_morphfrmocs_tests_dir</code>           \u2013            <p>Path to the location where a test is carried out with .frcmod</p> </li> <li> <code>pair_unique_atom_names_dir</code>           \u2013            <p>Location of the morph files with unique filenames.</p> </li> <li> <code>lig_unique_atom_names_dir</code>           \u2013            <p>Directory location for files with unique atom names.</p> </li> <li> <code>lig_frcmod_dir</code>           \u2013            <p>Directory location with the .frcmod created for each ligand.</p> </li> <li> <code>lig_acprep_dir</code>           \u2013            <p>Directory location where the .ac charges are converted into the .mol2 format.</p> </li> <li> <code>lig_dir</code>           \u2013            <p>Directory location with the .mol2 files.</p> </li> </ul> Source code in <code>ties/config.py</code> <pre><code>def __init__(self, **kwargs):\n    # set the path to the scripts\n    self.code_root = pathlib.Path(os.path.dirname(__file__))\n\n    # scripts/input files,\n    # these are specific to the host\n    self.script_dir = self.code_root / \"scripts\"\n    self.namd_script_dir = self.script_dir / \"namd\"\n    self.ambertools_script_dir = self.script_dir / \"ambertools\"\n    self.tleap_check_protein = self.ambertools_script_dir / \"check_prot.in\"\n    self.vmd_vis_script = self.script_dir / \"vmd\" / \"vis_morph.vmd\"\n    self.vmd_vis_script_sh = self.script_dir / \"vmd\" / \"vis_morph.sh\"\n\n    self.unique_atom_names = False\n\n    self._workdir = None\n    self._antechamber_dr = False\n    self._ambertools_home = None\n\n    self._protein = None\n\n    self._ligand_net_charge = None\n    self._atom_pair_q_atol = 0.1\n    self._net_charge_threshold = 0.1\n    self._redistribute_q_over_unmatched = True\n    self._allow_disjoint_components = False\n    # use only the element in the superimposition rather than the specific atom type\n    self._use_rdkit_mcs = True\n    self._use_element_in_superimposition = True\n    self._partial_ring_allowed = False\n    self.starting_pairs_heuristics = True\n    # weights in choosing the best MCS, the weighted sum of \"(1 - MCS fraction) and RMSD\".\n    self.weights_ratio = [1, 0]\n\n    # coordinates\n    self._align_molecules_using_mcs = False\n    self.align_add_removed_mcs = False\n    self._use_original_coor = False\n    self._coordinates_file = None\n\n    self._ligand_files = set()\n    self._manually_matched_atom_pairs = None\n    self._manually_mismatched_pairs = None\n    self._ligands_contain_q = None\n\n    self._ligand_tleap_in = None\n    self._complex_tleap_in = None\n\n    self._superimposition_starting_pairs = None\n    self._superimposition_starting_heuristic = 0.6\n\n    self._protein_ff = None\n    self._ligand_ff = \"leaprc.gaff\"\n    self._ligand_ff_name = \"gaff\"\n\n    # MD/NAMD production input file\n    self._md_engine = \"namd\"\n    # default to modern CPU version\n    self.namd_version = \"2.14\"\n    self._lambda_rep_dir_tree = False\n\n    # experimental\n    self._use_hybrid_single_dual_top = False\n    self._ignore_charges_completely = False\n\n    self.ligands = None\n\n    # if True, do not allow ligands with the same ligand name\n    self.uses_cmd = False\n\n    # assign all the initial configuration values\n    self.set_configs(**kwargs)\n\n    # logging\n    self.logging_breakdown = False\n    self.logging_formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n    self.logging_level = logging.INFO\n</code></pre>"},{"location":"reference/config/#ties.config.Config.workdir","title":"workdir  <code>property</code> <code>writable</code>","text":"<pre><code>workdir\n</code></pre> <p>Working directory for antechamber calls. If None, a temporary directory in /tmp/ will be used.</p> <p>:return: Work dir :rtype: str</p>"},{"location":"reference/config/#ties.config.Config.protein","title":"protein  <code>property</code> <code>writable</code>","text":"<pre><code>protein\n</code></pre> <p>Path to the protein</p> <p>:return: Protein filename :rtype: str</p>"},{"location":"reference/config/#ties.config.Config.ligand_files","title":"ligand_files  <code>property</code> <code>writable</code>","text":"<pre><code>ligand_files\n</code></pre> <p>A list of ligand filenames. :return:</p>"},{"location":"reference/config/#ties.config.Config.ambertools_home","title":"ambertools_home  <code>property</code> <code>writable</code>","text":"<pre><code>ambertools_home\n</code></pre> <p>Ambertools HOME path. If not configured, the env variable AMBERHOME as AMBER_PREFIX will be checked.</p> <p>:return: ambertools path</p>"},{"location":"reference/config/#ties.config.Config.ambertools_antechamber","title":"ambertools_antechamber  <code>property</code>","text":"<pre><code>ambertools_antechamber\n</code></pre> <p>Antechamber path based on the .ambertools_home</p> <p>:return:</p>"},{"location":"reference/config/#ties.config.Config.ambertools_parmchk2","title":"ambertools_parmchk2  <code>property</code>","text":"<pre><code>ambertools_parmchk2\n</code></pre> <p>Parmchk2 path based on the .ambertools_home :return:</p>"},{"location":"reference/config/#ties.config.Config.ambertools_tleap","title":"ambertools_tleap  <code>property</code>","text":"<pre><code>ambertools_tleap\n</code></pre> <p>Tleap path based on the .ambertools_home :return:</p>"},{"location":"reference/config/#ties.config.Config.antechamber_dr","title":"antechamber_dr  <code>property</code> <code>writable</code>","text":"<pre><code>antechamber_dr\n</code></pre> <p>Whether to use -dr setting when calling antechamber.</p> <p>:return:</p>"},{"location":"reference/config/#ties.config.Config.ligand_net_charge","title":"ligand_net_charge  <code>property</code> <code>writable</code>","text":"<pre><code>ligand_net_charge\n</code></pre> <p>The ligand charge. If not provided, neutral charge is assumed. The charge is necessary for calling antechamber (-nc).</p> <p>:return:</p>"},{"location":"reference/config/#ties.config.Config.coordinates_file","title":"coordinates_file  <code>property</code> <code>writable</code>","text":"<pre><code>coordinates_file\n</code></pre> <p>A file from which coordinate can be taken.</p> <p>:return:</p>"},{"location":"reference/config/#ties.config.Config.atom_pair_q_atol","title":"atom_pair_q_atol  <code>property</code> <code>writable</code>","text":"<pre><code>atom_pair_q_atol\n</code></pre> <p>It defines the maximum difference in charge between any two superimposed atoms a1 and a2. If the two atoms differ in charge more than this value, they will be unmatched and added to the alchemical regions.</p> <p>:return: default (0.1e) :rtype: float</p>"},{"location":"reference/config/#ties.config.Config.net_charge_threshold","title":"net_charge_threshold  <code>property</code> <code>writable</code>","text":"<pre><code>net_charge_threshold\n</code></pre> <p>Defines how much the superimposed regions can, in total, differ in charge. If the total exceeds the thresholds, atom pairs will be unmatched until the threshold is met.</p> <p>:return: default (0.1e) :rtype: float</p>"},{"location":"reference/config/#ties.config.Config.ignore_charges_completely","title":"ignore_charges_completely  <code>property</code> <code>writable</code>","text":"<pre><code>ignore_charges_completely\n</code></pre> <p>Ignore the charges during the superimposition. Useful for debugging. :return: default (False) :rtype: bool</p>"},{"location":"reference/config/#ties.config.Config.allow_disjoint_components","title":"allow_disjoint_components  <code>property</code> <code>writable</code>","text":"<pre><code>allow_disjoint_components\n</code></pre> <p>Defines whether there might be multiple superimposed areas that are separated by alchemical region.</p> <p>:return: default (False) :rtype: bool</p>"},{"location":"reference/config/#ties.config.Config.use_element_in_superimposition","title":"use_element_in_superimposition  <code>property</code> <code>writable</code>","text":"<pre><code>use_element_in_superimposition\n</code></pre> <p>Use element rather than the actual atom type for the superimposition during the joint-traversal of the two molecules.</p> <p>:return: default (False) :rtype: bool</p>"},{"location":"reference/config/#ties.config.Config.align_molecules_using_mcs","title":"align_molecules_using_mcs  <code>property</code> <code>writable</code>","text":"<pre><code>align_molecules_using_mcs\n</code></pre> <p>After determining the maximum common substructure (MCS), use it to align the coordinates of the second molecule to the first.</p> <p>:return: default (False) :rtype: bool</p>"},{"location":"reference/config/#ties.config.Config.use_original_coor","title":"use_original_coor  <code>property</code> <code>writable</code>","text":"<pre><code>use_original_coor\n</code></pre> <p>Antechamber when assigning charges can modify the charges slightly. If that's the case, use the original charges in order to correct this slight divergence in coordinates.</p> <p>:return: default (?) :rtype: bool</p>"},{"location":"reference/config/#ties.config.Config.ligands_contain_q","title":"ligands_contain_q  <code>property</code> <code>writable</code>","text":"<pre><code>ligands_contain_q\n</code></pre> <p>If not provided, it tries to deduce whether charges are provided. If all charges are set to 0, then it assumes that charges are not provided.</p> <p>If set to False explicitly, charges are ignored and computed again.</p> <p>:return: default (None) :rtype: bool</p>"},{"location":"reference/config/#ties.config.Config.superimposition_starting_pairs","title":"superimposition_starting_pairs  <code>property</code> <code>writable</code>","text":"<pre><code>superimposition_starting_pairs\n</code></pre> <p>Set a starting pair for the superimposition to narrow down the MCS search. E.g. \"C2-C12\"</p> <p>:rtype: str</p>"},{"location":"reference/config/#ties.config.Config.manually_matched_atom_pairs","title":"manually_matched_atom_pairs  <code>property</code> <code>writable</code>","text":"<pre><code>manually_matched_atom_pairs\n</code></pre> <p>Either a list of pairs or a file with a list of pairs of atoms that should be superimposed/matched.</p> <p>:return:</p>"},{"location":"reference/config/#ties.config.Config.manually_mismatched_pairs","title":"manually_mismatched_pairs  <code>property</code> <code>writable</code>","text":"<pre><code>manually_mismatched_pairs\n</code></pre> <p>A path to a file with a list of a pairs that should be mismatched.</p>"},{"location":"reference/config/#ties.config.Config.protein_ff","title":"protein_ff  <code>property</code> <code>writable</code>","text":"<pre><code>protein_ff\n</code></pre> <p>The protein forcefield to be used by ambertools for the protein parameterisation.</p> <p>:return: default (leaprc.ff19SB) :rtype: string</p>"},{"location":"reference/config/#ties.config.Config.md_engine","title":"md_engine  <code>property</code> <code>writable</code>","text":"<pre><code>md_engine\n</code></pre> <p>The MD engine, with the supported values NAMD2.13, NAMD2.14, NAMD3 and OpenMM</p> <p>:return: NAMD2.13, NAMD2.14, NAMD3 and OpenMM :rtype: string</p>"},{"location":"reference/config/#ties.config.Config.ligand_ff","title":"ligand_ff  <code>property</code>","text":"<pre><code>ligand_ff\n</code></pre> <p>The forcefield for the ligand.</p>"},{"location":"reference/config/#ties.config.Config.ligand_ff_name","title":"ligand_ff_name  <code>property</code> <code>writable</code>","text":"<pre><code>ligand_ff_name\n</code></pre> <p>Either GAFF or GAFF2</p> <p>:return:</p>"},{"location":"reference/config/#ties.config.Config.redistribute_q_over_unmatched","title":"redistribute_q_over_unmatched  <code>property</code> <code>writable</code>","text":"<pre><code>redistribute_q_over_unmatched\n</code></pre> <p>The superimposed and matched atoms have every slightly different charges. Taking an average charge between any two atoms introduces imbalances in the net charge of the alchemical regions, due to the different charge distribution.</p> <p>:return: default(True)</p>"},{"location":"reference/config/#ties.config.Config.use_hybrid_single_dual_top","title":"use_hybrid_single_dual_top  <code>property</code> <code>writable</code>","text":"<pre><code>use_hybrid_single_dual_top\n</code></pre> <p>Hybrid single dual topology (experimental). Currently not implemented.</p> <p>:return: default(False).</p>"},{"location":"reference/config/#ties.config.Config.ligand_tleap_in","title":"ligand_tleap_in  <code>property</code>","text":"<pre><code>ligand_tleap_in\n</code></pre> <p>The name of the tleap input file for ambertools for the ligand.</p> <p>:return: Default ('leap_ligand.in') :rtype: string</p>"},{"location":"reference/config/#ties.config.Config.complex_tleap_in","title":"complex_tleap_in  <code>property</code>","text":"<pre><code>complex_tleap_in\n</code></pre> <p>The tleap input file for the complex.</p> <p>:return: Default 'leap_complex.in' :type: string</p>"},{"location":"reference/config/#ties.config.Config.prep_dir","title":"prep_dir  <code>property</code>","text":"<pre><code>prep_dir\n</code></pre> <p>Path to the <code>prep</code> directory. Currently in the <code>workdir</code></p> <p>:return: Default (workdir/prep)</p>"},{"location":"reference/config/#ties.config.Config.pair_morphfrcmods_dir","title":"pair_morphfrcmods_dir  <code>property</code>","text":"<pre><code>pair_morphfrcmods_dir\n</code></pre> <p>Path to the .frcmod files for the morph.</p> <p>:return: Default (workdir/prep/morph_frcmods)</p>"},{"location":"reference/config/#ties.config.Config.pair_morphfrmocs_tests_dir","title":"pair_morphfrmocs_tests_dir  <code>property</code>","text":"<pre><code>pair_morphfrmocs_tests_dir\n</code></pre> <p>Path to the location where a test is carried out with .frcmod</p> <p>:return: Default (workdir/prep/morph_frcmods/tests)</p>"},{"location":"reference/config/#ties.config.Config.pair_unique_atom_names_dir","title":"pair_unique_atom_names_dir  <code>property</code>","text":"<pre><code>pair_unique_atom_names_dir\n</code></pre> <p>Location of the morph files with unique filenames.</p> <p>:return: Default (workdir/prep/morph_unique_atom_names)</p>"},{"location":"reference/config/#ties.config.Config.lig_unique_atom_names_dir","title":"lig_unique_atom_names_dir  <code>property</code>","text":"<pre><code>lig_unique_atom_names_dir\n</code></pre> <p>Directory location for files with unique atom names.</p> <p>:return: Default (workdir/prep/unique_atom_names)</p>"},{"location":"reference/config/#ties.config.Config.lig_frcmod_dir","title":"lig_frcmod_dir  <code>property</code>","text":"<pre><code>lig_frcmod_dir\n</code></pre> <p>Directory location with the .frcmod created for each ligand.</p> <p>:return: Default (workdir/prep/ligand_frcmods)</p>"},{"location":"reference/config/#ties.config.Config.lig_acprep_dir","title":"lig_acprep_dir  <code>property</code>","text":"<pre><code>lig_acprep_dir\n</code></pre> <p>Directory location where the .ac charges are converted into the .mol2 format.</p> <p>:return: Default (workdir/prep/acprep_to_mol2)</p>"},{"location":"reference/config/#ties.config.Config.lig_dir","title":"lig_dir  <code>property</code>","text":"<pre><code>lig_dir\n</code></pre> <p>Directory location with the .mol2 files.</p> <p>:return: Default (workdir/mol2)</p>"},{"location":"reference/config/#ties.config.Config.get_serializable","title":"get_serializable","text":"<pre><code>get_serializable()\n</code></pre> <p>Get a JSON serializable structure of the config.</p> <p>pathlib.Path is not JSON serializable, so replace it with str</p> <p>todo - consider capturing all information about the system here, including each suptop.get_serializable() so that you can record specific information such as the charge changes etc.</p> <p>:return: Dictionary {key:value} with the settings :rtype: Dictionary</p> Source code in <code>ties/config.py</code> <pre><code>def get_serializable(self):\n    \"\"\"\n    Get a JSON serializable structure of the config.\n\n    pathlib.Path is not JSON serializable, so replace it with str\n\n    todo - consider capturing all information about the system here,\n    including each suptop.get_serializable() so that you can record\n    specific information such as the charge changes etc.\n\n    :return: Dictionary {key:value} with the settings\n    :rtype: Dictionary\n    \"\"\"\n\n    exclude = [\n        \"_workdir_tempdir\",  # exists (during runtime) for cleaning up purposes\n    ]\n\n    host_specific = [\n        \"code_root\",\n        \"script_dir0\",\n        \"namd_script_dir\",\n        \"ambertools_script_dir\",\n        \"tleap_check_protein\",\n        \"vmd_vis_script\",\n    ]\n\n    ser = {}\n    for k, v in self.__dict__.items():\n        if k in host_specific or k in exclude:\n            continue\n\n        if type(v) is logging.Formatter:\n            continue\n\n        if type(v) is pathlib.PosixPath:\n            v = str(v)\n\n        # account for the ligands being pathlib objects\n        if k == \"ligands\" and v is not None:\n            # a list of ligands, convert to strings\n            v = [str(lig) for lig in v]\n        if k == \"_ligand_files\":\n            continue\n\n        ser[k] = v\n\n    return ser\n</code></pre>"},{"location":"reference/generator/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> generator","text":""},{"location":"reference/generator/#ties.generator","title":"generator","text":"<p>Functions:</p> <ul> <li> <code>join_frcmod_files</code>             \u2013              <p>This implementation should be used. Switch to join_frcmod_files2.</p> </li> <li> <code>correct_fep_tempfactor</code>             \u2013              <p>fixme - this function does not need to use the file?</p> </li> <li> <code>extract_PBC_from_tleap_log</code>             \u2013              <p>http://ambermd.org/namd/namd_amber.html</p> </li> <li> <code>prepare_antechamber_parmchk2</code>             \u2013              <p>Prepare the ambertools scripts.</p> </li> <li> <code>get_protein_net_charge</code>             \u2013              <p>Use automatic ambertools solvation of a single component to determine what is the next charge of the system.</p> </li> <li> <code>prepareFile</code>             \u2013              <p>Either copies or sets up a relative link between the files.</p> </li> <li> <code>update_PBC_in_namd_input</code>             \u2013              <p>fixme - rename this file since it generates the .eq files</p> </li> <li> <code>create_constraint_files</code>             \u2013              <p>:param original_pdb:</p> </li> <li> <code>init_namd_file_min</code>             \u2013              <p>:param from_dir:</p> </li> <li> <code>generate_namd_prod</code>             \u2013              <p>:param namd_prod:</p> </li> <li> <code>generate_namd_eq</code>             \u2013              <p>:param namd_eq:</p> </li> <li> <code>redistribute_charges</code>             \u2013              <p>Calculate the original charges in the matched component.</p> </li> </ul>"},{"location":"reference/generator/#ties.generator.join_frcmod_files","title":"join_frcmod_files","text":"<pre><code>join_frcmod_files(f1, f2, output_filepath)\n</code></pre> <p>This implementation should be used. Switch to join_frcmod_files2. This version might be removed if the simple approach is fine.</p> Source code in <code>ties/generator.py</code> <pre><code>def join_frcmod_files(f1, f2, output_filepath):\n    \"\"\"\n    This implementation should be used. Switch to join_frcmod_files2.\n    This version might be removed if the simple approach is fine.\n    \"\"\"\n    # fixme - load f1 and f2\n\n    def get_section(name, rlines):\n        \"\"\"\n        Chips away from the lines until the section is ready\n\n        fixme is there a .frcmod reader in ambertools?\n        http://ambermd.org/FileFormats.php#frcmod\n        \"\"\"\n        section_names = [\"MASS\", \"BOND\", \"ANGLE\", \"DIHE\", \"IMPROPER\", \"NONBON\"]\n        assert name in rlines.pop().strip()\n\n        section = []\n        while not (\n            len(rlines) == 0\n            or any(rlines[-1].startswith(sname) for sname in section_names)\n        ):\n            nextl = rlines.pop().strip()\n            if nextl == \"\":\n                continue\n            # depending on the column name, parse differently\n            if name == \"ANGLE\":\n                # e.g.\n                # c -cc-na   86.700     123.270   same as c2-cc-na, penalty score=  2.6\n                atom_types = nextl[:8]\n                other = nextl[9:].split()[::-1]\n                # The harmonic force constants for the angle \"ITT\"-\"JTT\"-\n                #                     \"KTT\" in units of kcal/mol/(rad**2) (radians are the\n                #                     traditional unit for angle parameters in force fields).\n                harmonicForceConstant = float(other.pop())\n                # TEQ        The equilibrium bond angle for the above angle in degrees.\n                eq_bond_angle = float(other.pop())\n                # the overall angle\n                section.append([atom_types, harmonicForceConstant, eq_bond_angle])\n            elif name == \"DIHE\":\n                # e.g.\n                # ca-ca-cd-cc   1    0.505       180.000           2.000      same as c2-ce-ca-ca, penalty score=229.0\n                atom_types = nextl[:11]\n                other = nextl[11:].split()[::-1]\n                \"\"\"\n                IDIVF      The factor by which the torsional barrier is divided.\n                    Consult Weiner, et al., JACS 106:765 (1984) p. 769 for\n                    details. Basically, the actual torsional potential is\n\n                           (PK/IDIVF) * (1 + cos(PN*phi - PHASE))\n\n                 PK         The barrier height divided by a factor of 2.\n\n                 PHASE      The phase shift angle in the torsional function.\n\n                            The unit is degrees.\n\n                 PN         The periodicity of the torsional barrier.\n                            NOTE: If PN .lt. 0.0 then the torsional potential\n                                  is assumed to have more than one term, and the\n                                  values of the rest of the terms are read from the\n                                  next cards until a positive PN is encountered.  The\n                                  negative value of pn is used only for identifying\n                                  the existence of the next term and only the\n                                  absolute value of PN is kept.\n                \"\"\"\n                IDIVF = float(other.pop())\n                PK = float(other.pop())\n                PHASE = float(other.pop())\n                PN = float(other.pop())\n                section.append([atom_types, IDIVF, PK, PHASE, PN])\n            elif name == \"IMPROPER\":\n                # e.g.\n                # cc-o -c -o          1.1          180.0         2.0          Using general improper torsional angle  X- o- c- o, penalty score=  3.0)\n                # ...  IDIVF , PK , PHASE , PN\n                atom_types = nextl[:11]\n                other = nextl[11:].split()[::-1]\n                # fixme - what is going on here? why is not generated this number?\n                # IDIVF = float(other.pop())\n                PK = float(other.pop())\n                PHASE = float(other.pop())\n                PN = float(other.pop())\n                if PN &lt; 0:\n                    raise Exception(\"Unimplemented - ordering using with negative 0\")\n                section.append([atom_types, PK, PHASE, PN])\n            else:\n                section.append(nextl.split())\n        return {name: section}\n\n    def load_frcmod(filepath):\n        # remark line\n        rlines = open(filepath).readlines()[::-1]\n        assert \"Remark\" in rlines.pop()\n\n        parsed = OrderedDict()\n        for section_name in [\"MASS\", \"BOND\", \"ANGLE\", \"DIHE\", \"IMPROPER\", \"NONBON\"]:\n            parsed.update(get_section(section_name, rlines))\n\n        return parsed\n\n    def join_frcmod(left_frc, right_frc):\n        joined = OrderedDict()\n        for left, right in zip(left_frc.items(), right_frc.items()):\n            lname, litems = left\n            rname, ritems = right\n            assert lname == rname\n\n            joined[lname] = copy.copy(litems)\n\n            if lname == \"MASS\":\n                if len(litems) &gt; 0 or len(ritems) &gt; 0:\n                    raise Exception(\"Unimplemented\")\n            elif lname == \"BOND\":\n                for ritem in ritems:\n                    if len(litems) &gt; 0 or len(ritems) &gt; 0:\n                        if ritem not in joined[lname]:\n                            raise Exception(\"Unimplemented\")\n            # ANGLE, e.g.\n            # c -cc-na   86.700     123.270   same as c2-cc-na, penalty score=  2.6\n            elif lname == \"ANGLE\":\n                for ritem in ritems:\n                    # if the item is not in the litems, add it there\n                    # extra the first three terms to determine if it is present\n                    # fixme - note we are ignoring the \"same as\" note\n                    if ritem not in joined[lname]:\n                        joined[lname].append(ritem)\n            elif lname == \"DIHE\":\n                for ritem in ritems:\n                    if ritem not in joined[lname]:\n                        joined[lname].append(ritem)\n            elif lname == \"IMPROPER\":\n                for ritem in ritems:\n                    if ritem not in joined[lname]:\n                        joined[lname].append(ritem)\n            elif lname == \"NONBON\":\n                # if they're empty\n                if not litems and not ritems:\n                    continue\n\n                raise Exception(\"Unimplemented\")\n            else:\n                raise Exception(\"Unimplemented\")\n        return joined\n\n    def write_frcmod(frcmod, filename):\n        with open(filename, \"w\") as FOUT:\n            FOUT.write(\"GENERATED .frcmod by joining two .frcmod files\" + os.linesep)\n            for sname, items in frcmod.items():\n                FOUT.write(f\"{sname}\" + os.linesep)\n                for item in items:\n                    atom_types = item[0]\n                    FOUT.write(atom_types)\n                    numbers = \" \\t\".join([str(n) for n in item[1:]])\n                    FOUT.write(\" \\t\" + numbers)\n                    FOUT.write(os.linesep)\n                # the ending line\n                FOUT.write(os.linesep)\n\n    left_frc = load_frcmod(f1)\n    right_frc = load_frcmod(f2)\n    joined_frc = join_frcmod(left_frc, right_frc)\n    write_frcmod(joined_frc, output_filepath)\n</code></pre>"},{"location":"reference/generator/#ties.generator.correct_fep_tempfactor","title":"correct_fep_tempfactor","text":"<pre><code>correct_fep_tempfactor(suptop, source_pdb_filename, new_pdb_filename, hybrid_topology=False)\n</code></pre> <p>fixme - this function does not need to use the file? we have the json information available here.</p> <p>Sets the temperature column in the PDB file So that the number reflects the alchemical information Requires by NAMD in order to know which atoms appear (1) and which disappear (-1).</p> Source code in <code>ties/generator.py</code> <pre><code>def correct_fep_tempfactor(\n    suptop, source_pdb_filename, new_pdb_filename, hybrid_topology=False\n):\n    \"\"\"\n    fixme - this function does not need to use the file?\n    we have the json information available here.\n\n    Sets the temperature column in the PDB file\n    So that the number reflects the alchemical information\n    Requires by NAMD in order to know which atoms\n    appear (1) and which disappear (-1).\n    \"\"\"\n\n    pmdpdb = parmed.load_file(str(source_pdb_filename), structure=True)\n    if \"HYB\" not in {a.residue.name for a in pmdpdb.atoms}:\n        raise Exception('Missing the resname \"HYB\" in the pdb file prepared for fep')\n\n    # the IDs (0-based) in this PDB correspond to the rank in the MOL2 (1-based)\n    id_to_tom = {idx - 1: atom for atom, idx in suptop.internal_ids.items()}\n\n    # dual-topology info\n    appearing_atoms = suptop.get_appearing_atoms()\n    disappearing_atoms = suptop.get_disappearing_atoms()\n\n    # update the Temp column\n    for atom in pmdpdb.atoms:\n        # ignore water and ions and non-ligand resname\n        # we only modify the protein, so ignore the ligand resnames\n        # fixme .. why is it called mer, is it tleap?\n        if atom.residue.name != \"HYB\":\n            continue\n\n        # recover the atom (or pair) via the ID\n        internal_atom = id_to_tom[atom.idx]\n\n        # if the atom was \"matched\", meaning present in both ligands (left and right)\n        # then ignore\n        # note: we only use the left ligand\n        if internal_atom in suptop.matched_pairs:\n            continue\n        elif internal_atom in appearing_atoms:\n            # appearing atoms should\n            atom.bfactor = 1\n        elif internal_atom in disappearing_atoms:\n            atom.bfactor = -1\n        else:\n            raise Exception(\"This should never happen. It has to be one of the cases\")\n\n    pmdpdb.save(\n        str(new_pdb_filename), use_hetatoms=False, overwrite=True\n    )  # , file_format='PDB') - fixme?\n</code></pre>"},{"location":"reference/generator/#ties.generator.extract_PBC_from_tleap_log","title":"extract_PBC_from_tleap_log","text":"<pre><code>extract_PBC_from_tleap_log(leap_log)\n</code></pre> <p>http://ambermd.org/namd/namd_amber.html Return the 9 numbers for the truncated octahedron unit cell in namd cellBasisVector1  d         0.0            0.0 cellBasisVector2  (-1/3)d (2/3)sqrt(2)d  0.0 cellBasisVector3  (-1/3)d (-1/3)sqrt(2)d (-1/3)sqrt(6)*d</p> Source code in <code>ties/generator.py</code> <pre><code>def extract_PBC_from_tleap_log(leap_log):\n    \"\"\"\n    http://ambermd.org/namd/namd_amber.html\n    Return the 9 numbers for the truncated octahedron unit cell in namd\n    cellBasisVector1  d         0.0            0.0\n    cellBasisVector2  (-1/3)*d (2/3)sqrt(2)*d  0.0\n    cellBasisVector3  (-1/3)*d (-1/3)sqrt(2)*d (-1/3)sqrt(6)*d\n    \"\"\"\n\n    leap_log = open(leap_log).read()\n\n    # octahedral box\n    if \"&gt; solvateoct\" in leap_log:\n        leapl_log_lines = leap_log.split(os.linesep)\n        line_to_extract = \"Total bounding box for atom centers:\"\n        line_of_interest = list(\n            filter(lambda line: line_to_extract in line, leapl_log_lines)\n        )\n        d1, d2, d3 = line_of_interest[-1].split(line_to_extract)[1].split()\n        d1, d2, d3 = float(d1), float(d2), float(d3)\n        assert d1 == d2 == d3\n        # scale the d since after minimisation the system turns out to be much smaller?\n        d = d1 * 0.8\n        return {\n            \"cbv1\": d,\n            \"cbv2\": 0,\n            \"cbv3\": 0,\n            \"cbv4\": (1 / 3.0) * d,\n            \"cbv5\": (2 / 3.0) * np.sqrt(2) * d,\n            \"cbv6\": 0,\n            \"cbv7\": (-1 / 3.0) * d,\n            \"cbv8\": (1 / 3.0) * np.sqrt(2) * d,\n            \"cbv9\": (1 / 3) * np.sqrt(6) * d,\n        }\n\n    # rectangular cuboid\n    elif re.search(r\"&gt; solvateBox\", leap_log, flags=re.RegexFlag.IGNORECASE):\n        dims_str = re.search(\n            \"Total vdw box size:\\s+(\\d+.\\d+)\\s+(\\d+.\\d+)\\s+(\\d+.\\d+)\", leap_log\n        ).groups()\n        x, y, z = [float(dim) for dim in dims_str]\n        return {\n            \"cbv1\": x,\n            \"cbv2\": 0,\n            \"cbv3\": 0,\n            \"cbv4\": 0,\n            \"cbv5\": y,\n            \"cbv6\": 0,\n            \"cbv7\": 0,\n            \"cbv8\": 0,\n            \"cbv9\": z,\n        }\n    else:\n        raise NotImplementedError(\n            \"Only octahedral and regular boxes are implemented atm. \"\n        )\n</code></pre>"},{"location":"reference/generator/#ties.generator.prepare_antechamber_parmchk2","title":"prepare_antechamber_parmchk2","text":"<pre><code>prepare_antechamber_parmchk2(source_script, target_script, net_charge)\n</code></pre> <p>Prepare the ambertools scripts. Particularly, create the scritp so that it has the net charge</p>"},{"location":"reference/generator/#ties.generator.prepare_antechamber_parmchk2--fixme-run-antechamber-directly-with-the-right-settings-from-here","title":"fixme - run antechamber directly with the right settings from here?","text":""},{"location":"reference/generator/#ties.generator.prepare_antechamber_parmchk2--fixme-check-if-antechamber-has-a-python-interface","title":"fixme - check if antechamber has a python interface?","text":"Source code in <code>ties/generator.py</code> <pre><code>def prepare_antechamber_parmchk2(source_script, target_script, net_charge):\n    \"\"\"\n    Prepare the ambertools scripts.\n    Particularly, create the scritp so that it has the net charge\n    # fixme - run antechamber directly with the right settings from here?\n    # fixme - check if antechamber has a python interface?\n    \"\"\"\n    net_charge_set = open(source_script).read().format(net_charge=net_charge)\n    open(target_script, \"w\").write(net_charge_set)\n</code></pre>"},{"location":"reference/generator/#ties.generator.get_protein_net_charge","title":"get_protein_net_charge","text":"<pre><code>get_protein_net_charge(working_dir, protein_file, ambertools_tleap, leap_input_file, prot_ff)\n</code></pre> <p>Use automatic ambertools solvation of a single component to determine what is the next charge of the system. This should be replaced with pka/propka or something akin. Note that this is unsuitable for the hybrid ligand: ambertools does not understand a hybrid ligand and might assign the wront net charge.</p> Source code in <code>ties/generator.py</code> <pre><code>def get_protein_net_charge(\n    working_dir, protein_file, ambertools_tleap, leap_input_file, prot_ff\n):\n    \"\"\"\n    Use automatic ambertools solvation of a single component to determine what is the next charge of the system.\n    This should be replaced with pka/propka or something akin.\n    Note that this is unsuitable for the hybrid ligand: ambertools does not understand a hybrid ligand\n    and might assign the wront net charge.\n    \"\"\"\n    cwd = working_dir / \"prep\" / \"prep_protein_to_find_net_charge\"\n    if not cwd.is_dir():\n        cwd.mkdir()\n\n    # copy the protein\n    shutil.copy(working_dir / protein_file, cwd)\n\n    # use ambertools to solvate the protein: set ion numbers to 0 so that they are determined automatically\n    # fixme - consider moving out of the complex\n    leap_in_conf = open(leap_input_file).read()\n    ligand_ff = \"leaprc.gaff\"  # ignored but must be provided\n    open(cwd / \"solv_prot.in\", \"w\").write(\n        leap_in_conf.format(\n            protein_ff=prot_ff, ligand_ff=ligand_ff, protein_file=protein_file\n        )\n    )\n\n    log_filename = cwd / \"ties_tleap.log\"\n    with open(log_filename, \"w\") as LOG:\n        try:\n            subprocess.run(\n                [ambertools_tleap, \"-s\", \"-f\", \"solv_prot.in\"],\n                cwd=cwd,\n                stdout=LOG,\n                stderr=LOG,\n                check=True,\n                text=True,\n                timeout=60 * 2,  # 2 minutes\n            )\n        except subprocess.CalledProcessError as E:\n            print(\n                \"ERROR: tleap could generate a simple topology for the protein to check the number of ions. \"\n            )\n            print(f\"ERROR: The output was saved in the directory: {cwd}\")\n            print(f\"ERROR: can be found in the file: {log_filename}\")\n            raise E\n\n    # read the file to see how many ions were added\n    newsys = parmed.load_file(str(cwd / \"prot_solv.pdb\"), structure=True)\n    names = [a.name for a in newsys.atoms]\n    cl = names.count(\"Cl-\")\n    na = names.count(\"Na+\")\n\n    if cl &gt; na:\n        return cl - na\n    elif cl &lt; na:\n        return -(na - cl)\n\n    return 0\n</code></pre>"},{"location":"reference/generator/#ties.generator.prepareFile","title":"prepareFile","text":"<pre><code>prepareFile(src, dst, symbolic=True)\n</code></pre> <p>Either copies or sets up a relative link between the files. This allows for a quick switch in how the directory structure is organised. Using relative links means that the entire TIES ligand or TIES complex has to be moved together. However, one might want to be able to send a single replica anywhere and execute it independantly (suitable for BOINC).</p> <p>@type: 'sym' or 'copy'</p> Source code in <code>ties/generator.py</code> <pre><code>def prepareFile(src, dst, symbolic=True):\n    \"\"\"\n    Either copies or sets up a relative link between the files.\n    This allows for a quick switch in how the directory structure is organised.\n    Using relative links means that the entire TIES ligand or TIES complex\n    has to be moved together.\n    However, one might want to be able to send a single replica anywhere and\n    execute it independantly (suitable for BOINC).\n\n    @type: 'sym' or 'copy'\n    \"\"\"\n    if symbolic:\n        # note that deleting all the files is intrusive, todo\n        if os.path.isfile(dst):\n            os.remove(dst)\n        os.symlink(src, dst)\n    else:\n        if os.path.isfile(dst):\n            os.remove(dst)\n        shutil.copy(src, dst)\n</code></pre>"},{"location":"reference/generator/#ties.generator.update_PBC_in_namd_input","title":"update_PBC_in_namd_input","text":"<pre><code>update_PBC_in_namd_input(namd_filename, new_pbc_box, structure_filename, constraint_lines='')\n</code></pre> <p>fixme - rename this file since it generates the .eq files These are the lines we modify: cellBasisVector1    {cell_x}  0.000  0.000 cellBasisVector2     0.000  {cell_y}  0.000 cellBasisVector3     0.000  0.000 {cell_z}</p> <p>With x/y/z replacing the 3 values</p> Source code in <code>ties/generator.py</code> <pre><code>def update_PBC_in_namd_input(\n    namd_filename, new_pbc_box, structure_filename, constraint_lines=\"\"\n):\n    \"\"\"\n    fixme - rename this file since it generates the .eq files\n    These are the lines we modify:\n    cellBasisVector1\t{cell_x}  0.000  0.000\n    cellBasisVector2\t 0.000  {cell_y}  0.000\n    cellBasisVector3\t 0.000  0.000 {cell_z}\n\n    With x/y/z replacing the 3 values\n    \"\"\"\n    assert len(new_pbc_box) == 3\n\n    reformatted_namd_in = (\n        open(namd_filename)\n        .read()\n        .format(\n            cell_x=new_pbc_box[0],\n            cell_y=new_pbc_box[1],\n            cell_z=new_pbc_box[2],\n            constraints=constraint_lines,\n            output=\"test_output\",\n            structure=structure_filename,\n        )\n    )\n\n    # write to the file\n    open(namd_filename, \"w\").write(reformatted_namd_in)\n</code></pre>"},{"location":"reference/generator/#ties.generator.create_constraint_files","title":"create_constraint_files","text":"<pre><code>create_constraint_files(original_pdb, output)\n</code></pre> <p>:param original_pdb: :param output: :return:</p> Source code in <code>ties/generator.py</code> <pre><code>def create_constraint_files(original_pdb, output):\n    \"\"\"\n\n    :param original_pdb:\n    :param output:\n    :return:\n    \"\"\"\n    sys = parmed.load_file(str(original_pdb), structure=True)\n    # for each atom, give the B column the right value\n    for atom in sys.atoms:\n        # ignore water\n        if atom.residue.name in [\"WAT\", \"Na+\", \"TIP3W\", \"TIP3\", \"HOH\", \"SPC\", \"TIP4P\"]:\n            continue\n\n        # set each atom depending on whether it is a H or not\n        if atom.name.upper().startswith(\"H\"):\n            atom.bfactor = 0\n        else:\n            # restrain the heavy atom\n            atom.bfactor = 4\n\n    sys.save(output, use_hetatoms=False, overwrite=True)\n</code></pre>"},{"location":"reference/generator/#ties.generator.init_namd_file_min","title":"init_namd_file_min","text":"<pre><code>init_namd_file_min(from_dir, to_dir, filename, structure_name, pbc_box, protein)\n</code></pre> <p>:param from_dir: :param to_dir: :param filename: :param structure_name: :param pbc_box: :param protein: :return:</p> Source code in <code>ties/generator.py</code> <pre><code>def init_namd_file_min(from_dir, to_dir, filename, structure_name, pbc_box, protein):\n    \"\"\"\n\n    :param from_dir:\n    :param to_dir:\n    :param filename:\n    :param structure_name:\n    :param pbc_box:\n    :param protein:\n    :return:\n    \"\"\"\n    if protein is not None:\n        cons = f\"\"\"\nconstraints  on\nconsexp  2\n# use the same file for the position reference and the B column\nconsref  ../build/{structure_name}.pdb ;#need all positions\nconskfile  ../build/cons.pdb\nconskcol  B\n        \"\"\"\n    else:\n        cons = \"constraints  off\"\n\n    min_namd_initialised = (\n        open(os.path.join(from_dir, filename))\n        .read()\n        .format(structure_name=structure_name, constraints=cons, **pbc_box)\n    )\n    out_name = \"eq0.conf\"\n    open(os.path.join(to_dir, out_name), \"w\").write(min_namd_initialised)\n</code></pre>"},{"location":"reference/generator/#ties.generator.generate_namd_prod","title":"generate_namd_prod","text":"<pre><code>generate_namd_prod(namd_prod, dst_dir, structure_name)\n</code></pre> <p>:param namd_prod: :param dst_dir: :param structure_name: :return:</p> Source code in <code>ties/generator.py</code> <pre><code>def generate_namd_prod(namd_prod, dst_dir, structure_name):\n    \"\"\"\n\n    :param namd_prod:\n    :param dst_dir:\n    :param structure_name:\n    :return:\n    \"\"\"\n    input_data = open(namd_prod).read()\n    reformatted_namd_in = input_data.format(\n        output=\"sim1\", structure_name=structure_name\n    )\n    open(dst_dir, \"w\").write(reformatted_namd_in)\n</code></pre>"},{"location":"reference/generator/#ties.generator.generate_namd_eq","title":"generate_namd_eq","text":"<pre><code>generate_namd_eq(namd_eq, dst_dir, structure_name, engine, protein)\n</code></pre> <p>:param namd_eq: :param dst_dir: :param structure_name: :param engine: :param protein: :return:</p> Source code in <code>ties/generator.py</code> <pre><code>def generate_namd_eq(namd_eq, dst_dir, structure_name, engine, protein):\n    \"\"\"\n\n    :param namd_eq:\n    :param dst_dir:\n    :param structure_name:\n    :param engine:\n    :param protein:\n    :return:\n    \"\"\"\n    input_data = open(namd_eq).read()\n    for i in range(1, 3):\n        if i == 1:\n            run = \"\"\"\nconstraintScaling 1\nrun 10000\n            \"\"\"\n            pressure = \"\"\n        else:\n            run = \"\"\"\n# protocol - minimization\nset factor 1\nset nall 10\nset n 1\n\nwhile {$n &lt;= $nall} {\n   constraintScaling $factor\n   run 40000\n   set n [expr $n + 1]\n   set factor [expr $factor * 0.5]\n}\n\nconstraintScaling 0\nrun 600000\n            \"\"\"\n            if engine.lower() == \"namd\" or engine.lower() == \"namd2\":\n                pressure = \"\"\"\nuseGroupPressure      yes ;# needed for 2fs steps\nuseFlexibleCell       no  ;# no for water box, yes for membrane\nuseConstantArea       no  ;# no for water box, yes for membrane\nBerendsenPressure                       on\nBerendsenPressureTarget                 1.0\nBerendsenPressureCompressibility        4.57e-5\nBerendsenPressureRelaxationTime         100\nBerendsenPressureFreq                   2\n                \"\"\"\n            else:\n                pressure = \"\"\"\nuseGroupPressure      yes ;# needed for 2fs steps\nuseFlexibleCell       no  ;# no for water box, yes for membrane\nuseConstantArea       no  ;# no for water box, yes for membrane\nlangevinPiston          on             # Nose-Hoover Langevin piston pressure control\nlangevinPistonTarget  1.01325          # target pressure in bar 1atm = 1.01325bar\nlangevinPistonPeriod  50.0             # oscillation period in fs. correspond to pgamma T=50fs=0.05ps\nlangevinPistonTemp    300              # f=1/T=20.0(pgamma)\nlangevinPistonDecay   25.0             # oscillation decay time. smaller value correspons to larger random\n                                       # forces and increased coupling to the Langevin temp bath.\n                                       # Equall or smaller than piston period\n                \"\"\"\n\n        if protein is not None:\n            cons = f\"\"\"\n        constraints  on\n        consexp  2\n        # use the same file for the position reference and the B column\n        consref  ../build/{structure_name}.pdb ;#need all positions\n        conskfile  ../build/cons.pdb\n        conskcol  B\n                \"\"\"\n        else:\n            cons = \"constraints  off\"\n\n        prev_output = \"eq{}\".format(i - 1)\n\n        reformatted_namd_in = input_data.format(\n            constraints=cons,\n            output=\"eq%d\" % (i),\n            prev_output=prev_output,\n            structure_name=structure_name,\n            pressure=pressure,\n            run=run,\n        )\n\n        next_eq_step_filename = dst_dir / (\"eq%d.conf\" % (i))\n        open(next_eq_step_filename, \"w\").write(reformatted_namd_in)\n</code></pre>"},{"location":"reference/generator/#ties.generator.redistribute_charges","title":"redistribute_charges","text":"<pre><code>redistribute_charges(mda)\n</code></pre> <p>Calculate the original charges in the matched component.</p> Source code in <code>ties/generator.py</code> <pre><code>def redistribute_charges(mda):\n    \"\"\"\n    Calculate the original charges in the matched component.\n    \"\"\"\n\n    return\n</code></pre>"},{"location":"reference/helpers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> helpers","text":""},{"location":"reference/helpers/#ties.helpers","title":"helpers","text":"<p>A list of functions with a clear purpose that does not belong specifically to any of the existing units.</p> <p>Classes:</p> <ul> <li> <code>ArgparseChecker</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>get_new_atom_names</code>             \u2013              <p>todo - add unit tests</p> </li> <li> <code>get_atom_names_counter</code>             \u2013              <p>name_counter: a dictionary with atom as the key such as 'N', 'C', etc,</p> </li> <li> <code>parse_frcmod_sections</code>             \u2013              <p>Copied from the previous TIES. It's simpler and this approach must be fine then.</p> </li> </ul>"},{"location":"reference/helpers/#ties.helpers.ArgparseChecker","title":"ArgparseChecker","text":"<p>Methods:</p> <ul> <li> <code>str2bool</code>             \u2013              <p>ArgumentParser tool to figure out the bool value</p> </li> <li> <code>logging_lvl</code>             \u2013              <p>ArgumentParser tool to figure out the bool value</p> </li> </ul>"},{"location":"reference/helpers/#ties.helpers.ArgparseChecker.str2bool","title":"str2bool  <code>staticmethod</code>","text":"<pre><code>str2bool(v)\n</code></pre> <p>ArgumentParser tool to figure out the bool value</p> Source code in <code>ties/helpers.py</code> <pre><code>@staticmethod\ndef str2bool(v):\n    \"ArgumentParser tool to figure out the bool value\"\n    if isinstance(v, bool):\n        return v\n    if v.lower() in (\"yes\", \"true\", \"t\", \"y\", \"1\"):\n        return True\n    elif v.lower() in (\"no\", \"false\", \"f\", \"n\", \"0\"):\n        return False\n    else:\n        raise argparse.ArgumentTypeError(\"Boolean value expected.\")\n</code></pre>"},{"location":"reference/helpers/#ties.helpers.ArgparseChecker.logging_lvl","title":"logging_lvl  <code>staticmethod</code>","text":"<pre><code>logging_lvl(v)\n</code></pre> <p>ArgumentParser tool to figure out the bool value</p> Source code in <code>ties/helpers.py</code> <pre><code>@staticmethod\ndef logging_lvl(v):\n    \"ArgumentParser tool to figure out the bool value\"\n    logging_levels = {\n        \"NOTSET\": logging.NOTSET,\n        \"DEBUG\": logging.DEBUG,\n        \"INFO\": logging.INFO,\n        \"WARNING\": logging.WARNING,\n        \"ERROR\": logging.ERROR,\n        \"CRITICAL\": logging.CRITICAL,\n        # extras\n        \"ALL\": logging.INFO,\n        \"FALSE\": logging.ERROR,\n    }\n\n    if isinstance(v, bool) and v is True:\n        return logging.WARNING\n    elif isinstance(v, bool) and v is False:\n        # effectively we disable logging until an error happens\n        return logging.ERROR\n    elif v.upper() in logging_levels:\n        return logging_levels[v.upper()]\n    else:\n        raise argparse.ArgumentTypeError(\"Meaningful logging level expected.\")\n</code></pre>"},{"location":"reference/helpers/#ties.helpers.get_new_atom_names","title":"get_new_atom_names","text":"<pre><code>get_new_atom_names(atoms, name_counter=None)\n</code></pre> <p>todo - add unit tests</p> <p>@parameter/returns name_counter: a dictionary with atom as the key such as 'N', 'C', etc, the counter keeps track of the last used counter for each name. Empty means that the counting will start from 1. input atoms: mdanalysis atoms</p> Source code in <code>ties/helpers.py</code> <pre><code>def get_new_atom_names(atoms, name_counter=None):\n    \"\"\"\n    todo - add unit tests\n\n    @parameter/returns name_counter: a dictionary with atom as the key such as 'N', 'C', etc,\n    the counter keeps track of the last used counter for each name.\n    Empty means that the counting will start from 1.\n    input atoms: mdanalysis atoms\n    \"\"\"\n    if name_counter is None:\n        name_counter = {}\n\n    # {new_uniqe_name: old_atom_name}\n    reverse_renaming_map = {}\n\n    for atom in atoms:\n        # count the letters before any digit\n        letter_count = 0\n        for letter in atom.name:\n            if not letter.isalpha():\n                break\n\n            letter_count += 1\n\n        # use max 3 letters from the atom name\n        letter_count = min(letter_count, 3)\n\n        letters = atom.name[:letter_count]\n\n        # how many atoms do we have with these letters? ie C1, C2, C3 -&gt; 3\n        last_used_counter = name_counter.get(letters, 0) + 1\n\n        # rename\n        new_name = letters + str(last_used_counter)\n\n        # if the name is longer than 4 character,\n        # shorten the number of letters\n        if len(new_name) &gt; 4:\n            # the name is too long, use only the first character\n            new_name = letters[: 4 - len(str(last_used_counter))] + str(\n                last_used_counter\n            )\n\n            # we assume that there is fewer than 1000 atoms with that name\n            assert len(str(last_used_counter)) &lt; 1000\n\n        reverse_renaming_map[new_name] = atom.name\n\n        atom.name = new_name\n\n        # update the counter\n        name_counter[letters] = last_used_counter\n\n    return name_counter, reverse_renaming_map\n</code></pre>"},{"location":"reference/helpers/#ties.helpers.get_atom_names_counter","title":"get_atom_names_counter","text":"<pre><code>get_atom_names_counter(atoms)\n</code></pre> <p>name_counter: a dictionary with atom as the key such as 'N', 'C', etc, the counter keeps track of the last used counter for each name. Ie if there are C1, C2, C3, this will return {'C':3} as the last counter.</p> Source code in <code>ties/helpers.py</code> <pre><code>def get_atom_names_counter(atoms):\n    \"\"\"\n    name_counter: a dictionary with atom as the key such as 'N', 'C', etc,\n    the counter keeps track of the last used counter for each name.\n    Ie if there are C1, C2, C3, this will return {'C':3} as the last counter.\n    \"\"\"\n    name_counter = {}\n\n    for atom in atoms:\n        # get the first letters that is not a character\n        afterLetters = [i for i, j in enumerate(atom.name) if j.isalpha()][-1] + 1\n\n        atom_name = atom.name[:afterLetters]\n        atom_number = int(atom.name[afterLetters:])\n\n        # we are starting the counter from 0 as we always add 1 later on\n        last_used_counter = name_counter.get(atom_name, 0)\n\n        # update the counter\n        name_counter[atom_name] = max(last_used_counter + 1, atom_number)\n\n    return name_counter\n</code></pre>"},{"location":"reference/helpers/#ties.helpers.parse_frcmod_sections","title":"parse_frcmod_sections","text":"<pre><code>parse_frcmod_sections(filename)\n</code></pre> <p>Copied from the previous TIES. It's simpler and this approach must be fine then.</p> Source code in <code>ties/helpers.py</code> <pre><code>def parse_frcmod_sections(filename):\n    \"\"\"\n    Copied from the previous TIES. It's simpler and this approach must be fine then.\n    \"\"\"\n    frcmod_info = {}\n    section = \"REMARK\"\n\n    with open(filename) as F:\n        for line in F:\n            start_line = line[0:9].strip()\n\n            if start_line in [\"MASS\", \"BOND\", \"IMPROPER\", \"NONBON\", \"ANGLE\", \"DIHE\"]:\n                section = start_line\n                frcmod_info[section] = []\n            elif line.strip() and section != \"REMARK\":\n                frcmod_info[section].append(line)\n\n    return frcmod_info\n</code></pre>"},{"location":"reference/ligand/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> ligand","text":""},{"location":"reference/ligand/#ties.ligand","title":"ligand","text":"<p>Classes:</p> <ul> <li> <code>Ligand</code>           \u2013            <p>The ligand helper class. Helps to load and manage the different copies of the ligand file.</p> </li> </ul>"},{"location":"reference/ligand/#ties.ligand.Ligand","title":"Ligand","text":"<pre><code>Ligand(ligand, config=None, save=True, use_general_type=True)\n</code></pre> <p>The ligand helper class. Helps to load and manage the different copies of the ligand file. Specifically, it tracks the different copies of the original input files as it is transformed (e.g. charge assignment).</p> <p>:param ligand: ligand filepath or RDKit molecule :type ligand: string :param config: Optional configuration from which the relevant ligand settings can be used :type config: :class:<code>Config</code> :param save: write a file with unique atom names for further inspection :type save: bool</p> <p>Methods:</p> <ul> <li> <code>antechamber_prepare_mol2</code>             \u2013              <p>Converts the ligand into a .mol2 format.</p> </li> <li> <code>generate_frcmod</code>             \u2013              <p>params</p> </li> <li> <code>correct_atom_names</code>             \u2013              <p>Ensure that each atom name:</p> </li> <li> <code>are_atom_names_correct</code>             \u2013              <p>Checks if atom names:</p> </li> </ul> Source code in <code>ties/ligand.py</code> <pre><code>def __init__(self, ligand, config=None, save=True, use_general_type=True):\n    \"\"\"Constructor method\"\"\"\n\n    self.save = save\n    # save workplace root\n    self.config = Config() if config is None else config\n\n    if isinstance(ligand, rdkit.Chem.Mol):\n        pmd_structure = parsing.pmd_structure_from_rdmol(ligand)\n        atoms, bonds = parsing.get_atoms_bonds_from_pmd_structure(pmd_structure)\n\n        # at the moment we rely on paths as well\n        # make this molecule available as a file\n        short_uuid = str(uuid.uuid4())[:8]\n        lig_path = self.config.workdir / f\"{short_uuid}.sdf\"\n        with rdkit.Chem.SDWriter(lig_path) as SD:\n            SD.write(ligand)\n\n        ligand = lig_path\n    else:\n        # fixme - move use_general_type parameter to config for later\n        atoms, bonds, pmd_structure = parsing.get_atoms_bonds_and_parmed_structure(\n            ligand, use_general_type=use_general_type\n        )\n\n    self.pmd_structure = pmd_structure\n    self.atoms = atoms\n    self.bonds = bonds\n\n    self.config.ligand_files = ligand\n\n    self.original_input = Path(ligand).absolute()\n\n    # internal name without an extension\n    self.internal_name = self.original_input.stem\n\n    # last used representative Path file\n    self.current = self.original_input\n\n    self._renaming_map = None\n    self.ligand_with_uniq_atom_names = None\n</code></pre>"},{"location":"reference/ligand/#ties.ligand.Ligand.antechamber_prepare_mol2","title":"antechamber_prepare_mol2","text":"<pre><code>antechamber_prepare_mol2(**kwargs)\n</code></pre> <p>Converts the ligand into a .mol2 format.</p> <p>BCC charges are generated if missing or requested. It calls antechamber (the charge type -c is not used if user prefers to use their charges). Any DU atoms created in the antechamber call are removed.</p> <p>:param atom_type: Atom type bla bla :type atom_type: :param net_charge: :type net_charge: int</p> Source code in <code>ties/ligand.py</code> <pre><code>def antechamber_prepare_mol2(self, **kwargs):\n    \"\"\"\n    Converts the ligand into a .mol2 format.\n\n    BCC charges are generated if missing or requested.\n    It calls antechamber (the charge type -c is not used if user prefers to use their charges).\n    Any DU atoms created in the antechamber call are removed.\n\n    :param atom_type: Atom type bla bla\n    :type atom_type:\n    :param net_charge:\n    :type net_charge: int\n    \"\"\"\n    self.config.set_configs(**kwargs)\n\n    if self.config.ligands_contain_q or not self.config.antechamber_charge_type:\n        logger.info(\n            f\"Antechamber: User-provided atom charges will be reused ({self.current.name})\"\n        )\n\n    mol2_cwd = self.config.lig_dir / self.internal_name\n\n    # prepare the directory\n    mol2_cwd.mkdir(parents=True, exist_ok=True)\n    mol2_target = mol2_cwd / f\"{self.internal_name}.mol2\"\n\n    # do not redo if the target file exists\n    if not (mol2_target).is_file():\n        log_filename = mol2_cwd / \"antechamber.log\"\n        with open(log_filename, \"w\") as LOG:\n            try:\n                cmd = [\n                    self.config.ambertools_antechamber,\n                    \"-i\",\n                    self.current,\n                    \"-fi\",\n                    self.current.suffix[1:],\n                    \"-o\",\n                    mol2_target,\n                    \"-fo\",\n                    \"mol2\",\n                    \"-at\",\n                    self.config.ligand_ff_name,\n                    \"-nc\",\n                    str(self.config.ligand_net_charge),\n                    \"-dr\",\n                    str(self.config.antechamber_dr),\n                ] + self.config.antechamber_charge_type\n                subprocess.run(\n                    cmd,\n                    cwd=mol2_cwd,\n                    stdout=LOG,\n                    stderr=LOG,\n                    check=True,\n                    text=True,\n                    timeout=60 * 30,  # 30 minutes\n                )\n            except subprocess.CalledProcessError as ProcessError:\n                raise Exception(\n                    f\"Could not convert the ligand into .mol2 file with antechamber. \"\n                    f\"See the log and its directory: {log_filename} . \"\n                    f\"Command used: {' '.join(map(str, cmd))}\"\n                ) from ProcessError\n        logger.debug(\n            f\"Converted {self.original_input} into .mol2, Log: {log_filename}\"\n        )\n    else:\n        logger.info(f\"File {mol2_target} already exists. Skipping. \")\n\n    self.antechamber_mol2 = mol2_target\n    self.current = mol2_target\n\n    # remove any DUMMY DU atoms in the .mol2 atoms\n    self._removeDU_atoms()\n</code></pre>"},{"location":"reference/ligand/#ties.ligand.Ligand.generate_frcmod","title":"generate_frcmod","text":"<pre><code>generate_frcmod(**kwargs)\n</code></pre> <p>params  - parmchk2  - atom_type</p> Source code in <code>ties/ligand.py</code> <pre><code>def generate_frcmod(self, **kwargs):\n    \"\"\"\n    params\n     - parmchk2\n     - atom_type\n    \"\"\"\n    self.config.set_configs(**kwargs)\n\n    logger.debug(f\"INFO: frcmod for {self} was computed before. Not repeating.\")\n    if hasattr(self, \"frcmod\"):\n        return\n\n    # fixme - work on the file handles instaed of the constant stitching\n    logger.debug(f\"Parmchk2: generate the .frcmod for {self.internal_name}.mol2\")\n\n    # prepare cwd\n    cwd = self.config.lig_frcmod_dir / self.internal_name\n    if not cwd.is_dir():\n        cwd.mkdir(parents=True, exist_ok=True)\n\n    target_frcmod = f\"{self.internal_name}.frcmod\"\n    log_filename = cwd / \"parmchk2.log\"\n    with open(log_filename, \"w\") as LOG:\n        try:\n            subprocess.run(\n                [\n                    self.config.ambertools_parmchk2,\n                    \"-i\",\n                    self.current,\n                    \"-o\",\n                    target_frcmod,\n                    \"-f\",\n                    \"mol2\",\n                    \"-s\",\n                    self.config.ligand_ff_name,\n                ],\n                stdout=LOG,\n                stderr=LOG,\n                check=True,\n                text=True,\n                cwd=cwd,\n                timeout=20,  # 20 seconds\n            )\n        except subprocess.CalledProcessError as E:\n            raise Exception(\n                f\"GAFF Error: Could not generate FRCMOD for file: {self.current} . \"\n                f\"See more here: {log_filename}\"\n            ) from E\n\n    logger.debug(f\"Parmchk2: created frcmod: {target_frcmod}\")\n    self.frcmod = cwd / target_frcmod\n</code></pre>"},{"location":"reference/ligand/#ties.ligand.Ligand.correct_atom_names","title":"correct_atom_names","text":"<pre><code>correct_atom_names()\n</code></pre> Ensure that each atom name <ul> <li>is unique</li> <li>has letter followed by digits</li> <li>has max 4 characters</li> </ul> <p>E.g. C17, NX23</p> <p>:param self.save: if the path is provided, the updated file     will be saved with the unique names and a handle to the new file (ParmEd) will be returned.</p> Source code in <code>ties/ligand.py</code> <pre><code>def correct_atom_names(self):\n    \"\"\"\n    Ensure that each atom name:\n     - is unique\n     - has letter followed by digits\n     - has max 4 characters\n    E.g. C17, NX23\n\n    :param self.save: if the path is provided, the updated file\n        will be saved with the unique names and a handle to the new file (ParmEd) will be returned.\n    \"\"\"\n    if self.are_atom_names_correct():\n        return\n\n    logger.debug(f\"Ligand {self.internal_name} will have its atom names renamed. \")\n\n    ligand = parmed.load_file(str(self.current), structure=True)\n\n    logger.debug(\n        f\"Atom names in the molecule ({self.original_input}/{self.internal_name}) are either not unique \"\n        f\"or do not follow NameDigit format (e.g. C15). Renaming\"\n    )\n    _, renaming_map = get_new_atom_names(ligand.atoms)\n    self._renaming_map = renaming_map\n    logger.debug(f\"Rename map: {renaming_map}\")\n\n    # save the output here\n    os.makedirs(self.config.lig_unique_atom_names_dir, exist_ok=True)\n\n    ligand_with_uniq_atom_names = self.config.lig_unique_atom_names_dir / (\n        self.internal_name + self.current.suffix\n    )\n    if self.save:\n        ligand.save(str(ligand_with_uniq_atom_names))\n\n    self.ligand_with_uniq_atom_names = ligand_with_uniq_atom_names\n    self.parmed = ligand\n    # this object is now represented by the updated ligand\n    self.current = ligand_with_uniq_atom_names\n</code></pre>"},{"location":"reference/ligand/#ties.ligand.Ligand.are_atom_names_correct","title":"are_atom_names_correct","text":"<pre><code>are_atom_names_correct()\n</code></pre> Checks if atom names <ul> <li>are unique</li> <li>have a correct format \"LettersNumbers\" e.g. C17</li> </ul> Source code in <code>ties/ligand.py</code> <pre><code>def are_atom_names_correct(self):\n    \"\"\"\n    Checks if atom names:\n     - are unique\n     - have a correct format \"LettersNumbers\" e.g. C17\n    \"\"\"\n    ligand = parmed.load_file(str(self.current), structure=True)\n    atom_names = [a.name for a in ligand.atoms]\n\n    are_uniqe = len(set(atom_names)) == len(atom_names)\n\n    return are_uniqe\n</code></pre>"},{"location":"reference/ligandmap/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> ligandmap","text":""},{"location":"reference/ligandmap/#ties.ligandmap","title":"ligandmap","text":"<p>Classes:</p> <ul> <li> <code>LigandMap</code>           \u2013            <p>Work on a list of morphs and use their information to generate a each to each map.</p> </li> </ul>"},{"location":"reference/ligandmap/#ties.ligandmap.LigandMap","title":"LigandMap","text":"<pre><code>LigandMap(ligands, morphs)\n</code></pre> <p>Work on a list of morphs and use their information to generate a each to each map. This class then uses the information for  * clustering,  * path finding (traveling salesman, minimum spanning tree)  * visualisation, etc.</p> <p>Methods:</p> <ul> <li> <code>generate_map</code>             \u2013              <p>Use the underlying morphs to extract the each to each cases.</p> </li> </ul> Source code in <code>ties/ligandmap.py</code> <pre><code>def __init__(self, ligands, morphs):\n    self.morphs = morphs\n    self.ligands = ligands\n    # similarity map\n    self.map = None\n    self.map_weights = None\n    self.graph = None\n</code></pre>"},{"location":"reference/ligandmap/#ties.ligandmap.LigandMap.generate_map","title":"generate_map","text":"<pre><code>generate_map()\n</code></pre> <p>Use the underlying morphs to extract the each to each cases.</p> Source code in <code>ties/ligandmap.py</code> <pre><code>def generate_map(self):\n    \"\"\"\n    Use the underlying morphs to extract the each to each cases.\n    \"\"\"\n    # a simple 2D map of the ligands\n    self.map = [list(range(len(self.ligands))) for l1 in range(len(self.ligands))]\n\n    # weights based on the size of the superimposed topology\n    self.map_weights = numpy.zeros([len(self.ligands), len(self.ligands)])\n    for morph in self.morphs:\n        self.map[morph.ligA.index][morph.ligB.index] = morph\n        self.map[morph.ligB.index][morph.ligA.index] = morph\n\n        matched_left, matched_right, disappearing_atoms, appearing_atoms = (\n            morph.overlap_fractions()\n        )\n        # use the average number of matched fractions in both ligands\n        weight = 1 - (matched_left + matched_right) / 2.0\n        self.map_weights[morph.ligA.index][morph.ligB.index] = weight\n        self.map_weights[morph.ligB.index][morph.ligA.index] = weight\n\n        # update also the morph\n        morph.set_distance(weight)\n</code></pre>"},{"location":"reference/md/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> md","text":""},{"location":"reference/md/#ties.md","title":"md","text":"<p>Classes:</p> <ul> <li> <code>MD</code>           \u2013            <p>Class a wrapper around TIES_MD API that exposes a simplified interface.</p> </li> </ul>"},{"location":"reference/md/#ties.md.MD","title":"MD","text":"<pre><code>MD(sim_dir, sim_name='complex', fast=False)\n</code></pre> <p>Class a wrapper around TIES_MD API that exposes a simplified interface.</p> <p>:param sim_dir: str, points to where the simulation is running i.e where the TIES.cfg file is. :param sim_name: str, the prefix to the input param and topo file i.e complex for complex.pdb/prmtop. :param fast: boolean, if True the setting is TIES.cfg will be overwritten with minimal TIES protocol.</p> <p>Methods:</p> <ul> <li> <code>run</code>             \u2013              <p>Wrapper for TIES_MD.TIES.run()</p> </li> <li> <code>analysis</code>             \u2013              <p>Wrapper for TIES_MD.ties_analysis()</p> </li> </ul> Source code in <code>ties/md.py</code> <pre><code>def __init__(self, sim_dir, sim_name=\"complex\", fast=False):\n    cwd = os.getcwd()\n    self.sim_dir = os.path.join(cwd, sim_dir)\n    self.analysis_dir = os.path.join(self.sim_dir, \"..\", \"..\", \"..\")\n    # This is the main TIES MD object we call it options as the user interacts with this object to change options\n    self.options = TIES(cwd=self.sim_dir, exp_name=sim_name)\n\n    if fast:\n        # modify md to cut as many corners as possible i.e. reps, windows, sim length\n        self.options.total_reps = 3\n        self.options.global_lambdas = [\n            0.00,\n            0.05,\n            0.1,\n            0.3,\n            0.5,\n            0.7,\n            0.9,\n            0.95,\n            1.00,\n        ]\n        self.options.sampling_per_window = 2 * unit.nanoseconds()\n\n    self.options.setup()\n</code></pre>"},{"location":"reference/md/#ties.md.MD.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Wrapper for TIES_MD.TIES.run()</p> <p>:return: None</p> Source code in <code>ties/md.py</code> <pre><code>def run(self):\n    \"\"\"\n    Wrapper for TIES_MD.TIES.run()\n\n    :return: None\n    \"\"\"\n    self.options.run()\n</code></pre>"},{"location":"reference/md/#ties.md.MD.analysis","title":"analysis","text":"<pre><code>analysis(legs, analysis_cfg='./analysis.cfg')\n</code></pre> <p>Wrapper for TIES_MD.ties_analysis()</p> <p>:param legs: list of strings, these are the thermodynamic legs of the simulation i.e. ['lig', 'com']. :param analysis_cfg: str, for what the analysis config file is called.</p> <p>:return: None</p> Source code in <code>ties/md.py</code> <pre><code>def analysis(self, legs, analysis_cfg=\"./analysis.cfg\"):\n    \"\"\"\n    Wrapper for TIES_MD.ties_analysis()\n\n    :param legs: list of strings, these are the thermodynamic legs of the simulation i.e. ['lig', 'com'].\n    :param analysis_cfg: str, for what the analysis config file is called.\n\n    :return: None\n    \"\"\"\n    os.chdir(self.analysis_dir)\n    if not os.path.exists(\"exp.dat\"):\n        ties_analysis.make_exp(verbose=False)\n\n    # read the experimental data\n    with open(\"exp.dat\") as f:\n        data = f.read()\n    exp_js = json.loads(data)\n\n    ana_cfg = ties_analysis.Config(analysis_cfg)\n    ana_cfg.simulation_legs = legs\n    ana_cfg.exp_data = exp_js\n    ana = ties_analysis.Analysis(ana_cfg)\n    ana.run()\n</code></pre>"},{"location":"reference/namd_generator/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> namd_generator","text":""},{"location":"reference/namd_generator/#ties.namd_generator","title":"namd_generator","text":"<p>Load two ligands, run the topology superimposer, and then using the results, generate the NAMD input files.</p> <p>frcmod file format: http://ambermd.org/FileFormats.php#frcmod</p>"},{"location":"reference/overlay/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> overlay","text":""},{"location":"reference/overlay/#ties.overlay","title":"overlay","text":"<p>Functions:</p> <ul> <li> <code>merge_compatible_suptops_faster</code>             \u2013              <p>:param pairing_suptop:</p> </li> <li> <code>extract_best_suptop</code>             \u2013              <p>Assumes that any merging possible already took place.</p> </li> </ul>"},{"location":"reference/overlay/#ties.overlay.merge_compatible_suptops_faster","title":"merge_compatible_suptops_faster","text":"<pre><code>merge_compatible_suptops_faster(pairing_suptop: dict, min_bonds: int)\n</code></pre> <p>:param pairing_suptop: :param min_bonds: if the End molecule at this point has only two bonds, they can be mapped to two other bonds     in the start molecule. :return:</p> Source code in <code>ties/overlay.py</code> <pre><code>def merge_compatible_suptops_faster(pairing_suptop: dict, min_bonds: int):\n    \"\"\"\n\n    :param pairing_suptop:\n    :param min_bonds: if the End molecule at this point has only two bonds, they can be mapped to two other bonds\n        in the start molecule.\n    :return:\n    \"\"\"\n\n    if len(pairing_suptop) == 1:\n        return [pairing_suptop.popitem()[1]]\n\n    # any to any\n    all_pairings = list(itertools.combinations(pairing_suptop.keys(), r=min_bonds))\n\n    if min_bonds == 3:\n        all_pairings += list(itertools.combinations(pairing_suptop.keys(), r=2))\n    selected_pairings = all_pairings\n\n    # selected_pairings = []\n    # for pairings in all_pairings:\n    #     n = set()\n    #     for pairing in pairings:\n    #         n.add(pairing[0])\n    #         n.add(pairing[1])\n    #     #\n    #     if 2 * len(pairings) == len(n):\n    #         selected_pairings.append(pairings)\n\n    # start with all the suptops as starting points\n    # this is because it might be impossible to merge\n    # any of the paths\n    # in which case the default paths will be the best\n    built_topologies = list(pairing_suptop.values())\n\n    # attempt to combine the different traversals\n    for mapping in selected_pairings:\n        # mapping the different bonds to different bonds\n\n        # check if the suptops are consistent with each other\n        if not are_consistent_topologies([pairing_suptop[key] for key in mapping]):\n            continue\n\n        # merge them!\n        large_suptop = copy.copy(pairing_suptop[mapping[0]])\n        for next_map in mapping[1:]:\n            next_suptop = pairing_suptop[next_map]\n\n            # add both the pairs and the bonds that are not present in st1\n            large_suptop.merge(next_suptop)\n\n        built_topologies.append(large_suptop)\n\n    return built_topologies\n</code></pre>"},{"location":"reference/overlay/#ties.overlay.extract_best_suptop","title":"extract_best_suptop","text":"<pre><code>extract_best_suptop(suptops, ignore_coords, weights, get_list=False)\n</code></pre> <p>Assumes that any merging possible already took place. We now have a set of solutions and have to select the best ones.</p> <p>:param suptops: :param ignore_coords: :return:</p> Source code in <code>ties/overlay.py</code> <pre><code>def extract_best_suptop(suptops, ignore_coords, weights, get_list=False):\n    \"\"\"\n    Assumes that any merging possible already took place.\n    We now have a set of solutions and have to select the best ones.\n\n    :param suptops:\n    :param ignore_coords:\n    :return:\n    \"\"\"\n\n    # fixme - ignore coords currently does not work\n    # multiple different paths to traverse the topologies were found\n    # this means some kind of symmetry in the topologies\n    # For example, in the below drawn case (starting from C1-C11) there are two\n    # solutions: (O1-O11, O2-O12) and (O1-O12, O2-O11).\n    #     LIGAND 1        LIGAND 2\n    #        C1              C11\n    #        \\                \\\n    #        N1              N11\n    #        /\\              / \\\n    #     O1    O2        O11   O12\n    # Here we decide which of the mappings is better.\n    # fixme - uses coordinates to decide which mapping is better.\n    #  - Improve: use dihedral angles to decide which mapping is better too\n    def item_or_list(suptops):\n        if get_list:\n            return suptops\n        else:\n            return suptops[0]\n\n    if len(suptops) == 0:\n        warnings.warn(\"Cannot decide on the best mapping without any suptops...\")\n        return None\n\n    elif len(suptops) == 1:\n        return item_or_list(suptops)\n\n    # candidates = copy.copy(suptops)\n\n    # sort from largest to smallest\n    suptops.sort(key=lambda st: len(st), reverse=True)\n\n    if ignore_coords:\n        return item_or_list(suptops)\n\n    # when length is the same, take the smaller RMSD\n    # most likely this is about hydrogens\n    different_length_suptops = []\n    for key, same_length_suptops in itertools.groupby(suptops, key=lambda st: len(st)):\n        # order by RMSD\n        sorted_by_rmsd = sorted(\n            same_length_suptops, key=lambda st: st.align_ligands_using_mcs()\n        )\n        # these have the same lengths and the same RMSD, so they must be mirrors\n        for suptop in sorted_by_rmsd[1:]:\n            if suptop.is_mirror_of(sorted_by_rmsd[0]):\n                sorted_by_rmsd[0].add_mirror_suptop(suptop)\n            else:\n                # add it as a different solution\n                different_length_suptops.append(suptop)\n        different_length_suptops.append(sorted_by_rmsd[0])\n\n    # sort using weights\n    # score = mcs_score * weight - rmsd * weight ;\n    def score(st):\n        # inverse for 0 to be optimal\n        mcs_score = (1 - st.mcs_score()) * weights[0]\n\n        # rmsd 0 is best as well\n        rmsd_score = st.align_ligands_using_mcs() * weights[1]\n\n        return (mcs_score + rmsd_score) / len(weights)\n\n    different_length_suptops.sort(key=score)\n    # if they have a different length, there must be a reason why it is better.\n    # todo\n\n    return item_or_list(different_length_suptops)\n</code></pre>"},{"location":"reference/pair/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> pair","text":""},{"location":"reference/pair/#ties.pair","title":"pair","text":"<p>Classes:</p> <ul> <li> <code>Pair</code>           \u2013            <p>Facilitates the creation of morphs.</p> </li> </ul>"},{"location":"reference/pair/#ties.pair.Pair","title":"Pair","text":"<pre><code>Pair(ligA, ligB, config=None, **kwargs)\n</code></pre> <p>Facilitates the creation of morphs. It offers functionality related to a pair of ligands (a transformation).</p> <p>:param ligA: The ligand to be used as the starting state for the transformation. :type ligA: :class:<code>Ligand</code> or string :param ligB: The ligand to be used as the ending point of the transformation. :type ligB: :class:<code>Ligand</code> or string :param config: The configuration object holding all settings. :type config: :class:<code>Config</code></p> <p>fixme - list all relevant kwargs here</p> <pre><code>param ligand_net_charge: integer, net charge of each ligand (has to be the same)\n</code></pre> <p>Methods:</p> <ul> <li> <code>superimpose</code>             \u2013              <p>Please see :class:<code>Config</code> class for the documentation of kwargs. The passed kwargs overwrite the config</p> </li> <li> <code>set_suptop</code>             \u2013              <p>Attach a SuperimposedTopology object along with the ParmEd objects for the ligA and ligZ.</p> </li> <li> <code>make_atom_names_unique</code>             \u2013              <p>Ensure that each that atoms across the two ligands have unique names.</p> </li> <li> <code>check_json_file</code>             \u2013              <p>Performance optimisation in case TIES is rerun again. Return the first matched atoms which</p> </li> <li> <code>merge_frcmod_files</code>             \u2013              <p>Merges the .frcmod files generated for each ligand separately, simply by adding them together.</p> </li> <li> <code>overlap_fractions</code>             \u2013              <p>Calculate the size of the common area.</p> </li> </ul> Source code in <code>ties/pair.py</code> <pre><code>def __init__(self, ligA, ligB, config=None, **kwargs):\n    \"\"\"\n    Please use the Config class for the documentation of the possible kwargs.\n    Each kwarg is passed to the config class.\n\n    fixme - list all relevant kwargs here\n\n        param ligand_net_charge: integer, net charge of each ligand (has to be the same)\n    \"\"\"\n\n    # create a new config if it is not provided\n    self.config = ties.config.Config() if config is None else config\n\n    # channel all config variables to the config class\n    self.config.set_configs(**kwargs)\n\n    # tell Config about the ligands if necessary\n    if self.config.ligands is None:\n        self.config.ligands = [ligA, ligB]\n\n    # create ligands if they're just paths\n    if isinstance(ligA, ties.ligand.Ligand):\n        self.ligA = ligA\n    else:\n        self.ligA = ties.ligand.Ligand(ligA, self.config)\n\n    if isinstance(ligB, ties.ligand.Ligand):\n        self.ligB = ligB\n    else:\n        self.ligB = ties.ligand.Ligand(ligB, self.config)\n\n    # initialise the filepaths to the molecules that morph\n    self.current_ligA = self.ligA.current\n    self.current_ligB = self.ligB.current\n\n    self.internal_name = f\"{self.ligA.internal_name}_{self.ligB.internal_name}\"\n    self.mol2 = None\n    self.pdb = None\n    self.summary = None\n    self.suptop = None\n    self.mda_l1 = None\n    self.mda_l2 = None\n    self.distance = None\n</code></pre>"},{"location":"reference/pair/#ties.pair.Pair.superimpose","title":"superimpose","text":"<pre><code>superimpose(**kwargs)\n</code></pre> <p>Please see :class:<code>Config</code> class for the documentation of kwargs. The passed kwargs overwrite the config object passed in the constructor.</p> <p>fixme - list all relevant kwargs here</p> Source code in <code>ties/pair.py</code> <pre><code>def superimpose(self, **kwargs):\n    \"\"\"\n    Please see :class:`Config` class for the documentation of kwargs. The passed kwargs overwrite the config\n    object passed in the constructor.\n\n    fixme - list all relevant kwargs here\n    \"\"\"\n    self.config.set_configs(**kwargs)\n\n    self.ligA.use_element(self.config._use_element_in_superimposition)\n    self.ligB.use_element(self.config._use_element_in_superimposition)\n\n    # extract data from the ligands\n    ligA_atoms = self.ligA.atoms\n    ligA_pmd_structure = self.ligA.pmd_structure\n\n    ligB_atoms = self.ligB.atoms\n    ligB_pmd_structure = self.ligB.pmd_structure\n\n    # TODO - check that these atoms exist, use indices instead of names, ideally C:7 (Element:Idx)\n    new_mismatch_names = []\n    for a, z in self.config.manually_mismatched_pairs:\n        raise NotImplementedError(\"renamed not needed\")\n        new_names = (self.ligA.rev_renaming_map[a], self.ligB.rev_renaming_map[z])\n        logger.debug(\n            f\"Selecting mismatching atoms. The mismatch {(a, z)}) was renamed to {new_names}\"\n        )\n        new_mismatch_names.append(new_names)\n\n    # fixme - this should be moved out of here,\n    #  ideally there would be a function in the main interface for this\n    manual_match = (\n        []\n        if self.config.manually_matched_atom_pairs is None\n        else self.config.manually_matched_atom_pairs\n    )\n    starting_node_pairs = []\n    for l_aname, r_aname in manual_match:\n        # find the starting node pairs, ie the manually matched pair(s)\n        found_left_node = None\n        for atom in ligA_atoms:\n            if l_aname == atom.name:\n                found_left_node = atom\n        if found_left_node is None:\n            raise ValueError(\n                f'Manual Matching: could not find an atom name: \"{l_aname}\" in the left molecule'\n            )\n\n        found_right_node = None\n        for atom in ligB_atoms:\n            if r_aname == atom.name:\n                found_right_node = atom\n        if found_right_node is None:\n            raise ValueError(\n                f'Manual Matching: could not find an atom name: \"{r_aname}\" in the right molecule'\n            )\n\n        starting_node_pairs.append([found_left_node, found_right_node])\n\n    if starting_node_pairs:\n        logger.debug(f\"Starting nodes will be used: {starting_node_pairs}\")\n\n    logging_key = str(self)\n\n    # fixme - simplify to only take the ParmEd as input\n    suptop = superimpose_topologies(\n        ligA_atoms,\n        ligB_atoms,\n        disjoint_components=self.config.allow_disjoint_components,\n        net_charge_filter=True,\n        pair_charge_atol=self.config.atom_pair_q_atol,\n        net_charge_threshold=self.config.net_charge_threshold,\n        redistribute_charges_over_unmatched=self.config.redistribute_q_over_unmatched,\n        ignore_charges_completely=self.config.ignore_charges_completely,\n        ignore_bond_types=True,\n        ignore_coords=False,\n        partial_rings_allowed=self.config.partial_ring_allowed,\n        align_molecules=self.config.align_molecules_using_mcs,\n        use_general_type=self.config.use_element_in_superimposition,\n        # fixme - not the same ... use_element_in_superimposition,\n        use_only_element=False,\n        starting_pairs_heuristics=self.config.superimposition_starting_heuristic,  # fixme - add to config\n        force_mismatch=new_mismatch_names,\n        starting_node_pairs=starting_node_pairs,\n        parmed_ligA=ligA_pmd_structure,\n        parmed_ligB=ligB_pmd_structure,\n        starting_pair_seed=self.config.superimposition_starting_pairs,\n        logging_key=logging_key,\n        config=self.config,\n    )\n\n    self.set_suptop(suptop, ligA_pmd_structure, ligB_pmd_structure)\n    # attach the used config to the suptop\n\n    if suptop is not None:\n        suptop.config = self.config\n        # attach the morph to the suptop\n        suptop.morph = self\n\n    return suptop\n</code></pre>"},{"location":"reference/pair/#ties.pair.Pair.set_suptop","title":"set_suptop","text":"<pre><code>set_suptop(suptop, parmed_ligA, parmed_ligZ)\n</code></pre> <p>Attach a SuperimposedTopology object along with the ParmEd objects for the ligA and ligZ.</p> <p>:param suptop: :class:<code>SuperimposedTopology</code> :param parmed_ligA: An ParmEd for the ligA :param parmed_ligZ: An ParmEd for the ligZ</p> Source code in <code>ties/pair.py</code> <pre><code>def set_suptop(self, suptop, parmed_ligA, parmed_ligZ):\n    \"\"\"\n    Attach a SuperimposedTopology object along with the ParmEd objects for the ligA and ligZ.\n\n    :param suptop: :class:`SuperimposedTopology`\n    :param parmed_ligA: An ParmEd for the ligA\n    :param parmed_ligZ: An ParmEd for the ligZ\n    \"\"\"\n    self.suptop = suptop\n    self.parmed_ligA = parmed_ligA\n    self.parmed_ligZ = parmed_ligZ\n</code></pre>"},{"location":"reference/pair/#ties.pair.Pair.make_atom_names_unique","title":"make_atom_names_unique","text":"<pre><code>make_atom_names_unique(out_ligA_filename=None, out_ligZ_filename=None, save=True)\n</code></pre> <p>Ensure that each that atoms across the two ligands have unique names.</p> <p>While renaming atoms, start with the element (C, N, ..) followed by  the count so far (e.g. C1, C2, N1).</p> <p>Resnames are set to \"INI\" and \"FIN\", this is useful for the hybrid dual topology.</p> <p>:param out_ligA_filename: The new filenames for the ligands with renamed atoms. If None, the default     naming convention is used. :type out_ligA_filename: string or bool :param out_ligZ_filename: The new filenames for the ligands with renamed atoms. If None, the default     naming convention is used. :type out_ligZ_filename: string or bool :param save: Whether to save to the disk the ligands after renaming the atoms :type save: bool</p> Source code in <code>ties/pair.py</code> <pre><code>def make_atom_names_unique(\n    self, out_ligA_filename=None, out_ligZ_filename=None, save=True\n):\n    \"\"\"\n    Ensure that each that atoms across the two ligands have unique names.\n\n    While renaming atoms, start with the element (C, N, ..) followed by\n     the count so far (e.g. C1, C2, N1).\n\n    Resnames are set to \"INI\" and \"FIN\", this is useful for the hybrid dual topology.\n\n    :param out_ligA_filename: The new filenames for the ligands with renamed atoms. If None, the default\n        naming convention is used.\n    :type out_ligA_filename: string or bool\n    :param out_ligZ_filename: The new filenames for the ligands with renamed atoms. If None, the default\n        naming convention is used.\n    :type out_ligZ_filename: string or bool\n    :param save: Whether to save to the disk the ligands after renaming the atoms\n    :type save: bool\n    \"\"\"\n\n    # The A ligand is a template for the renaming\n    self.ligA.correct_atom_names()\n\n    # load both ligands\n    left = parmed.load_file(str(self.ligA.current), structure=True)\n    right = parmed.load_file(str(self.ligB.current), structure=True)\n\n    common_atom_names = {a.name for a in right.atoms}.intersection(\n        {a.name for a in left.atoms}\n    )\n    atom_names_overlap = len(common_atom_names) &gt; 0\n\n    if atom_names_overlap or not self.ligB.are_atom_names_correct():\n        logger.debug(\n            f\"Renaming ({self.ligA.internal_name}) molecule ({self.ligB.internal_name}) atom names are either reused or do not follow the correct format. \"\n        )\n        if atom_names_overlap:\n            logger.debug(f\"Common atom names: {common_atom_names}\")\n        name_counter_L_nodes = ties.helpers.get_atom_names_counter(left.atoms)\n        _, renaming_map = ties.helpers.get_new_atom_names(\n            right.atoms, name_counter=name_counter_L_nodes\n        )\n        self.ligB.renaming_map = renaming_map\n\n    # rename the residue names to INI and FIN\n    for atom in left.atoms:\n        atom.residue = \"INI\"\n    for atom in right.atoms:\n        atom.residue = \"FIN\"\n\n    # fixme - instead of using the save parameter, have a method pair.save(filename1, filename2) and\n    #  call it when necessary.\n    # prepare the destination directory\n    if not save:\n        return\n\n    if out_ligA_filename is None:\n        cwd = (\n            self.config.pair_unique_atom_names_dir\n            / f\"{self.ligA.internal_name}_{self.ligB.internal_name}\"\n        )\n        cwd.mkdir(parents=True, exist_ok=True)\n\n        self.current_ligA = cwd / (self.ligA.internal_name + \".mol2\")\n        self.current_ligB = cwd / (self.ligB.internal_name + \".mol2\")\n    else:\n        self.current_ligA = out_ligA_filename\n        self.current_ligB = out_ligZ_filename\n\n    # save the updated atom names\n    left.save(str(self.current_ligA))\n    right.save(str(self.current_ligB))\n</code></pre>"},{"location":"reference/pair/#ties.pair.Pair.check_json_file","title":"check_json_file","text":"<pre><code>check_json_file()\n</code></pre> <p>Performance optimisation in case TIES is rerun again. Return the first matched atoms which can be used as a seed for the superimposition.</p> <p>:return: If the superimposition was computed before, and the .json file is available,     gets one of the matched atoms. :rtype: [(ligA_atom, ligZ_atom)]</p> Source code in <code>ties/pair.py</code> <pre><code>def check_json_file(self):\n    \"\"\"\n    Performance optimisation in case TIES is rerun again. Return the first matched atoms which\n    can be used as a seed for the superimposition.\n\n    :return: If the superimposition was computed before, and the .json file is available,\n        gets one of the matched atoms.\n    :rtype: [(ligA_atom, ligZ_atom)]\n    \"\"\"\n    matching_json = (\n        self.config.workdir\n        / f\"fep_{self.ligA.internal_name}_{self.ligB.internal_name}.json\"\n    )\n    if not matching_json.is_file():\n        return None\n\n    return [list(json.load(matching_json.open())[\"matched\"].items())[0]]\n</code></pre>"},{"location":"reference/pair/#ties.pair.Pair.merge_frcmod_files","title":"merge_frcmod_files","text":"<pre><code>merge_frcmod_files(ligcom=None)\n</code></pre> <p>Merges the .frcmod files generated for each ligand separately, simply by adding them together.</p> <p>The duplication has no effect on the final generated topology parm7 top file.</p> <p>We are also testing the .frcmod here with the user's force field in order to check if the merge works correctly.</p> <p>:param ligcom: Either \"lig\" if only ligands are present, or \"com\" if the complex is present.     Helps with the directory structure. :type ligcom: string \"lig\" or \"com\"</p> Source code in <code>ties/pair.py</code> <pre><code>def merge_frcmod_files(self, ligcom=None):\n    \"\"\"\n    Merges the .frcmod files generated for each ligand separately, simply by adding them together.\n\n    The duplication has no effect on the final generated topology parm7 top file.\n\n    We are also testing the .frcmod here with the user's force field in order to check if\n    the merge works correctly.\n\n    :param ligcom: Either \"lig\" if only ligands are present, or \"com\" if the complex is present.\n        Helps with the directory structure.\n    :type ligcom: string \"lig\" or \"com\"\n    \"\"\"\n    ambertools_tleap = self.config.ambertools_tleap\n    ambertools_script_dir = self.config.ambertools_script_dir\n    if self.config.protein is None:\n        protein_ff = None\n    else:\n        protein_ff = self.config.protein_ff\n\n    ligand_ff = self.config.ligand_ff\n\n    frcmod_info1 = ties.helpers.parse_frcmod_sections(self.ligA.frcmod)\n    frcmod_info2 = ties.helpers.parse_frcmod_sections(self.ligB.frcmod)\n\n    cwd = self.config.workdir\n\n    # fixme: use the provided cwd here, otherwise this will not work if the wrong cwd is used\n    # have some conf module instead of this\n    if ligcom:\n        morph_frcmod = (\n            cwd\n            / f\"ties-{self.ligA.internal_name}-{self.ligB.internal_name}\"\n            / ligcom\n            / \"build\"\n            / \"hybrid.frcmod\"\n        )\n    else:\n        # fixme - clean up\n        morph_frcmod = (\n            cwd\n            / f\"ties-{self.ligA.internal_name}-{self.ligB.internal_name}\"\n            / \"build\"\n            / \"hybrid.frcmod\"\n        )\n    morph_frcmod.parent.mkdir(parents=True, exist_ok=True)\n    with open(morph_frcmod, \"w\") as FOUT:\n        FOUT.write(\"merged frcmod\\n\")\n\n        for section in [\"MASS\", \"BOND\", \"ANGLE\", \"DIHE\", \"IMPROPER\", \"NONBON\"]:\n            section_lines = frcmod_info1[section] + frcmod_info2[section]\n            FOUT.write(\"{0:s}\\n\".format(section))\n            for line in section_lines:\n                FOUT.write(\"{0:s}\".format(line))\n            FOUT.write(\"\\n\")\n\n        FOUT.write(\"\\n\\n\")\n\n    # this is our current frcmod file\n    self.frcmod = morph_frcmod\n\n    # as part of the .frcmod writing\n    # insert dummy angles/dihedrals if a morph .frcmod requires\n    # new terms between the appearing/disappearing atoms\n    # this is a trick to make sure tleap has everything it needs to generate the .top file\n    correction_introduced = self._check_hybrid_frcmod(\n        ambertools_tleap, ambertools_script_dir, protein_ff, ligand_ff\n    )\n    if correction_introduced:\n        # move the .frcmod which turned out to be insufficient according to the test\n        shutil.move(morph_frcmod, str(self.frcmod) + \".uncorrected\")\n        # now copy in place the corrected version\n        shutil.copy(self.frcmod, morph_frcmod)\n</code></pre>"},{"location":"reference/pair/#ties.pair.Pair.overlap_fractions","title":"overlap_fractions","text":"<pre><code>overlap_fractions()\n</code></pre> <p>Calculate the size of the common area.</p> <p>:return: Four decimals capturing: 1) the fraction of the common size with respect to the ligA topology,     2) the fraction of the common size with respect to the ligZ topology,     3) the percentage of the disappearing atoms in the disappearing molecule     4) the percentage of the appearing atoms  in the appearing molecule :rtype: [float, float, float, float]</p> Source code in <code>ties/pair.py</code> <pre><code>def overlap_fractions(self):\n    \"\"\"\n    Calculate the size of the common area.\n\n    :return: Four decimals capturing: 1) the fraction of the common size with respect to the ligA topology,\n        2) the fraction of the common size with respect to the ligZ topology,\n        3) the percentage of the disappearing atoms in the disappearing molecule\n        4) the percentage of the appearing atoms  in the appearing molecule\n    :rtype: [float, float, float, float]\n    \"\"\"\n\n    if self.suptop is None:\n        return 0, 0, float(\"inf\"), float(\"inf\")\n    else:\n        mcs_size = len(self.suptop.matched_pairs)\n\n    matched_fraction_left = mcs_size / float(len(self.suptop.top1))\n    matched_fraction_right = mcs_size / float(len(self.suptop.top2))\n    disappearing_atoms_fraction = (\n        (len(self.suptop.top1) - mcs_size) / float(len(self.suptop.top1)) * 100\n    )\n    appearing_atoms_fraction = (\n        (len(self.suptop.top2) - mcs_size) / float(len(self.suptop.top2)) * 100\n    )\n\n    return (\n        matched_fraction_left,\n        matched_fraction_right,\n        disappearing_atoms_fraction,\n        appearing_atoms_fraction,\n    )\n</code></pre>"},{"location":"reference/parsing/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> parsing","text":""},{"location":"reference/parsing/#ties.parsing","title":"parsing","text":"<p>Functions:</p> <ul> <li> <code>pmd_structure_from_rdmol</code>             \u2013              <p>Generate a parmed structure from an RDKit Mol.</p> </li> <li> <code>get_atoms_bonds_and_parmed_structure</code>             \u2013              <p>:param filename:</p> </li> <li> <code>correct_mol2_gaff_atoms</code>             \u2013              <p>The mol2 gaff atom types are not understood by Parmed.</p> </li> <li> <code>get_atoms_bonds_from_pmd_structure</code>             \u2013              </li> <li> <code>do_atom_names_have_simple_format</code>             \u2013              <p>Check if the atom name is followed by a number, e.g. \"C15\"</p> </li> </ul>"},{"location":"reference/parsing/#ties.parsing--convert-the-parmed-atoms-into-atom-objects","title":"convert the Parmed atoms into Atom objects.","text":""},{"location":"reference/parsing/#ties.parsing.pmd_structure_from_rdmol","title":"pmd_structure_from_rdmol","text":"<pre><code>pmd_structure_from_rdmol(rd_mol: Mol)\n</code></pre> <p>Generate a parmed structure from an RDKit Mol.</p> <p>The atom types and charges are extracted from the properties.</p> <p>:param rd_mol: :return:</p> Source code in <code>ties/parsing.py</code> <pre><code>def pmd_structure_from_rdmol(rd_mol: rdkit.Chem.Mol):\n    \"\"\"\n    Generate a parmed structure from an RDKit Mol.\n\n    The atom types and charges are extracted from the properties.\n\n    :param rd_mol:\n    :return:\n    \"\"\"\n\n    # use directly PDB since that is what parmed is always using\n    fh = StringIO(rdkit.Chem.MolToPDBBlock(rd_mol))\n    parmed_structure = PDBFile.parse(fh, skip_bonds=True)\n\n    # verify that they are the same structures\n    for rd_a, pmd_a in zip(rd_mol.GetAtoms(), parmed_structure.atoms):\n        assert rd_a.GetAtomicNum() == pmd_a.atomic_number\n\n    # extract the charges and the atom types\n    pq_prop_openff = \"atom.dprop.PartialCharge\"\n    if rd_mol.HasProp(pq_prop_openff):\n        pqs = list(map(float, rd_mol.GetProp(pq_prop_openff).split()))\n        assert len(pqs) == rd_mol.GetNumAtoms()\n        for atom, pq in zip(parmed_structure.atoms, pqs):\n            atom.charge = pq\n    else:\n        warnings.warn(\n            f\"Missing partial charges property ({pq_prop_openff}) from the RDKit Mol\"\n        )\n\n    at_prop = \"BCCAtomTypes\"\n    if rd_mol.HasProp(\"%s\" % at_prop):\n        ats = ast.literal_eval(rd_mol.GetProp(\"%s\" % at_prop))\n        assert len(ats) == rd_mol.GetNumAtoms()\n        for atom, pq in zip(parmed_structure.atoms, ats):\n            atom.type = pq\n    else:\n        warnings.warn(f\"Missing atom types property ({at_prop}) in the RDKit molecule\")\n\n    # check if every bond from the RDKit molecule is in the parmed structure\n    for rd_bond in rd_mol.GetBonds():\n        found = False\n        for pmd_bond in parmed_structure.bonds:\n            if (\n                rd_bond.GetBeginAtomIdx() == pmd_bond.atom1.idx\n                and rd_bond.GetEndAtomIdx() == pmd_bond.atom2.idx\n            ):\n                found = True\n\n        if not found:\n            raise Exception(\n                \"Missing a bond in parmed structure after a conversion from an rdkit molecule\"\n            )\n\n    # check the opposite, are there any extra bonds?\n    for pmd_bond in parmed_structure.bonds:\n        found = False\n        for rd_bond in rd_mol.GetBonds():\n            if (\n                rd_bond.GetBeginAtomIdx() == pmd_bond.atom1.idx\n                and rd_bond.GetEndAtomIdx() == pmd_bond.atom2.idx\n            ):\n                found = True\n                break\n\n        if not found:\n            raise Exception(\n                \"The new parmed structure contains a bond that could not be found in the original rdkit molecule\"\n            )\n\n    return parmed_structure\n</code></pre>"},{"location":"reference/parsing/#ties.parsing.get_atoms_bonds_and_parmed_structure","title":"get_atoms_bonds_and_parmed_structure","text":"<pre><code>get_atoms_bonds_and_parmed_structure(filename, use_general_type=True)\n</code></pre> <p>:param filename: :param use_general_type: :return: (atoms, bonds, parmed_structure)</p> Source code in <code>ties/parsing.py</code> <pre><code>def get_atoms_bonds_and_parmed_structure(filename, use_general_type=True):\n    \"\"\"\n\n    :param filename:\n    :param use_general_type:\n    :return: (atoms, bonds, parmed_structure)\n    \"\"\"\n\n    # load if .sdf\n    if Path(filename).suffix.lower() == \".sdf\":\n        warnings.warn(\n            f\"Reading .sdf ({filename}) via RDKit - using only the first conformer. \"\n        )\n        mol = rdkit.Chem.SDMolSupplier(filename, removeHs=False)[0]\n        parmed_structure = pmd_structure_from_rdmol(mol)\n    else:\n        parmed_structure: parmed.Structure = parmed.load_file(\n            str(filename), structure=True\n        )\n        correct_mol2_gaff_atoms(parmed_structure)\n\n    atoms, bonds = get_atoms_bonds_from_pmd_structure(parmed_structure)\n\n    return atoms, bonds, parmed_structure\n</code></pre>"},{"location":"reference/parsing/#ties.parsing.correct_mol2_gaff_atoms","title":"correct_mol2_gaff_atoms","text":"<pre><code>correct_mol2_gaff_atoms(parmed_structure: Structure)\n</code></pre> <p>The mol2 gaff atom types are not understood by Parmed.</p> <p>e.g. \"cl\" are not read as chlorine, but as carbon</p> <p>This functions corrects them by modifying the input structure.</p> Source code in <code>ties/parsing.py</code> <pre><code>def correct_mol2_gaff_atoms(parmed_structure: parmed.Structure):\n    \"\"\"\n    The mol2 gaff atom types are not understood by Parmed.\n\n    e.g. \"cl\" are not read as chlorine, but as carbon\n\n    This functions corrects them by modifying the input structure.\n    \"\"\"\n\n    if not is_gaff_atoms(parmed_structure):\n        return\n\n    for atom in parmed_structure.atoms:\n        element = periodic_table.GetAtomicNumber(gaff_element_map[atom.type.upper()])\n        if element != atom.element:\n            # correct the atomic number\n            atom.element = element\n            # check that it updated the element name\n            assert atom.element_name == gaff_element_map[atom.type.upper()]\n</code></pre>"},{"location":"reference/parsing/#ties.parsing.get_atoms_bonds_from_pmd_structure","title":"get_atoms_bonds_from_pmd_structure","text":"<pre><code>get_atoms_bonds_from_pmd_structure(parmed_structure: Structure)\n</code></pre>"},{"location":"reference/parsing/#ties.parsing.get_atoms_bonds_from_pmd_structure--convert-the-parmed-atoms-into-atom-objects","title":"convert the Parmed atoms into Atom objects.","text":"Source code in <code>ties/parsing.py</code> <pre><code>def get_atoms_bonds_from_pmd_structure(parmed_structure: parmed.Structure):\n    \"\"\"\n    # convert the Parmed atoms into Atom objects.\n    \"\"\"\n    atoms = []\n    for parmed_atom in parmed_structure.atoms:\n        atom_type = parmed_atom.type\n\n        if not atom_type:\n            # extract the element symbol from the atomic number\n            atom_type = periodic_table.GetElementSymbol(parmed_atom.atomic_number)\n\n        # atom type might be empty if\n        if not atom_type:\n            # use the atom name as the atom type, e.g. C7\n            atom_type = parmed_atom.name\n\n        try:\n            atom = Atom(\n                name=parmed_atom.name,\n                atom_type=atom_type,\n                charge=parmed_atom.charge,\n            )\n        except AttributeError:\n            # most likely the charges were missing, manually set the charges to 0\n            atom = Atom(\n                name=parmed_atom.name,\n                atom_type=atom_type,\n                charge=0.0,\n            )\n            logger.warning(\n                \"One of the input files is missing charges. Setting the charge to 0\"\n            )\n        atom.id = parmed_atom.idx\n        atom.position = [parmed_atom.xx, parmed_atom.xy, parmed_atom.xz]\n        atom.resname = parmed_atom.residue.name\n        atoms.append(atom)\n\n    bonds = [(b.atom1.idx, b.atom2.idx, b.order) for b in parmed_structure.bonds]\n\n    for from_idx, to_idx, bond_type in bonds:\n        atoms[from_idx].bind_to(atoms[to_idx], bond_type)\n\n    # verify: the ids and the order in the list is the same\n    for i, atom in enumerate(atoms):\n        assert i == atom.id\n\n    return atoms, bonds\n</code></pre>"},{"location":"reference/parsing/#ties.parsing.do_atom_names_have_simple_format","title":"do_atom_names_have_simple_format","text":"<pre><code>do_atom_names_have_simple_format(names)\n</code></pre> <p>Check if the atom name is followed by a number, e.g. \"C15\" Note that the full atom name cannot be more than 4 characters. This is because the PDB format does not allow for more characters which can lead to inconsistencies.</p> <p>:param names: a list of atom names :type names: list[str] :return True if they all follow the correct format.</p> Source code in <code>ties/parsing.py</code> <pre><code>def do_atom_names_have_simple_format(names):\n    \"\"\"\n    Check if the atom name is followed by a number, e.g. \"C15\"\n    Note that the full atom name cannot be more than 4 characters.\n    This is because the PDB format does not allow for more\n    characters which can lead to inconsistencies.\n\n    :param names: a list of atom names\n    :type names: list[str]\n    :return True if they all follow the correct format.\n    \"\"\"\n    for name in names:\n        # cannot exceed 4 characters\n        if len(name) &gt; 4:\n            return False\n\n        # count letters before any digit\n        letter_count = 0\n        for letter in name:\n            if not letter.isalpha():\n                break\n\n            letter_count += 1\n\n        # at least one character\n        if letter_count == 0:\n            return False\n\n        # extrac the number suffix\n        atom_number = name[letter_count:]\n        try:\n            int(atom_number)\n        except Exception:\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/protein/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> protein","text":""},{"location":"reference/protein/#ties.protein","title":"protein","text":"<p>Classes:</p> <ul> <li> <code>Protein</code>           \u2013            <p>A helper tool for the protein file. It calculates the number of ions needed to neutralise it</p> </li> </ul>"},{"location":"reference/protein/#ties.protein.Protein","title":"Protein","text":"<pre><code>Protein(filename=None, config=None)\n</code></pre> <p>A helper tool for the protein file. It calculates the number of ions needed to neutralise it (using ambertools for now).</p> <p>:param filename: filepath to the protein :type filename: string :param config: Optional configuration for the protein :type config: :class:<code>Config</code></p> <p>Methods:</p> <ul> <li> <code>get_path</code>             \u2013              <p>Get a path to the protein.</p> </li> </ul> Source code in <code>ties/protein.py</code> <pre><code>def __init__(self, filename=None, config=None):\n    if filename is None and config is None:\n        raise Exception(\n            \"Protein filename is not passed and the config file is missing. \"\n        )\n\n    self.config = Config() if config is None else config\n\n    if filename is None:\n        if config.protein is None:\n            raise Exception(\"Could not find the protein in the config object. \")\n        self.file = config.protein\n    elif filename is not None:\n        self.file = filename\n        # update the config\n        config.protein = filename\n\n    # fixme - check if the file exists at this point, throw an exception otherwise\n\n    # calculate the charges of the protein (using ambertools)\n    # fixme - turn this into a method? stage2: use propka or some other tool, not this workaround\n    self.protein_net_charge = ties.generator.get_protein_net_charge(\n        config.workdir,\n        config.protein.absolute(),\n        config.ambertools_tleap,\n        config.tleap_check_protein,\n        config.protein_ff,\n    )\n\n    logger.info(f\"Protein net charge: {self.protein_net_charge}\")\n</code></pre>"},{"location":"reference/protein/#ties.protein.Protein.get_path","title":"get_path","text":"<pre><code>get_path()\n</code></pre> <p>Get a path to the protein.</p> <p>:return: the protein filename :rtype: string</p> Source code in <code>ties/protein.py</code> <pre><code>def get_path(self):\n    \"\"\"\n    Get a path to the protein.\n\n    :return: the protein filename\n    :rtype: string\n    \"\"\"\n    return self.file\n</code></pre>"},{"location":"reference/topology_superimposer/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> topology_superimposer","text":""},{"location":"reference/topology_superimposer/#ties.topology_superimposer","title":"topology_superimposer","text":"<p>The main module responsible for the superimposition.</p> <p>Classes:</p> <ul> <li> <code>AtomPair</code>           \u2013            <p>An atom pair for networkx.</p> </li> <li> <code>SuperimposedTopology</code>           \u2013            <p>SuperimposedTopology contains in the minimal case two sets of nodes S1 and S2, which</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_largest</code>             \u2013              <p>return a list of largest solutions</p> </li> <li> <code>long_merge</code>             \u2013              <p>Carry out a merge and apply all checks.</p> </li> <li> <code>merge_compatible_suptops</code>             \u2013              <p>Imagine mapping of two carbons C1 and C2 to another pair of carbons C1' and C2'.</p> </li> <li> <code>superimpose_topologies</code>             \u2013              <p>The main function that manages the entire process.</p> </li> <li> <code>is_mirror_of_one</code>             \u2013              <p>\"Mirror\" in the sense that it is an alternative topological way to traverse the molecule.</p> </li> <li> <code>generate_nxg_from_list</code>             \u2013              <p>Helper function. Generates a graph from a list of atoms</p> </li> <li> <code>get_starting_configurations</code>             \u2013              <p>Minimise the number of starting configurations to optimise the process speed.</p> </li> <li> <code>get_atoms_bonds_from_file</code>             \u2013              <p>Use Parmed to load the files.</p> </li> <li> <code>assign_coords_from_pdb</code>             \u2013              <p>Match the atoms from the ParmEd object based on a .pdb file</p> </li> </ul>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.AtomPair","title":"AtomPair","text":"<pre><code>AtomPair(left_node, right_node)\n</code></pre> <p>An atom pair for networkx.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def __init__(self, left_node, right_node):\n    self.left_atom = left_node\n    self.right_atom = right_node\n    # generate the hash value for this match\n    self.hash_value = self._gen_hash()\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology","title":"SuperimposedTopology","text":"<pre><code>SuperimposedTopology(topology1=None, topology2=None, parmed_ligA=None, parmed_ligZ=None)\n</code></pre> <p>SuperimposedTopology contains in the minimal case two sets of nodes S1 and S2, which are paired together and represent a strongly connected component.</p> <p>However, it can also represent the symmetrical versions that were superimposed.</p> <p>Methods:</p> <ul> <li> <code>mcs_score</code>             \u2013              <p>Raturn a ratio of the superimposed atoms to the number of all atoms.</p> </li> <li> <code>write_metadata</code>             \u2013              <p>Writes a .json file with a summary of which atoms are classified as appearing, disappearing</p> </li> <li> <code>write_pdb</code>             \u2013              <p>param filename: name or a filepath of the new file. If None, standard preconfigured pattern will be used.</p> </li> <li> <code>write_mol2</code>             \u2013              <p>param filename: str location where the .mol2 file should be saved.</p> </li> <li> <code>get_single_topology_region</code>             \u2013              <p>Return: matched atoms (even if they were unmatched for any reason)</p> </li> <li> <code>get_single_topology_app</code>             \u2013              <p>fixme - called app but gives both app and dis</p> </li> <li> <code>ringring</code>             \u2013              <p>Rings can only be matched to rings.</p> </li> <li> <code>is_or_was_matched</code>             \u2013              <p>A helper function. For whatever reasons atoms get discarded.</p> </li> <li> <code>get_unmatched_atoms</code>             \u2013              <p>Find the atoms in both topologies which were unmatched and return them.</p> </li> <li> <code>get_unique_atom_count</code>             \u2013              <p>Requires that the .assign_atoms_ids() was called.</p> </li> <li> <code>align_ligands_using_mcs</code>             \u2013              <p>Align the two ligands using the MCS (Maximum Common Substructure).</p> </li> <li> <code>alchemical_overlap_check</code>             \u2013              <p>Calculate how well the alchemical regions overlap using distances between them.</p> </li> <li> <code>rm_matched_pairs_with_different_bonds</code>             \u2013              <p>Scan the matched pairs. Assume you have three pairs</p> </li> <li> <code>get_dual_topology_bonds</code>             \u2013              <p>Get the bonds between all the atoms.</p> </li> <li> <code>largest_cc_survives</code>             \u2013              <p>CC - Connected Component.</p> </li> <li> <code>assign_atoms_ids</code>             \u2013              <p>Assign an ID to each pair A1-B1. This means that if we request an atom ID</p> </li> <li> <code>get_appearing_atoms</code>             \u2013              </li> <li> <code>get_disappearing_atoms</code>             \u2013              </li> <li> <code>remove_lonely_hydrogens</code>             \u2013              <p>You could also remove the hydrogens when you correct charges.</p> </li> <li> <code>match_gaff2_nondirectional_bonds</code>             \u2013              <p>If needed, swap cc-cd with cd-cc.</p> </li> <li> <code>get_net_charge</code>             \u2013              <p>Calculate the net charge difference across</p> </li> <li> <code>get_matched_with_diff_q</code>             \u2013              <p>Returns a list of matched atom pairs that have a different q,</p> </li> <li> <code>apply_net_charge_filter</code>             \u2013              <p>Averaging the charges across paired atoms introduced inequalities.</p> </li> <li> <code>remove_attached_hydrogens</code>             \u2013              <p>The node_pair to which these hydrogens are attached was removed.</p> </li> <li> <code>find_lowest_rmsd_mirror</code>             \u2013              <p>Walk through the different mirrors and out of all options select the one</p> </li> <li> <code>is_subgraph_of_global_top</code>             \u2013              <p>Check if after superimposition, one graph is a subgraph of another</p> </li> <li> <code>rmsd</code>             \u2013              <p>For each pair take the distance, and then get rmsd, so root(mean(square(deviation)))</p> </li> <li> <code>link_pairs</code>             \u2013              <p>This helps take care of the bonds.</p> </li> <li> <code>find_mirror_choices</code>             \u2013              <p>For each pair (A1, B1) find all the other options in the mirrors where (A1, B2)</p> </li> <li> <code>add_alternative_mapping</code>             \u2013              <p>This means that there is another way to traverse and overlap the two molecules,</p> </li> <li> <code>correct_for_coordinates</code>             \u2013              <p>Use the coordinates of the atoms, to figure out which symmetries are the correct ones.</p> </li> <li> <code>is_area_overlapping_fully</code>             \u2013              <p>Each atom in one set has to be matched to an atom in the second set. And vice versa.</p> </li> <li> <code>is_area_overlapping</code>             \u2013              <p>Even a small overlap will return True.</p> </li> <li> <code>enforce_no_partial_rings</code>             \u2013              <p>Ensure that rings are either fully matched,</p> </li> <li> <code>get_topology_similarity_score</code>             \u2013              <p>Having the superimposed A(Left) and B(Right), score the match.</p> </li> <li> <code>unmatch_pairs_with_different_charges</code>             \u2013              <p>Removes the matched pairs where atom charges are more different</p> </li> <li> <code>is_consistent_with</code>             \u2013              <p>Conditions:</p> </li> <li> <code>get_circles</code>             \u2013              <p>Return circles found in the matched pairs.</p> </li> <li> <code>get_original_circles</code>             \u2013              <p>Return the original circles present in the input topologies.</p> </li> <li> <code>cycle_spans_multiple_cycles</code>             \u2013              <p>What is the circle is shared?</p> </li> <li> <code>merge</code>             \u2013              <p>Absorb the other suptop by adding all the node pairs that are not present</p> </li> <li> <code>validate_charges</code>             \u2013              <p>Check the original charges:</p> </li> <li> <code>redistribute_charges</code>             \u2013              <p>After the match is made and the user commits to the superimposed topology,</p> </li> <li> <code>contains_same_atoms_symmetric</code>             \u2013              <p>The atoms can be paired differently, but they are the same.</p> </li> <li> <code>is_subgraph_of</code>             \u2013              <p>Checks if this superimposed topology is a subgraph of another superimposed topology.</p> </li> <li> <code>subgraph_relationship</code>             \u2013              <p>Return</p> </li> <li> <code>is_mirror_of</code>             \u2013              <p>this is a naive check</p> </li> <li> <code>eq</code>             \u2013              <p>Check if the superimposed topology is \"the same\". This means that every pair has a corresponding pair in the</p> </li> <li> <code>toJSON</code>             \u2013              <p>\"</p> </li> </ul> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def __init__(\n    self, topology1=None, topology2=None, parmed_ligA=None, parmed_ligZ=None\n):\n    self.set_parmeds(parmed_ligA, parmed_ligZ)\n\n    \"\"\"\n    @superimposed_nodes : a set of pairs of nodes that matched together\n    \"\"\"\n    matched_pairs = []\n\n    # TEST: with the list of matching nodes, check if each node was used only once,\n    # the number of unique nodes should be equivalent to 2*len(common_pairs)\n    all_matched_nodes = []\n    [all_matched_nodes.extend(list(pair)) for pair in matched_pairs]\n    assert len(matched_pairs) * 2 == len(all_matched_nodes)\n\n    # fixme don't allow for initiating with matching pairs, it's not used anyway\n\n    # todo convert to nx? some other graph theory package?\n    matched_pairs.sort(key=lambda pair: pair[0].name)\n    self.matched_pairs = matched_pairs\n    self.top1 = topology1\n    self.top2 = topology2\n    # create graph representation for both in networkx library, initially to track the number of cycles\n    # fixme\n\n    self.mirrors = []\n    self.alternative_mappings = []\n    # this is a set of all nodes rather than their pairs\n    self.nodes = set(all_matched_nodes)\n    self.nodes_added_log = []\n\n    self.internal_ids = None\n    self.unique_atom_count = 0\n    self.matched_pairs_bonds = {}\n\n    # options\n    # Ambertools ignores the bonds when creating the .prmtop from the hybrid.mol2 file,\n    # so for now we can ignore the bond types\n    self.ignore_bond_types = True\n\n    # removed because\n    # fixme - make this into a list\n    self._removed_pairs_with_charge_difference = []  # atom-atom charge decided by qtol\n    self._removed_because_disjointed_cc = []  # disjointed segment\n    self._removed_due_to_net_charge = []\n    self._removed_because_unmatched_rings = []\n    self._removed_because_diff_bonds = []  # the atoms pair uses a different bond\n\n    # save the cycles in the left and right molecules\n    if self.top1 is not None and self.top2 is not None:\n        self._init_nonoverlapping_cycles()\n\n    self.id = SuperimposedTopology.COUNTER\n    SuperimposedTopology.COUNTER += 1\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique","title":"fixme - should check first if atomName is unique","text":""},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique","title":"fixme - should check first if atomName is unique","text":""},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.mcs_score","title":"mcs_score","text":"<pre><code>mcs_score()\n</code></pre> <p>Raturn a ratio of the superimposed atoms to the number of all atoms. Specifically, (superimposed_atoms_number * 2) / (atoms_number_ligandA + atoms_number_ligandB) :return:</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def mcs_score(self):\n    \"\"\"\n    Raturn a ratio of the superimposed atoms to the number of all atoms.\n    Specifically, (superimposed_atoms_number * 2) / (atoms_number_ligandA + atoms_number_ligandB)\n    :return:\n    \"\"\"\n    return (len(self.matched_pairs) * 2) / (len(self.top1) + len(self.top2))\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.write_metadata","title":"write_metadata","text":"<pre><code>write_metadata(filename=None)\n</code></pre> <p>Writes a .json file with a summary of which atoms are classified as appearing, disappearing as well as all other metadata relevant to this superimposition/hybrid. TODO add information:  - config class in general  -- relative paths to ligand 1, ligand 2 (the latest copies, ie renamed etc)  -- general settings used  - pair? bonds? these can be restractured, so not necessary?</p> <pre><code>param filename: a location where the metadata should be saved\n</code></pre> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def write_metadata(self, filename=None):\n    \"\"\"\n    Writes a .json file with a summary of which atoms are classified as appearing, disappearing\n    as well as all other metadata relevant to this superimposition/hybrid.\n    TODO add information:\n     - config class in general\n     -- relative paths to ligand 1, ligand 2 (the latest copies, ie renamed etc)\n     -- general settings used\n     - pair? bonds? these can be restractured, so not necessary?\n\n        param filename: a location where the metadata should be saved\n    \"\"\"\n\n    # store at the root for now\n    # fixme - should either be created or generated API\n    if filename is None:\n        matching_json = (\n            self.config.workdir\n            / f\"meta_{self.morph.ligA.internal_name}_{self.morph.ligB.internal_name}.json\"\n        )\n    else:\n        matching_json = pathlib.Path(filename)\n\n    matching_json.parent.mkdir(parents=True, exist_ok=True)\n\n    json.dump(self.toJSON(), open(matching_json, \"w\"))\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.write_pdb","title":"write_pdb","text":"<pre><code>write_pdb(filename=None)\n</code></pre> <p>param filename: name or a filepath of the new file. If None, standard preconfigured pattern will be used.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def write_pdb(self, filename=None):\n    \"\"\"\n    param filename: name or a filepath of the new file. If None, standard preconfigured pattern will be used.\n    \"\"\"\n    if filename is None:\n        morph_pdb_path = (\n            self.config.workdir\n            / f\"{self.morph.ligA.internal_name}_{self.morph.ligB.internal_name}_morph.pdb\"\n        )\n    else:\n        morph_pdb_path = filename\n\n    # def write_morph_top_pdb(filepath, mda_l1, mda_l2, suptop, hybrid_single_dual_top=False):\n    if self.config.use_hybrid_single_dual_top:\n        # the NAMD hybrid single dual topology\n        # rename the ligand on the left to INI\n        # and the ligand on the right to END\n\n        # first, set all the matched pairs to -2 and 2 (single topology)\n        # regardless of how they were mismatched\n        raise NotImplementedError(\n            \"Cannot yet write hybrid single dual topology .pdb file\"\n        )\n\n        # then, set the different atoms to -1 and 1 (dual topology)\n\n        # save in a single PDB file\n        # Note that the atoms from left to right\n        # in the single topology region have to\n        # be separated by the same number\n        # fixme - make a check for that\n        return\n    # fixme - find another library that can handle writing to a PDB file, MDAnalysis\n    # save the ligand with all the appropriate atomic positions, write it using the pdb format\n    # pdb file format: http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM\n    # write a dual .pdb file\n    with open(morph_pdb_path, \"w\") as FOUT:\n        for atom in self.parmed_ligA.atoms:\n            \"\"\"\n            There is only one forcefield which is shared across the two topologies.\n            Basically, we need to check whether the atom is in both topologies.\n            If that is the case, then the atom should have the same name, and therefore appear only once.\n            However, if there is a new atom, it should be specfically be outlined\n            that it is 1) new and 2) the right type\n            \"\"\"\n            # write all the atoms if they are matched, that's the common part\n            # note that ParmEd does not have the information on a residue ID\n            REMAINS = 0\n            if self.contains_left_atom(atom.idx):\n                line = (\n                    f\"ATOM  {atom.idx:&gt;5d} {atom.name:&gt;4s} {atom.residue.name:&gt;3s}  \"\n                    f\"{1:&gt;4d}    \"\n                    f\"{atom.xx:&gt;8.3f}{atom.xy:&gt;8.3f}{atom.xz:&gt;8.3f}\"\n                    f\"{1.0:&gt;6.2f}{REMAINS:&gt;6.2f}\" + (\" \" * 11) + \"  \" + \"  \" + \"\\n\"\n                )\n                FOUT.write(line)\n            else:\n                # this atom was not found, this means it disappears, so we should update the\n                DISAPPEARING_ATOM = -1.0\n                line = (\n                    f\"ATOM  {atom.idx:&gt;5d} {atom.name:&gt;4s} {atom.residue.name:&gt;3s}  \"\n                    f\"{1:&gt;4d}    \"\n                    f\"{atom.xx:&gt;8.3f}{atom.xy:&gt;8.3f}{atom.xz:&gt;8.3f}\"\n                    f\"{1.0:&gt;6.2f}{DISAPPEARING_ATOM:&gt;6.2f}\"\n                    + (\" \" * 11)\n                    + \"  \"\n                    + \"  \"\n                    + \"\\n\"\n                )\n                FOUT.write(line)\n        # add atoms from the right topology,\n        # which are going to be created\n        for atom in self.parmed_ligZ.atoms:\n            if not self.contains_right_atom(atom.idx):\n                APPEARING_ATOM = 1.0\n                line = (\n                    f\"ATOM  {atom.idx:&gt;5d} {atom.name:&gt;4s} {atom.residue.name:&gt;3s}  \"\n                    f\"{1:&gt;4d}    \"\n                    f\"{atom.xx:&gt;8.3f}{atom.xy:&gt;8.3f}{atom.xz:&gt;8.3f}\"\n                    f\"{1.0:&gt;6.2f}{APPEARING_ATOM:&gt;6.2f}\"\n                    + (\" \" * 11)\n                    + \"  \"\n                    + \"  \"\n                    + \"\\n\"\n                )\n                FOUT.write(line)\n    self.pdb = morph_pdb_path\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.write_mol2","title":"write_mol2","text":"<pre><code>write_mol2(filename=None, use_left_charges=True, use_left_coords=True)\n</code></pre> <p>param filename: str location where the .mol2 file should be saved.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def write_mol2(self, filename=None, use_left_charges=True, use_left_coords=True):\n    \"\"\"\n    param filename: str location where the .mol2 file should be saved.\n    \"\"\"\n    if filename is None:\n        hybrid_mol2 = (\n            self.config.workdir\n            / f\"{self.morph.ligA.internal_name}_{self.morph.ligB.internal_name}_morph.mol2\"\n        )\n    else:\n        hybrid_mol2 = filename\n\n    # fixme - make this as a method of suptop as well\n    # recreate the mol2 file that is merged and contains the correct atoms from both\n    # mol2 format: http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/mol2.pdf\n    # fixme - build this molecule using the MDAnalysis builder instead of the current approach\n    # however, MDAnalysis currently cannot convert pdb into mol2? ...\n    # where the formatting is done manually\n    with open(hybrid_mol2, \"w\") as FOUT:\n        bonds = self.get_dual_topology_bonds()\n\n        FOUT.write(\"@&lt;TRIPOS&gt;MOLECULE \" + os.linesep)\n        # name of the molecule\n        FOUT.write(\"HYB \" + os.linesep)\n        # num_atoms [num_bonds [num_subst [num_feat [num_sets]]]]\n        # fixme this is tricky\n        FOUT.write(f\"{self.get_unique_atom_count():d} {len(bonds):d}\" + os.linesep)\n        # mole type\n        FOUT.write(\"SMALL \" + os.linesep)\n        # charge_type\n        FOUT.write(\"NO_CHARGES \" + os.linesep)\n        FOUT.write(os.linesep)\n\n        # write the atoms\n        FOUT.write(\"@&lt;TRIPOS&gt;ATOM \" + os.linesep)\n        # atom_id atom_name x y z atom_type [subst_id [subst_name [charge [status_bit]]]]\n        # e.g.\n        #       1 O4           3.6010   -50.1310     7.2170 o          1 L39      -0.815300\n\n        # so from the two topologies all the atoms are needed and they need to have a different atom_id\n        # so we might need to name the atom_id for them, other details are however pretty much the same\n        # the importance of atom_name is difficult to estimate\n\n        # we are going to assign IDs in the superimposed topology in order to track which atoms have IDs\n        # and which don't\n\n        # fixme - for writing, modify things to achieve the desired output\n        # note - we are modifying in place our atoms\n        for left, right in self.matched_pairs:\n            logger.debug(\n                f\"Aligned {left.original_name} id {left.id} with {right.original_name} id {right.id}\"\n            )\n            if not use_left_charges:\n                left.charge = right.charge\n            if not use_left_coords:\n                left.position = right.position\n\n        subst_id = 1  # resid basically\n        # write all the atoms that were matched first with their IDs\n        # prepare all the atoms, note that we use primarily the left ligand naming\n        all_atoms = [\n            left for left, right in self.matched_pairs\n        ] + self.get_unmatched_atoms()\n\n        # reorder the list according to the ID\n        all_atoms.sort(key=lambda atom: self.get_generated_atom_id(atom))\n\n        resname = \"HYB\"\n        for atom in all_atoms:\n            FOUT.write(\n                f\"{self.get_generated_atom_id(atom)} {atom.name} \"\n                f\"{atom.position[0]:.4f} {atom.position[1]:.4f} {atom.position[2]:.4f} \"\n                f\"{atom.type.lower()} {subst_id} {resname} {atom.charge:.6f} {os.linesep}\"\n            )\n\n        FOUT.write(os.linesep)\n\n        # write bonds\n        FOUT.write(\"@&lt;TRIPOS&gt;BOND \" + os.linesep)\n\n        # we have to list every bond:\n        # 1) all the bonds between the paired atoms, so that part is easy\n        # 2) bonds which link the disappearing atoms, and their connection to the paired atoms\n        # 3) bonds which link the appearing atoms, and their connections to the paired atoms\n\n        bond_counter = 1\n        list(bonds)\n        for bond_from_id, bond_to_id, bond_type in sorted(\n            list(bonds), key=lambda b: b[:2]\n        ):\n            # Bond Line Format:\n            # bond_id origin_atom_id target_atom_id bond_type [status_bits]\n            FOUT.write(\n                f\"{bond_counter} {bond_from_id} {bond_to_id} {bond_type}\"\n                + os.linesep\n            )\n            bond_counter += 1\n\n    self.mol2 = hybrid_mol2\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_single_topology_region","title":"get_single_topology_region","text":"<pre><code>get_single_topology_region()\n</code></pre> <p>Return: matched atoms (even if they were unmatched for any reason)</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_single_topology_region(self):\n    \"\"\"\n    Return: matched atoms (even if they were unmatched for any reason)\n    \"\"\"\n    # strip the pairs of the exact information about the charge differences\n    removed_pairs_with_charge_difference = [\n        (n1, n2) for (n1, n2), q_diff in self._removed_pairs_with_charge_difference\n    ]\n\n    # fixme: this should not work with disjointed cc and others?\n    unpaired = (\n        self._removed_because_disjointed_cc\n        + self._removed_due_to_net_charge\n        + removed_pairs_with_charge_difference\n    )\n\n    return self.matched_pairs + unpaired\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_single_topology_app","title":"get_single_topology_app","text":"<pre><code>get_single_topology_app()\n</code></pre> <p>fixme - called app but gives both app and dis get the appearing and disappearing region in the hybrid single topology use the single topology region and classify all other atoms not in it as either appearing or disappearing</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_single_topology_app(self):\n    \"\"\"\n    fixme - called app but gives both app and dis\n    get the appearing and disappearing region in the hybrid single topology\n    use the single topology region and classify all other atoms not in it\n    as either appearing or disappearing\n    \"\"\"\n    single_top_area = self.get_single_topology_region()\n\n    # turn it into a set\n    single_top_set = set()\n    for left, right in single_top_area:\n        single_top_set.add(left)\n        single_top_set.add(right)\n\n    # these unmatched atoms could be due to charge etc.\n    # so they historically refer to the dual-topology\n    unmatched_app = self.get_appearing_atoms()\n    app = {a for a in unmatched_app if a not in single_top_set}\n    unmatched_dis = self.get_disappearing_atoms()\n    dis = {a for a in unmatched_dis if a not in single_top_set}\n\n    return app, dis\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.ringring","title":"ringring","text":"<pre><code>ringring()\n</code></pre> <p>Rings can only be matched to rings.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def ringring(self):\n    \"\"\"\n    Rings can only be matched to rings.\n    \"\"\"\n    l_circles, r_circles = self.get_original_circles()\n    removed_h = []\n    ringring_removed = []\n    for left, right in self.matched_pairs[::-1]:\n        if (left, right) in removed_h:\n            continue\n\n        l_ring = any([left in c for c in l_circles])\n        r_ring = any([right in c for c in r_circles])\n        if l_ring + r_ring == 1:\n            removed_h.extend(self.remove_attached_hydrogens((left, right)))\n            self.remove_node_pair((left, right))\n            ringring_removed.append((left, right))\n\n    if ringring_removed:\n        logger.debug(\n            f\"(ST{self.id}) Ring only matches ring filter, removed: {ringring_removed} with hydrogens {removed_h}\"\n        )\n    return ringring_removed, removed_h\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.is_or_was_matched","title":"is_or_was_matched","text":"<pre><code>is_or_was_matched(atom_name1, atom_name2)\n</code></pre> <p>A helper function. For whatever reasons atoms get discarded. E.g. they had a different charge, or were part of the disjointed component, etc. This function simply checks if the most original match was made between the two atoms. It helps with verifying the original matching.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_or_was_matched(self, atom_name1, atom_name2):\n    \"\"\"\n    A helper function. For whatever reasons atoms get discarded.\n    E.g. they had a different charge, or were part of the disjointed component, etc.\n    This function simply checks if the most original match was made between the two atoms.\n    It helps with verifying the original matching.\n    \"\"\"\n    if self.contains_atom_name_pair(atom_name1, atom_name2):\n        return True\n\n    # check if it was unmatched\n    unmatched_lists = [\n        self._removed_because_disjointed_cc,\n        # ignore the charges in this list\n        [pair for pair, q in self._removed_due_to_net_charge],\n        [pair for pair, q in self._removed_pairs_with_charge_difference],\n    ]\n    for unmatched_list in unmatched_lists:\n        for atom1, atom2 in unmatched_list:\n            if atom1.name == atom_name1 and atom2.name == atom_name2:\n                return True\n\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_unmatched_atoms","title":"get_unmatched_atoms","text":"<pre><code>get_unmatched_atoms()\n</code></pre> <p>Find the atoms in both topologies which were unmatched and return them. These are both, appearing and disappearing.</p> <p>Note that some atoms were removed due to charges.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_unmatched_atoms(self):\n    \"\"\"\n    Find the atoms in both topologies which were unmatched and return them.\n    These are both, appearing and disappearing.\n\n    Note that some atoms were removed due to charges.\n    \"\"\"\n    unmatched_atoms = []\n    for node in self.top1:\n        if not self.contains_node(node):\n            unmatched_atoms.append(node)\n\n    for node in self.top2:\n        if not self.contains_node(node):\n            unmatched_atoms.append(node)\n\n    return unmatched_atoms\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_unique_atom_count","title":"get_unique_atom_count","text":"<pre><code>get_unique_atom_count()\n</code></pre> <p>Requires that the .assign_atoms_ids() was called. This should be rewritten. But basically, it needs to count each matched pair as one atom, and the appearing and disappearing atoms separately.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_unique_atom_count(self):\n    \"\"\"\n    Requires that the .assign_atoms_ids() was called.\n    This should be rewritten. But basically, it needs to count each matched pair as one atom,\n    and the appearing and disappearing atoms separately.\n    \"\"\"\n    return self.unique_atom_count\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.align_ligands_using_mcs","title":"align_ligands_using_mcs","text":"<pre><code>align_ligands_using_mcs(overwrite_original=False, use_disjointed=False)\n</code></pre> <p>Align the two ligands using the MCS (Maximum Common Substructure). The ligA here is the reference (docked) to which the ligZ is aligned.</p> <p>:param overwrite_original: After aligning by MCS, update the internal coordinates     which will be saved to a file at the end. :type overwrite_original: bool</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def align_ligands_using_mcs(self, overwrite_original=False, use_disjointed=False):\n    \"\"\"\n    Align the two ligands using the MCS (Maximum Common Substructure).\n    The ligA here is the reference (docked) to which the ligZ is aligned.\n\n    :param overwrite_original: After aligning by MCS, update the internal coordinates\n        which will be saved to a file at the end.\n    :type overwrite_original: bool\n    \"\"\"\n\n    if self.mda_ligA is None or self.mda_ligB is None:\n        # todo comment\n        return self.rmsd()\n\n    ligA = self.mda_ligA\n    ligB = self.mda_ligB\n\n    # back up\n    ligA_original_positions = ligA.atoms.positions[:]\n    ligB_original_positions = ligB.atoms.positions[:]\n\n    left_disjointed_cc = []\n    right_disjointed_cc = []\n\n    if use_disjointed and self._removed_because_disjointed_cc:\n        left_disjointed_cc = [\n            left.id for left, _ in self._removed_because_disjointed_cc\n        ]\n        right_disjointed_cc = [\n            right.id for _, right in self._removed_because_disjointed_cc\n        ]\n\n    # select the atoms for the MCS,\n    # the following uses 0-based indexing\n    mcs_ligA_ids = [\n        left.id for left, right in self.matched_pairs\n    ] + left_disjointed_cc\n    mcs_ligB_ids = [\n        right.id for left, right in self.matched_pairs\n    ] + right_disjointed_cc\n\n    ligA_fragment = ligA.atoms[mcs_ligA_ids]\n    ligB_fragment = ligB.atoms[mcs_ligB_ids]\n\n    # move all to the origin of the fragment\n    ligA_mcs_centre = ligA_fragment.centroid()\n    ligA.atoms.translate(-ligA_mcs_centre)\n    ligB.atoms.translate(-ligB_fragment.centroid())\n\n    rotation_matrix, rmsd = MDAnalysis.analysis.align.rotation_matrix(\n        ligB_fragment.positions, ligA_fragment.positions\n    )\n\n    # apply the rotation to\n    ligB.atoms.rotate(rotation_matrix)\n    # move back to ligA\n    ligB.atoms.translate(ligA_mcs_centre)\n\n    # save the superimposed coordinates\n    ligB_sup = self.mda_ligB.atoms.positions[:]\n\n    # restore the MDAnalysis positions (\"working copy\")\n    # in theory you do not need to do this every time\n    self.mda_ligA.atoms.positions = ligA_original_positions\n    self.mda_ligB.atoms.positions = ligB_original_positions\n\n    if not overwrite_original:\n        # return the RMSD of the superimposed matched pairs only\n        return rmsd\n\n    # use the aligned coordinates\n    self.parmed_ligZ.coordinates = ligB_sup\n\n    # ideally this would now be done with MDAnalysis which can now write .mol2\n    # overwrite the internal atom positions with the final generated alignment\n    for parmed_atom in self.parmed_ligZ.atoms:\n        found = False\n        for atom in self.top2:\n            if parmed_atom.idx == atom.id:\n                atom.position = parmed_atom.xx, parmed_atom.xy, parmed_atom.xz\n                found = True\n                break\n        assert found\n\n    return rmsd\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.alchemical_overlap_check","title":"alchemical_overlap_check","text":"<pre><code>alchemical_overlap_check() -&gt; tuple[float]\n</code></pre> <p>Calculate how well the alchemical regions overlap using distances between them.</p> <p>For A (left) and B (right). For each atom in B, find the distance to closest alchemical atom in A to get B-A distances. Then apply RMS(B-A).</p> <p>Do the same steps in reverse to get A-B.</p> For B-A <p>0, B and A are the same size.</p> <p>0, B is growing</p> <p>If both, B-A and A-B &gt; 0, this means the alchemical regions are divergent.</p> <p>This function takes the coordinates as they come.</p> <p>:return: RMS(A-B), max(A-B), RMS(B-A), max(B-A)</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def alchemical_overlap_check(self) -&gt; tuple[float]:\n    \"\"\"\n    Calculate how well the alchemical regions overlap using distances between them.\n\n    For A (left) and B (right). For each atom in B,\n    find the distance to closest alchemical atom in A to get B-A distances.\n    Then apply RMS(B-A).\n\n    Do the same steps in reverse to get A-B.\n\n    For B-A:\n        0, B and A are the same size.\n        &gt;0, B is growing\n\n    If both, B-A and A-B &gt; 0, this means the alchemical regions are divergent.\n\n    This function takes the coordinates as they come.\n\n    :return: RMS(A-B), max(A-B), RMS(B-A), max(B-A)\n    \"\"\"\n\n    # alchemical areas\n    B_pos = np.array([a.position for a in self.get_appearing_atoms()])\n    A_pos = np.array([a.position for a in self.get_disappearing_atoms()])\n\n    if not B_pos.size or not A_pos.size:\n        return 0, 0, 0, 0\n\n    # shortest distances from B to any alchemical atom in A\n    # B - A\n    shortest_B_to_A = MDAnalysis.lib.distances.distance_array(B_pos, A_pos).min(\n        axis=1\n    )\n    B_to_A_rmsd = np.sqrt(np.square(shortest_B_to_A).mean())\n\n    # shortest distances from A to any alchemical atom in B\n    # A - B\n    shortest_A_to_B = MDAnalysis.lib.distances.distance_array(A_pos, B_pos).min(\n        axis=1\n    )\n    A_to_B_rmsd = np.sqrt(np.square(shortest_A_to_B).mean())\n\n    return A_to_B_rmsd, max(shortest_A_to_B), B_to_A_rmsd, max(shortest_B_to_A)\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.rm_matched_pairs_with_different_bonds","title":"rm_matched_pairs_with_different_bonds","text":"<pre><code>rm_matched_pairs_with_different_bonds()\n</code></pre> <p>Scan the matched pairs. Assume you have three pairs A-B=C with the double bond on the right side, and the alternative bonds A=B-C remove all A, B and C pairs because of the different bonds Remove them by finding that A-B is not A=B, and B=C is not B-C</p> <p>return: the list of removed pairs</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def rm_matched_pairs_with_different_bonds(self):\n    \"\"\"\n    Scan the matched pairs. Assume you have three pairs\n    A-B=C with the double bond on the right side,\n    and the alternative bonds\n    A=B-C remove all A, B and C pairs because of the different bonds\n    Remove them by finding that A-B is not A=B, and B=C is not B-C\n\n    return: the list of removed pairs\n    \"\"\"\n\n    # extract the bonds for the matched molecules first\n    removed_pairs = []\n    for from_pair, bonded_pair_list in list(self.matched_pairs_bonds.items())[::-1]:\n        for bonded_pair, bond_type in bonded_pair_list:\n            # ignore if this combination was already checked\n            if bonded_pair in removed_pairs and from_pair in removed_pairs:\n                continue\n\n            if bond_type[0] != bond_type[1]:\n                # resolve this, remove the bonded pair from the matched atoms\n                if from_pair not in removed_pairs:\n                    self.remove_node_pair(from_pair)\n                    removed_pairs.append(from_pair)\n                if bonded_pair not in removed_pairs:\n                    self.remove_node_pair(bonded_pair)\n                    removed_pairs.append(bonded_pair)\n\n                # keep the history\n                self._removed_because_diff_bonds.append((from_pair, bonded_pair))\n\n    return removed_pairs\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_dual_topology_bonds","title":"get_dual_topology_bonds","text":"<pre><code>get_dual_topology_bonds()\n</code></pre> <p>Get the bonds between all the atoms. Use the atom IDs for the bonds.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_dual_topology_bonds(self):\n    \"\"\"\n    Get the bonds between all the atoms.\n    Use the atom IDs for the bonds.\n    \"\"\"\n    assert self.top1 is not None and self.top2 is not None\n    # fixme - check if the atoms IDs have been generated\n    assert self.internal_ids is not None\n\n    # extract the bonds for the matched molecules first\n    bonds = set()\n    for from_pair, bonded_pair_list in self.matched_pairs_bonds.items():\n        from_pair_id = self.get_generated_atom_id(from_pair)\n        for bonded_pair, bond_type in bonded_pair_list:\n            if not self.ignore_bond_types:\n                if bond_type[0] != bond_type[1]:\n                    logger.error(\n                        \"ERROR: bond types do not match, even though they apply to the same atoms\"\n                    )\n                    logger.error(\n                        f'ERROR: left bond is \"{bond_type[0]}\" and right bond is \"{bond_type[1]}\"'\n                    )\n                    logger.error(f\"ERROR: the bonded atoms are {bonded_pair}\")\n                    raise Exception(\n                        \"The bond types do not correspond to each other\"\n                    )\n            # every bonded pair has to be in the topology\n            assert bonded_pair in self.matched_pairs\n            to_pair_id = self.get_generated_atom_id(bonded_pair)\n            # before adding them to bonds, check if they are not already there\n            bond_sorted = sorted([from_pair_id, to_pair_id])\n            bond_sorted.append(bond_type[0])\n            bonds.add(tuple(bond_sorted))\n\n    # extract the bond information from the unmatched\n    unmatched_atoms = self.get_unmatched_atoms()\n    # for every atom, check to which \"pair\" the bond connects,\n    # and use that pair's ID to make the link\n\n    # several iterations of walking through the atoms,\n    # this is to ensure that we remove each atom one by one\n    # e.g. imagine this PAIR-SingleA1-SingleA2-SingleA3\n    # so only the first SingleA1 is connected to a pair,\n    # so the first iteration would take care of that,\n    # the next iteration would connect SingleA2 to SingleA1, etc\n    # first, remove the atoms that are connected to pairs\n    for atom in unmatched_atoms:\n        for bond in atom.bonds:\n            unmatched_atom_id = self.get_generated_atom_id(atom)\n            # check if the unmatched atom is bonded to any pair\n            pair = self.find_pair_with_atom(bond.atom)\n            if pair is not None:\n                # this atom is bound to a pair, so add the bond to the pair\n                pair_id = self.get_generated_atom_id(pair[0])\n                # add the bond between the atom and the pair\n                bond_sorted = sorted([unmatched_atom_id, pair_id])\n                bond_sorted.append(bond.type)\n                bonds.add(tuple(bond_sorted))\n            else:\n                # it is not directly linked to a matched pair,\n                # simply add this missing bond to whatever atom it is bound\n                another_unmatched_atom_id = self.get_generated_atom_id(bond.atom)\n                bond_sorted = sorted([unmatched_atom_id, another_unmatched_atom_id])\n                bond_sorted.append(bond.type)\n                bonds.add(tuple(bond_sorted))\n\n    # fixme - what about circles etc? these bonds\n    # that form circles should probably be added while checking if the circles make sense etc\n    # also, rather than checking if it is a circle, we could check if the new linked atom,\n    # is in a pair to which the new pair refers (the same rule that is used currently)\n    return bonds\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.largest_cc_survives","title":"largest_cc_survives","text":"<pre><code>largest_cc_survives(verbose=True)\n</code></pre> <p>CC - Connected Component.</p> <p>Removes any disjoint components. Only the largest CC will be left. In the case of of equal length CCs, an arbitrary is chosen.</p> <p>How: Generates the graph where each pair is a single node, connecting the nodes if the bonds exist. Uses then networkx to find CCs.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def largest_cc_survives(self, verbose=True):\n    \"\"\"\n    CC - Connected Component.\n\n    Removes any disjoint components. Only the largest CC will be left.\n    In the case of of equal length CCs, an arbitrary is chosen.\n\n    How:\n    Generates the graph where each pair is a single node, connecting the nodes if the bonds exist.\n    Uses then networkx to find CCs.\n    \"\"\"\n\n    if len(self) == 0:\n        return self, []\n\n    def lookup_up(pairs, tuple_pair):\n        for pair in pairs:\n            if pair.is_pair(tuple_pair):\n                return pair\n\n        raise Exception(\"Did not find the AtomPair\")\n\n    g = nx.Graph()\n    atom_pairs = []\n    for pair in self.matched_pairs:\n        ap = AtomPair(pair[0], pair[1])\n        atom_pairs.append(ap)\n        g.add_node(ap)\n\n    # connect the atom pairs\n    for pair_from, pair_list in self.matched_pairs_bonds.items():\n        # lookup the corresponding atom pairs\n        ap_from = lookup_up(atom_pairs, pair_from)\n        for tuple_pair, bond_type in pair_list:\n            ap_to = lookup_up(atom_pairs, tuple_pair)\n            g.add_edge(ap_from, ap_to)\n\n    # check for connected components (CC)\n    remove_ccs = []\n    ccs = [g.subgraph(cc).copy() for cc in nx.connected_components(g)]\n    largest_cc = max([len(cc) for cc in ccs])\n\n    # there are disjoint fragments, remove the smaller one\n    for cc in ccs[::-1]:\n        # remove the cc if it smaller than the largest component\n        if len(cc) &lt; largest_cc:\n            remove_ccs.append(cc)\n            ccs.remove(cc)\n\n    # remove the cc that have a smaller number of heavy atoms\n    largest_heavy_atom_cc = max(\n        [len([p for p in cc.nodes() if p.is_heavy_atom()]) for cc in ccs]\n    )\n    for cc in ccs[::-1]:\n        if len([p for p in cc if p.is_heavy_atom()]) &lt; largest_heavy_atom_cc:\n            if verbose:\n                logger.debug(\"Found CC that had fewer heavy atoms. Removing. \")\n            remove_ccs.append(cc)\n            ccs.remove(cc)\n\n    # remove the cc that has a smaller number of rings\n    largest_cycle_num = max([len(nx.cycle_basis(cc)) for cc in ccs])\n    for cc in ccs[::-1]:\n        if len(nx.cycle_basis(cc)) &lt; largest_cycle_num:\n            if verbose:\n                logger.debug(\"Found CC that had fewer cycles. Removing. \")\n            remove_ccs.append(cc)\n            ccs.remove(cc)\n\n    # remove cc that has a smaller number of heavy atoms across rings\n    most_heavy_atoms_in_cycles = 0\n    for cc in ccs[::-1]:\n        # count the heavy atoms across the cycles\n        heavy_atom_counter = 0\n        for cycle in nx.cycle_basis(cc):\n            for a in cycle:\n                if a.is_heavy_atom():\n                    heavy_atom_counter += 1\n        if heavy_atom_counter &gt; most_heavy_atoms_in_cycles:\n            most_heavy_atoms_in_cycles = heavy_atom_counter\n\n    for cc in ccs[::-1]:\n        # count the heavy atoms across the cycles\n        heavy_atom_counter = 0\n        for cycle in nx.cycle_basis(cc):\n            for a in cycle:\n                if a.is_heavy_atom():\n                    heavy_atom_counter += 1\n\n        if heavy_atom_counter &lt; most_heavy_atoms_in_cycles:\n            if verbose:\n                logger.debug(\n                    \"Found CC that had fewer heavy atoms in cycles. Removing. \"\n                )\n            remove_ccs.append(cc)\n            ccs.remove(cc)\n\n    if len(ccs) &gt; 1:\n        # there are equally large CCs\n        if verbose:\n            logger.debug(\n                \"The Connected Components are equally large! Picking the first one\"\n            )\n        for cc in ccs[1:]:\n            remove_ccs.append(cc)\n            ccs.remove(cc)\n\n    assert len(ccs) == 1, (\n        \"At this point there should be left only one main component\"\n    )\n\n    # remove the worse cc\n    for cc in remove_ccs:\n        for atom_pair in cc:\n            atom_tuple = (atom_pair.left_atom, atom_pair.right_atom)\n            self.remove_node_pair(atom_tuple)\n            self._removed_because_disjointed_cc.append(atom_tuple)\n\n    return largest_cc, remove_ccs\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.assign_atoms_ids","title":"assign_atoms_ids","text":"<pre><code>assign_atoms_ids(id_start=1)\n</code></pre> <p>Assign an ID to each pair A1-B1. This means that if we request an atom ID for A1 or B1 it will be the same.</p> <p>Then assign different IDs for the other atoms</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def assign_atoms_ids(self, id_start=1):\n    \"\"\"\n    Assign an ID to each pair A1-B1. This means that if we request an atom ID\n    for A1 or B1 it will be the same.\n\n    Then assign different IDs for the other atoms\n    \"\"\"\n    self.internal_ids = {}\n    id_counter = id_start\n    # for each pair assign an ID\n    for left_atom, right_atom in self.matched_pairs:\n        self.internal_ids[left_atom] = id_counter\n        self.internal_ids[right_atom] = id_counter\n        # make it possible to look up the atom ID with a pair\n        self.internal_ids[(left_atom, right_atom)] = id_counter\n\n        id_counter += 1\n        self.unique_atom_count += 1\n\n    # for each atom that was not mapped to any other atom,\n    # but is still in the topology, generate an ID for it\n\n    # find the not mapped atoms in the left topology and assign them an atom ID\n    for node in self.top1:\n        # check if this node was matched\n        if not self.contains_node(node):\n            self.internal_ids[node] = id_counter\n            id_counter += 1\n            self.unique_atom_count += 1\n\n    # find the not mapped atoms in the right topology and assign them an atom ID\n    for node in self.top2:\n        # check if this node was matched\n        if not self.contains_node(node):\n            self.internal_ids[node] = id_counter\n            id_counter += 1\n            self.unique_atom_count += 1\n\n    # return the last atom\n    return id_counter\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms","title":"get_appearing_atoms","text":"<pre><code>get_appearing_atoms()\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms--fixme-should-check-first-if-atomname-is-unique","title":"fixme - should check first if atomName is unique","text":"<p>Return a list of appearing atoms (atomName) which are the atoms that are</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_appearing_atoms(self):\n    \"\"\"\n    # fixme - should check first if atomName is unique\n    Return a list of appearing atoms (atomName) which are the\n    atoms that are\n    \"\"\"\n    unmatched = []\n    for top2_atom in self.top2:\n        is_matched = False\n        for _, matched_right_ligand_atom in self.matched_pairs:\n            if top2_atom is matched_right_ligand_atom:\n                is_matched = True\n                break\n        if not is_matched:\n            unmatched.append(top2_atom)\n\n    return unmatched\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms","title":"get_disappearing_atoms","text":"<pre><code>get_disappearing_atoms()\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-should-check-first-if-atomname-is-unique","title":"fixme - should check first if atomName is unique","text":""},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-update-to-using-the-node-set","title":"fixme - update to using the node set","text":"<p>Return a list of appearing atoms (atomName) which are the atoms that are found in the topology, and that are not present in the matched_pairs</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_disappearing_atoms(self):\n    \"\"\"\n    # fixme - should check first if atomName is unique\n    # fixme - update to using the node set\n    Return a list of appearing atoms (atomName) which are the\n    atoms that are found in the topology, and that\n    are not present in the matched_pairs\n    \"\"\"\n    unmatched = []\n    for top1_atom in self.top1:\n        is_matched = False\n        for matched_left_ligand_atom, _ in self.matched_pairs:\n            if top1_atom is matched_left_ligand_atom:\n                is_matched = True\n                break\n        if not is_matched:\n            unmatched.append(top1_atom)\n\n    return unmatched\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.remove_lonely_hydrogens","title":"remove_lonely_hydrogens","text":"<pre><code>remove_lonely_hydrogens()\n</code></pre> <p>You could also remove the hydrogens when you correct charges.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def remove_lonely_hydrogens(self):\n    \"\"\"\n    You could also remove the hydrogens when you correct charges.\n    \"\"\"\n    logger.error(\n        \"ERROR: function used that was not verified. It can create errors. \"\n        \"Please verify that the code works first.\"\n    )\n    # in order to see any hydrogens that are by themselves, we check for any connection\n    removed_pairs = []\n    for A1, B1 in self.matched_pairs:\n        # fixme - assumes hydrogens start their names with H*\n        if not A1.name.upper().startswith(\"H\"):\n            continue\n\n        # check if any of the bonded atoms can be found in this sup top\n        if not self.contains_any(A1.bonds) or not self.contains_node(B1.bonds):\n            # we appear disconnected, remove us\n            pass\n        for bonded_atom in A1.bonds:\n            assert not bonded_atom.name.upper().startswith(\"H\")\n            if self.contains_node(bonded_atom):\n                continue\n\n    return removed_pairs\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.match_gaff2_nondirectional_bonds","title":"match_gaff2_nondirectional_bonds","text":"<pre><code>match_gaff2_nondirectional_bonds()\n</code></pre> <p>If needed, swap cc-cd with cd-cc. If two pairs are linked: (CC/CD) - (CD/CC), replace them according to the left side: (CC/CC) - (CD/CD). Apply this rule to all other pairs in Table I (b) at http://ambermd.org/antechamber/gaff.html</p> <p>These two define where the double bond is in a ring. GAFF decides on which one is cc or cd depending on the arbitrary atom order. This intervention we ensure that we do not remove atoms based on that arbitrary order.</p> <p>This method is idempotent.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def match_gaff2_nondirectional_bonds(self):\n    \"\"\"\n    If needed, swap cc-cd with cd-cc.\n    If two pairs are linked: (CC/CD) - (CD/CC),\n    replace them according to the left side: (CC/CC) - (CD/CD).\n    Apply this rule to all other pairs in Table I (b) at http://ambermd.org/antechamber/gaff.html\n\n    These two define where the double bond is in a ring.\n    GAFF decides on which one is cc or cd depending on the arbitrary atom order.\n    This intervention we ensure that we do not remove atoms based on that arbitrary order.\n\n    This method is idempotent.\n    \"\"\"\n    nondirectionals = (\n        {\"CC\", \"CD\"},\n        {\"CE\", \"CF\"},\n        {\"CP\", \"CQ\"},\n        {\"PC\", \"PD\"},\n        {\"PE\", \"PF\"},\n        {\"NC\", \"ND\"},\n    )\n\n    for no_direction_pair in nondirectionals:\n        corrected_pairs = []\n        for A1, A2 in self.matched_pairs:\n            # check if it is the right combination\n            if (\n                not {A1.type, A2.type} == no_direction_pair\n                or (A1, A2) in corrected_pairs\n            ):\n                continue\n\n            # ignore if they are already the same\n            if A2.type == A1.type:\n                continue\n\n            # fixme - temporary solution\n            # fixme - do we want to check if we are in a ring?\n            # for now we are simply rewriting the types here so that it passes the \"specific atom type\" checks later\n            # ie so that later CC-CC and CD-CD are compared\n            # fixme - check if .type is used when writing the final output.\n            A2.type = A1.type\n            logger.debug(\n                f\"Arbitrary atom type correction. \"\n                f\"Right atom type {A2.type} (in {A2}) overwritten with left atom type {A1.type} (in {A1}). \"\n            )\n\n            corrected_pairs.append((A1, A2))\n\n    return 0\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_net_charge","title":"get_net_charge","text":"<pre><code>get_net_charge()\n</code></pre> <p>Calculate the net charge difference across the matched pairs.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_net_charge(self):\n    \"\"\"\n    Calculate the net charge difference across\n    the matched pairs.\n    \"\"\"\n    net_charge = sum(n1.charge - n2.charge for n1, n2 in self.matched_pairs)\n    return net_charge\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_matched_with_diff_q","title":"get_matched_with_diff_q","text":"<pre><code>get_matched_with_diff_q()\n</code></pre> <p>Returns a list of matched atom pairs that have a different q, sorted in the descending order (the first pair has the largest q diff).</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_matched_with_diff_q(self):\n    \"\"\"\n    Returns a list of matched atom pairs that have a different q,\n    sorted in the descending order (the first pair has the largest q diff).\n    \"\"\"\n    diff_q = [\n        (n1, n2)\n        for n1, n2 in self.matched_pairs\n        if np.abs(n1.united_charge - n2.united_charge) &gt; 0\n    ]\n    return sorted(\n        diff_q,\n        key=lambda p: abs(p[0].united_charge - p[1].united_charge),\n        reverse=True,\n    )\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter","title":"apply_net_charge_filter","text":"<pre><code>apply_net_charge_filter(net_charge_threshold)\n</code></pre> <p>Averaging the charges across paired atoms introduced inequalities. Check if the sum of the inequalities in charges is below net_charge. If not, remove pairs until that net_charge is met. Which pairs are removed depends on the approach. Greedy removal of the pairs with the highest difference can create disjoint blocks which creates issues in themselves.</p>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter--specifically-create-copies-for-each-strategy-here-and-try-a-couple-of-them","title":"Specifically, create copies for each strategy here and try a couple of them.","text":"<p>Returns: a new suptop where the net_charge_threshold is enforced.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def apply_net_charge_filter(self, net_charge_threshold):\n    \"\"\"\n    Averaging the charges across paired atoms introduced inequalities.\n    Check if the sum of the inequalities in charges is below net_charge.\n    If not, remove pairs until that net_charge is met.\n    Which pairs are removed depends on the approach.\n    Greedy removal of the pairs with the highest difference\n    can create disjoint blocks which creates issues in themselves.\n\n    # Specifically, create copies for each strategy here and try a couple of them.\n    Returns: a new suptop where the net_charge_threshold is enforced.\n    \"\"\"\n\n    approaches = [\n        \"greedy\",\n        \"terminal_alch_linked\",\n        \"terminal\",\n        \"alch_linked\",\n        \"leftovers\",\n        \"smart\",\n    ]\n    rm_disjoint_at_each_step = [True, False]\n\n    # best configuration info\n    best_approach = None\n    suptop_size = -1\n    rm_disjoint_each_step_conf = False\n\n    # try all confs\n    for rm_disjoint_each_step in rm_disjoint_at_each_step:\n        for approach in approaches:\n            # make a shallow copy of the suptop\n            next_approach = copy.copy(self)\n            # first overall\n            if rm_disjoint_each_step:\n                next_approach.largest_cc_survives(verbose=False)\n\n            # try the strategy\n            while np.abs(next_approach.get_net_charge()) &gt; net_charge_threshold:\n                best_candidate_with_h = next_approach._smart_netqtol_pair_picker(\n                    approach\n                )\n                for pair in best_candidate_with_h:\n                    next_approach.remove_node_pair(pair)\n\n                if rm_disjoint_each_step:\n                    next_approach.largest_cc_survives(verbose=False)\n\n            # regardless of whether the continuous disjoint removal is being tried or not,\n            # it will be applied at the end\n            # so apply it here at the end in order to make this comparison equivalent\n            next_approach.largest_cc_survives(verbose=False)\n\n            if len(next_approach) &gt; suptop_size:\n                suptop_size = len(next_approach)\n                best_approach = approach\n                rm_disjoint_each_step_conf = rm_disjoint_each_step\n\n    # apply the best strategy to this suptop\n    logger.debug(\n        f\"Pair removal strategy (q net tol): {best_approach} with disjoint CC removed at each step: {rm_disjoint_each_step_conf}\"\n    )\n\n    total_diff = 0\n    if rm_disjoint_each_step_conf:\n        self.largest_cc_survives()\n    while np.abs(self.get_net_charge()) &gt; net_charge_threshold:\n        best_candidate_with_h = self._smart_netqtol_pair_picker(best_approach)\n\n        # remove them\n        for pair in best_candidate_with_h:\n            self.remove_node_pair(pair)\n            diff_q_pairs = abs(pair[0].united_charge - pair[1].united_charge)\n            # add to the list of removed because of the net charge\n            self._removed_due_to_net_charge.append([pair, diff_q_pairs])\n            total_diff += diff_q_pairs\n\n        if rm_disjoint_each_step_conf:\n            self.largest_cc_survives()\n\n    return total_diff\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.remove_attached_hydrogens","title":"remove_attached_hydrogens","text":"<pre><code>remove_attached_hydrogens(node_pair)\n</code></pre> <p>The node_pair to which these hydrogens are attached was removed. Remove the dangling hydrogens.</p> <p>Check if these hydrogen are matched/superimposed. If that is the case. Remove the pairs.</p> <p>Note that if the hydrogens are paired and attached to node_pairA, they have to be attached to node_pairB, as a rule of being a match.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def remove_attached_hydrogens(self, node_pair):\n    \"\"\"\n    The node_pair to which these hydrogens are attached was removed.\n    Remove the dangling hydrogens.\n\n    Check if these hydrogen are matched/superimposed. If that is the case. Remove the pairs.\n\n    Note that if the hydrogens are paired and attached to node_pairA,\n    they have to be attached to node_pairB, as a rule of being a match.\n    \"\"\"\n\n    # skip if no hydrogens found\n    if node_pair not in self.matched_pairs_bonds:\n        return []\n\n    attached_pairs = self.matched_pairs_bonds[node_pair]\n\n    removed_pairs = []\n    for pair, bond_types in list(attached_pairs):\n        # ignore non hydrogens\n        if not pair[0].element == \"H\":\n            continue\n\n        self.remove_node_pair(pair)\n        logger.debug(f\"Removed dangling hydrogen pair: {pair}\")\n        removed_pairs.append(pair)\n    return removed_pairs\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.find_lowest_rmsd_mirror","title":"find_lowest_rmsd_mirror","text":"<pre><code>find_lowest_rmsd_mirror()\n</code></pre> <p>Walk through the different mirrors and out of all options select the one that has the lowest RMSD. This way we increase the chance of getting a better match. However, long term it will be necessary to use the dihedrals to ensure that we match the atoms better.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def find_lowest_rmsd_mirror(self):\n    \"\"\"\n    Walk through the different mirrors and out of all options select the one\n    that has the lowest RMSD. This way we increase the chance of getting a better match.\n    However, long term it will be necessary to use the dihedrals to ensure that we match\n    the atoms better.\n    \"\"\"\n    # fixme - you have to also take into account the \"weird / other symmetries\" besides mirrors\n    winner = self\n    lowest_rmsd = self.rmsd()\n    for mirror in self.mirrors:\n        mirror_rmsd = mirror.rmsd()\n        if mirror_rmsd &lt; lowest_rmsd:\n            lowest_rmsd = mirror_rmsd\n            winner = mirror\n\n    if self is winner:\n        # False here means that it is not a mirror\n        return lowest_rmsd, self, False\n    else:\n        return lowest_rmsd, winner, True\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of_global_top","title":"is_subgraph_of_global_top","text":"<pre><code>is_subgraph_of_global_top()\n</code></pre> <p>Check if after superimposition, one graph is a subgraph of another :return:</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_subgraph_of_global_top(self):\n    \"\"\"\n    Check if after superimposition, one graph is a subgraph of another\n    :return:\n    \"\"\"\n    # check if one topology is a subgraph of another topology\n    if len(self.matched_pairs) == len(self.top1) or len(self.matched_pairs) == len(\n        self.top2\n    ):\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.rmsd","title":"rmsd","text":"<pre><code>rmsd()\n</code></pre> <p>For each pair take the distance, and then get rmsd, so root(mean(square(deviation)))</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def rmsd(self):\n    \"\"\"\n    For each pair take the distance, and then get rmsd, so root(mean(square(deviation)))\n    \"\"\"\n\n    assert len(self.matched_pairs) &gt; 0\n\n    dsts = []\n    for atomA, atomB in self.matched_pairs:\n        dst = np.sqrt(np.sum(np.square((atomA.position - atomB.position))))\n        dsts.append(dst)\n    return np.sqrt(np.mean(np.square(dsts)))\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.link_pairs","title":"link_pairs","text":"<pre><code>link_pairs(from_pair, pairs)\n</code></pre> <p>This helps take care of the bonds.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def link_pairs(self, from_pair, pairs):\n    \"\"\"\n    This helps take care of the bonds.\n    \"\"\"\n    assert from_pair in self.matched_pairs_bonds\n    for pair, bond_types in pairs:\n        # the parent pair should have its list of pairs\n        assert pair in self.matched_pairs_bonds, f\"not found pair {pair}\"\n\n        # link X-Y\n        self.matched_pairs_bonds[from_pair].add((pair, bond_types))\n        # link Y-X\n        self.matched_pairs_bonds[pair].add((from_pair, bond_types))\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices","title":"find_mirror_choices","text":"<pre><code>find_mirror_choices()\n</code></pre> <p>For each pair (A1, B1) find all the other options in the mirrors where (A1, B2)</p>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--ie-ignore-x-b1-search-if-we-repair-from-a-to-b-then-b-to-a-should-be-repaired-too","title":"ie Ignore (X, B1) search, if we repair from A to B, then B to A should be repaired too","text":""},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--fixme-is-this-still-necessary-if-we-are-traversing-all-paths","title":"fixme - is this still necessary if we are traversing all paths?","text":"Source code in <code>ties/topology_superimposer.py</code> <pre><code>def find_mirror_choices(self):\n    \"\"\"\n    For each pair (A1, B1) find all the other options in the mirrors where (A1, B2)\n    # ie Ignore (X, B1) search, if we repair from A to B, then B to A should be repaired too\n\n    # fixme - is this still necessary if we are traversing all paths?\n    \"\"\"\n    choices = {}\n    for A1, B1 in self.matched_pairs:\n        options_for_a1 = []\n        for mirror in self.mirrors:\n            for A2, B2 in mirror.matched_pairs:\n                if A1 is A2 and B1 is not B2:\n                    options_for_a1.append(B2)\n\n        if options_for_a1:\n            options_for_a1.insert(0, B1)\n            choices[A1] = options_for_a1\n\n    return choices\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.add_alternative_mapping","title":"add_alternative_mapping","text":"<pre><code>add_alternative_mapping(weird_symmetry)\n</code></pre> <p>This means that there is another way to traverse and overlap the two molecules, but that the self is better (e.g. lower rmsd) than the other one</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def add_alternative_mapping(self, weird_symmetry):\n    \"\"\"\n    This means that there is another way to traverse and overlap the two molecules,\n    but that the self is better (e.g. lower rmsd) than the other one\n    \"\"\"\n    self.alternative_mappings.append(weird_symmetry)\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates","title":"correct_for_coordinates","text":"<pre><code>correct_for_coordinates()\n</code></pre> <p>Use the coordinates of the atoms, to figure out which symmetries are the correct ones. Rearrange so that the overall topology represents the one that has appropriate coordinates, whereas all the mirrors represent the other poor matches.</p>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates--fixme-ensure-that-each-node-is-used-only-once-at-the-end","title":"fixme - ensure that each node is used only once at the end","text":"Source code in <code>ties/topology_superimposer.py</code> <pre><code>def correct_for_coordinates(self):\n    \"\"\"\n    Use the coordinates of the atoms, to figure out which symmetries are the correct ones.\n    Rearrange so that the overall topology represents the one that has appropriate coordinates,\n    whereas all the mirrors represent the other poor matches.\n\n    # fixme - ensure that each node is used only once at the end\n    \"\"\"\n\n    # check if you have coordinates\n    # fixme - rn we have it, check\n\n    # superimpose the coordinates, ensure a good match\n    # fixme - this was done before, so let's leave this way for now\n\n    # fixme - consider putting this conf as a mirror, and then modifying this\n\n    # check which are preferable for each of the mirrors\n    # we have to match mirrors to each other, ie say we have (O1=O3) and (O2=O4)\n    # we should find the mirror matching (O1=O4) and (O2=O3)\n    # so note that we have a closure here: All 4 atoms are used in both cases, and each time are paired differently.\n    # So this is how we defined the mirror - and therefore we can reduce this issue to the minimal mirrors.\n    # fixme - is this a cycle? O1-O3-O2-O4-O1\n    # Let's try to define a chain: O1 =O3, and O1 =O4, and O2 is =O3 or =O4\n    # So we have to define how to find O1 matching to different parts, and then decide\n    choices_mapping = self.find_mirror_choices()\n\n    # fixme - rewrite this method to eliminate one by one the hydrogens that fit in perfectly,\n    # some of them will have a plural significant match, while others might be hazy,\n    # so we have to eliminate them one by one, searching the best matches and then eliminating them\n\n    removed_nodes = set()\n    for A1, choices in choices_mapping.items():\n        # remove the old tuple\n        # fixme - not sure if this is the right way to go,\n        # but we break all the rules when applying this simplistic strategy\n        self.remove_node_pair((A1, choices[0]))\n        removed_nodes.add(A1)\n        removed_nodes.add(choices[0])\n\n    shortest_dsts = []\n\n    added_nodes = set()\n\n    # better matches\n    # for each atom that mismatches, scan all molecules and find the best match and eliminate it\n    blacklisted_bxs = []\n    for _ in range(len(choices_mapping)):\n        # fixme - optimisation of this could be such that if they two atoms are within 0.2A or something\n        # then they are straight away fixed\n        closest_dst = 9999999\n        closest_a1 = None\n        closest_bx = None\n        for A1, choices in choices_mapping.items():\n            # so we have several choices for A1, and now naively we are taking the one that is closest, and\n            # assuming the superimposition is easy, this would work\n\n            # FIXME - you cannot use simply distances, if for A1 and A2 the best is BX, then BX there should be\n            # rules for that\n            for BX in choices:\n                if BX in blacklisted_bxs:\n                    continue\n                # use the distance_array because of PBC correction and speed\n                a1_bx_dst = np.sqrt(np.sum(np.square(A1.position - BX.position)))\n                if a1_bx_dst &lt; closest_dst:\n                    closest_dst = a1_bx_dst\n                    closest_bx = BX\n                    closest_a1 = A1\n\n        # across all the possible choices, found the best match now:\n        blacklisted_bxs.append(closest_bx)\n        shortest_dsts.append(closest_dst)\n        logger.debug(f\"{closest_a1.name} is matching best with {closest_bx.name}\")\n\n        # remove the old tuple and insert the new one\n        self.add_node_pair((closest_a1, closest_bx))\n        added_nodes.add(closest_a1)\n        added_nodes.add(closest_bx)\n        # remove from consideration\n        del choices_mapping[closest_a1]\n        # blacklist\n\n    # fixme - check that the added and the removed nodes are the same set\n    assert removed_nodes == added_nodes\n\n    # this is the corrected region score (there might not be any)\n    if len(shortest_dsts) != 0:\n        avg_dst = np.mean(shortest_dsts)\n    else:\n        # fixme\n        avg_dst = 0\n\n    return avg_dst\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.is_area_overlapping_fully","title":"is_area_overlapping_fully","text":"<pre><code>is_area_overlapping_fully(l_atoms, r_atoms)\n</code></pre> <p>Each atom in one set has to be matched to an atom in the second set. And vice versa.</p> <p>:param l_atoms: :param r_atoms: :return:</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_area_overlapping_fully(self, l_atoms, r_atoms):\n    \"\"\"\n    Each atom in one set has to be matched to an atom in the second set. And vice versa.\n\n    :param l_atoms:\n    :param r_atoms:\n    :return:\n    \"\"\"\n    if len(l_atoms) != len(r_atoms):\n        return False\n\n    for atom in l_atoms:\n        if not self.contains_node(atom):\n            return False\n\n        _, matched_r = self.get_pair_with_atom(atom)\n        if matched_r not in r_atoms:\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.is_area_overlapping","title":"is_area_overlapping","text":"<pre><code>is_area_overlapping(l_atoms, r_atoms)\n</code></pre> <p>Even a small overlap will return True.</p> <p>:param l_atoms: :param r_atoms: :return:</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_area_overlapping(self, l_atoms, r_atoms):\n    \"\"\"\n    Even a small overlap will return True.\n\n    :param l_atoms:\n    :param r_atoms:\n    :return:\n    \"\"\"\n\n    for atom in l_atoms:\n        _, matched_r = self.get_pair_with_atom(atom)\n        if matched_r in r_atoms:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.enforce_no_partial_rings","title":"enforce_no_partial_rings","text":"<pre><code>enforce_no_partial_rings()\n</code></pre> <p>Ensure that rings are either fully matched, or not matched with anything at all.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def enforce_no_partial_rings(self):\n    \"\"\"\n    Ensure that rings are either fully matched,\n    or not matched with anything at all.\n    \"\"\"\n\n    # circles from the original ligands\n    l_cycles, r_cycles = self.get_original_circles()\n\n    # keep track of the fully matched cycles\n    atoms_in_good_cycles = set()\n\n    # find the fully matched cycles\n    for l_cycle in l_cycles[::-1]:\n        for r_cycle in r_cycles[::-1]:\n            if not self.is_area_overlapping_fully(l_cycle, r_cycle):\n                continue\n\n            # these rings are matched perfectly\n            l_cycles.remove(l_cycle)\n            r_cycles.remove(r_cycle)\n            atoms_in_good_cycles.update(l_cycle)\n            atoms_in_good_cycles.update(r_cycle)\n\n    def remove_partial_rings(circles):\n        for atom in [atom for sublist in circles for atom in sublist]:\n            # account for the fused rings\n            # the correct part of the fused ring should remain untouched\n            if atom in atoms_in_good_cycles:\n                continue\n\n            if not self.contains_node(atom):\n                continue\n\n            left, right = self.get_pair_with_atom(atom)\n            self._remove_unmatched_ring_atom(right)\n            self._remove_unmatched_ring_atom(left)\n\n    # remove any other matched ring atoms\n    # at this point we cannot be certain what they are matched to\n    remove_partial_rings(l_cycles)\n    remove_partial_rings(r_cycles)\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score","title":"get_topology_similarity_score","text":"<pre><code>get_topology_similarity_score()\n</code></pre> <p>Having the superimposed A(Left) and B(Right), score the match. This is a rather naive approach. It compares A-B match by checking if any of the node X and X' in A and B have a bond to another node Y that is not present in A-B, but that is directly reachable from X and X' in a similar way. We ignore the charge of Y and focus here only on the topology.</p> <p>For every \"external bond\" from the component we try to see if topologically it scores well. So for any matched pair, we extend the topology and the score is equal to the size of such an component. Then we do this for all other matching nodes and sum the score.</p>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score--fixme-maybe-you-should-use-the-entire-graphs-in-order-to-see-if-this-is-good-or-not","title":"fixme - maybe you should use the entire graphs in order to see if this is good or not?","text":"<p>so the simpler approach is to ignore charges for a second to only understand the relative place in the topology, in other words, the question is, how similar are two nodes A and B vs A and C? let's traverse A and B together, and then A and C together, and while doing that, ignore the charges. In this case, A and B could get together 20 parts, whereas A and C traverses together 22 parts, meaning that topologically, it is a more suitable one, because it closer corresponds to the actual atom. Note that this approach has problem: - you can imagine A and B traversing where B is in a completely wrong global place, but it happens to have a bigger part common to A, than C which globally is correct. Answer to this: at the same time, ideally B would be excluded, because it should have been already matched to another topology.</p> <p>Alternative approach: take into consideration other components and the distance from this component to them. Specifically, allows mismatches</p> <p>FIXME - allow flexible mismatches. Meaning if someone mutates one bonded atom, then it might be noticed that</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_topology_similarity_score(self):\n    \"\"\"\n    Having the superimposed A(Left) and B(Right), score the match.\n    This is a rather naive approach. It compares A-B match by checking\n    if any of the node X and X' in A and B have a bond to another node Y that is\n    not present in A-B, but that is directly reachable from X and X' in a similar way.\n    We ignore the charge of Y and focus here only on the topology.\n\n    For every \"external bond\" from the component we try to see if topologically it scores well.\n    So for any matched pair, we extend the topology and the score is equal to the size of\n    such an component. Then we do this for all other matching nodes and sum the score.\n\n    # fixme - maybe you should use the entire graphs in order to see if this is good or not?\n    so the simpler approach is to ignore charges for a second to only understand the relative place in the topology,\n    in other words, the question is, how similar are two nodes A and B vs A and C? let's traverse A and B together,\n    and then A and C together, and while doing that, ignore the charges. In this case, A and B could\n    get together 20 parts, whereas A and C traverses together 22 parts, meaning that topologically,\n    it is a more suitable one, because it closer corresponds to the actual atom.\n    Note that this approach has problem:\n    - you can imagine A and B traversing where B is in a completely wrong global place, but it\n    happens to have a bigger part common to A, than C which globally is correct. Answer to this:\n    at the same time, ideally B would be excluded, because it should have been already matched to another\n    topology.\n\n    Alternative approach: take into consideration other components and the distance from this component\n    to them. Specifically, allows mismatches\n\n    FIXME - allow flexible mismatches. Meaning if someone mutates one bonded atom, then it might be noticed\n    that\n    \"\"\"\n    overall_score = 0\n    for node_a, node_b in self.matched_pairs:\n        # for every neighbour in Left\n        for a_bond in node_a.bonds:\n            # if this bonded atom is present in this superimposed topology (or component), ignore\n            # fixme - surely this can be done better, you could have \"contains this atom or something\"\n            in_this_sup_top = False\n            for other_a, _ in self.matched_pairs:\n                if a_bond.atom == other_a:\n                    in_this_sup_top = True\n                    break\n            if in_this_sup_top:\n                continue\n\n            # a candidate is found that could make the node_a and node_b more similar,\n            # so check if it is also present in node_b,\n            # ignore the charges to focus only on the topology and put aside the parameterisation\n            for b_bond in node_b.bonds:\n                # fixme - what if the atom is mutated into a different atom? we have to be able\n                # to relies on other measures than just this one, here the situation is that the topology\n                # is enough to answer the question (because only charges were modified),\n                # however, this gets more tricky\n                # fixme - hardcoded\n                score = len(_overlay(a_bond.atom, b_bond.atom))\n\n                # this is a purely topology based score, the bigger the overlap the better the match\n                overall_score += score\n\n            # check if the neighbour points to any node X that is not used in Left,\n\n            # if node_b leads to the same node X\n    return overall_score\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.unmatch_pairs_with_different_charges","title":"unmatch_pairs_with_different_charges","text":"<pre><code>unmatch_pairs_with_different_charges(atol)\n</code></pre> <p>Removes the matched pairs where atom charges are more different than the provided absolute tolerance atol (units in Electrons).</p> <p>remove_dangling_h: After removing any pair it also removes any bound hydrogen(s).</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def unmatch_pairs_with_different_charges(self, atol):\n    \"\"\"\n    Removes the matched pairs where atom charges are more different\n    than the provided absolute tolerance atol (units in Electrons).\n\n    remove_dangling_h: After removing any pair it also removes any bound hydrogen(s).\n    \"\"\"\n    removed_hydrogen_pairs = []\n    for node1, node2 in self.matched_pairs[::-1]:\n        if (\n            node1.united_eq(node2, atol=atol)\n            or (node1, node2) in removed_hydrogen_pairs\n        ):\n            continue\n\n        # remove this pair\n        # use full logging for this kind of information\n        # print('Q: removing nodes', (node1, node2)) # to do - consider making this into a logging feature\n        self.remove_node_pair((node1, node2))\n\n        # keep track of the removed atoms due to the charge\n        self._removed_pairs_with_charge_difference.append(\n            ((node1, node2), math.fabs(node2.united_charge - node1.united_charge))\n        )\n\n        # Removed functionality: remove the dangling hydrogens\n        removed_h_pairs = self.remove_attached_hydrogens((node1, node2))\n        removed_hydrogen_pairs.extend(removed_h_pairs)\n        for h_pair in removed_h_pairs:\n            self._removed_pairs_with_charge_difference.append((h_pair, \"dangling\"))\n\n    # sort the removed in a descending order\n    self._removed_pairs_with_charge_difference.sort(\n        key=lambda x: x[1], reverse=True\n    )\n\n    return self._removed_pairs_with_charge_difference\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.is_consistent_with","title":"is_consistent_with","text":"<pre><code>is_consistent_with(suptop)\n</code></pre> Conditions <ul> <li>There should be a minimal overlap of at least 1 node.</li> <li>There is no pair (Na=Nb) in this sup top such that (Na=Nc) or (Nb=Nc) for some Nc in the other suptop.</li> <li>The number of cycles in this suptop and the other suptop must be the same (?removing for now, fixme)</li> <li>merging cannot lead to new cycles?? (fixme). What is the reasoning behind this?     I mean, I guess the assumption is that, if the cycles were compatible,     they would be created during the search, rather than now while merging. ??</li> </ul> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_consistent_with(self, suptop):\n    \"\"\"\n    Conditions:\n        - There should be a minimal overlap of at least 1 node.\n        - There is no pair (Na=Nb) in this sup top such that (Na=Nc) or (Nb=Nc) for some Nc in the other suptop.\n        - The number of cycles in this suptop and the other suptop must be the same (?removing for now, fixme)\n        - merging cannot lead to new cycles?? (fixme). What is the reasoning behind this?\n            I mean, I guess the assumption is that, if the cycles were compatible,\n            they would be created during the search, rather than now while merging. ??\n    \"\"\"\n\n    # confirm that there is no mismatches, ie (A=B) in suptop1 and (A=C) in suptop2 where (C!=B)\n    for st1Na, st1Nb in self.matched_pairs:\n        for st2Na, st2Nb in suptop.matched_pairs:\n            if (\n                (st1Na is st2Na)\n                and st1Nb is not st2Nb\n                or (st1Nb is st2Nb)\n                and st1Na is not st2Na\n            ):\n                return False\n\n    # ensure there is at least one common pair\n    if self.count_common_node_pairs(suptop) == 0:\n        return False\n\n    # why do we need this?\n    # if not self.is_consistent_cycles(suptop):\n    #     return False\n\n    return True\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_circles","title":"get_circles","text":"<pre><code>get_circles()\n</code></pre> <p>Return circles found in the matched pairs.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_circles(self):\n    \"\"\"\n    Return circles found in the matched pairs.\n    \"\"\"\n    gl, gr = self.get_nx_graphs()\n    gl_circles = [set(circle) for circle in nx.cycle_basis(gl)]\n    gr_circles = [set(circle) for circle in nx.cycle_basis(gr)]\n    return gl_circles, gr_circles\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.get_original_circles","title":"get_original_circles","text":"<pre><code>get_original_circles()\n</code></pre> <p>Return the original circles present in the input topologies.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_original_circles(self):\n    \"\"\"\n    Return the original circles present in the input topologies.\n    \"\"\"\n    # create a circles\n    l_original = self._get_original_circle(self.top1)\n    r_original = self._get_original_circle(self.top2)\n\n    l_circles = [set(circle) for circle in nx.cycle_basis(l_original)]\n    r_circles = [set(circle) for circle in nx.cycle_basis(r_original)]\n    return l_circles, r_circles\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.cycle_spans_multiple_cycles","title":"cycle_spans_multiple_cycles","text":"<pre><code>cycle_spans_multiple_cycles()\n</code></pre> <p>What is the circle is shared? We are using cycles which excluded atoms that join different rings. fixme - could this lead to a special case?</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def cycle_spans_multiple_cycles(self):\n    # This filter checks whether a newly created suptop cycle spans multiple cycles\n    # this is one of the filters (#106)\n    # fixme - should this be applied whenever we work with more than 1 cycle?\n    # it checks whether any cycles in the left molecule,\n    # is paired with more than one cycle in the right molecule\n    \"\"\"\n    What is the circle is shared?\n    We are using cycles which excluded atoms that join different rings.\n    fixme - could this lead to a special case?\n    \"\"\"\n\n    for l_cycle in self._nonoverlapping_l_cycles:\n        overlap_counter = 0\n        for r_cycle in self._nonoverlapping_r_cycles:\n            # check if the cycles overlap\n            if self._cycles_overlap(l_cycle, r_cycle):\n                overlap_counter += 1\n\n        if overlap_counter &gt; 1:\n            return True\n\n    for r_cycle in self._nonoverlapping_r_cycles:\n        overlap_counter = 0\n        for l_cycle in self._nonoverlapping_l_cycles:\n            # check if the cycles overlap\n            if self._cycles_overlap(l_cycle, r_cycle):\n                overlap_counter += 1\n\n        if overlap_counter &gt; 1:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.merge","title":"merge","text":"<pre><code>merge(suptop)\n</code></pre> <p>Absorb the other suptop by adding all the node pairs that are not present in the current sup top.</p> <p>WARNING: ensure that the other suptop is consistent with this sup top.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def merge(self, suptop):\n    \"\"\"\n    Absorb the other suptop by adding all the node pairs that are not present\n    in the current sup top.\n\n    WARNING: ensure that the other suptop is consistent with this sup top.\n    \"\"\"\n    # assert self.is_consistent_with(suptop)\n\n    # print(\"About the merge two sup tops\")\n    # self.print_summary()\n    # other_suptop.print_summary()\n\n    merged_pairs = []\n    for pair in suptop.matched_pairs:\n        # check if this pair is present\n        if not self.contains(pair):\n            n1, n2 = pair\n            if self.contains_node(n1) or self.contains_node(n2):\n                raise Exception(\"already uses that node\")\n            # pass the bonded pairs here\n            self.add_node_pair(pair)\n            merged_pairs.append(pair)\n    # after adding all the nodes, now add the bonds\n    for pair in merged_pairs:\n        # add the connections\n        bonded_pairs = suptop.matched_pairs_bonds[pair]\n        assert len(bonded_pairs) &gt; 0\n        self.link_pairs(pair, bonded_pairs)\n\n    # removed from the \"merged\" the ones that agree, so it contains only the new stuff\n    # to make it easier to read\n    self.nodes_added_log.append((\"merged with\", merged_pairs))\n\n    # check for duplication, fixme - temporary\n    return merged_pairs\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.validate_charges","title":"validate_charges  <code>staticmethod</code>","text":"<pre><code>validate_charges(atom_list_l, atom_list_right)\n</code></pre> <p>Check the original charges: - ensure that the total charge of L and R are integers - ensure that they are equal to the same integer</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>@staticmethod\ndef validate_charges(atom_list_l, atom_list_right):\n    \"\"\"\n    Check the original charges:\n    - ensure that the total charge of L and R are integers\n    - ensure that they are equal to the same integer\n    \"\"\"\n    whole_left_charge = sum(a.charge for a in atom_list_l)\n    np.testing.assert_almost_equal(\n        whole_left_charge,\n        round(whole_left_charge),\n        decimal=2,\n        err_msg=f\"left charges are not integral. Expected {round(whole_left_charge)}\"\n        f\" but found {whole_left_charge}\",\n    )\n\n    whole_right_charge = sum(a.charge for a in atom_list_right)\n    np.testing.assert_almost_equal(\n        whole_right_charge,\n        round(whole_right_charge),\n        decimal=2,\n        err_msg=f\"right charges are not integral. Expected {round(whole_right_charge)}\"\n        f\" but found {whole_right_charge}\",\n    )\n    # same integer\n    np.testing.assert_almost_equal(whole_left_charge, whole_right_charge, decimal=2)\n\n    return round(whole_left_charge)\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.redistribute_charges","title":"redistribute_charges","text":"<pre><code>redistribute_charges()\n</code></pre> <p>After the match is made and the user commits to the superimposed topology, the charges can be revised. We calculate the average charges between every match, and check how that affects the rest of the molecule (the unmatched atoms). Then, we distribute the charges to the unmatched atoms to get the net charge as a whole number/integer.</p> <p>This function should be called after removing the matches for whatever reason. ie at the end of anything that could modify the atom pairing.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def redistribute_charges(self):\n    \"\"\"\n    After the match is made and the user commits to the superimposed topology,\n    the charges can be revised.\n    We calculate the average charges between every match, and check how that affects\n    the rest of the molecule (the unmatched atoms).\n    Then, we distribute the charges to the unmatched atoms to get\n    the net charge as a whole number/integer.\n\n    This function should be called after removing the matches for whatever reason.\n    ie at the end of anything that could modify the atom pairing.\n    \"\"\"\n\n    SuperimposedTopology.validate_charges(self.top1, self.top2)\n\n    # find the integral net charge of the molecule\n    net_charge = round(sum(a.charge for a in self.top1))\n    net_charge_test = round(sum(a.charge for a in self.top2))\n    if net_charge != net_charge_test:\n        raise Exception(\n            \"The internally computed net charges of the molecules are different\"\n        )\n    # fixme - use the one passed by the user?\n    logger.debug(f\"Internally computed net charge: {net_charge}\")\n\n    # the total charge in the matched region before the changes\n    matched_total_charge_l = sum(  # noqa: F841\n        left.charge for left, right in self.matched_pairs\n    )\n    matched_total_charge_r = sum(  # noqa: F841\n        right.charge for left, right in self.matched_pairs\n    )\n\n    # get the unmatched atoms in Left and Right\n    l_unmatched = self.get_disappearing_atoms()\n    r_unmatched = self.get_appearing_atoms()\n\n    init_q_dis = sum(a.charge for a in l_unmatched)\n    init_q_app = sum(a.charge for a in r_unmatched)\n    logger.debug(\n        f\"Initial cumulative charge of the appearing={init_q_app:.6f}, disappearing={init_q_dis:.6f} \"\n        f\"alchemical regions\"\n    )\n\n    # average the charges between matched atoms in the joint area of the dual topology\n    total_charge_matched = (\n        0  # represents the net charge of the joint area minus molecule charge\n    )\n    for left, right in self.matched_pairs:\n        avg_charge = (left.charge + right.charge) / 2.0\n        # write the new charge\n        left.charge = right.charge = avg_charge\n        total_charge_matched += avg_charge\n    # total_partial_charge_matched e.g. -0.9 (partial charges) - -1 (net molecule charge) = 0.1\n    total_partial_charge_matched = total_charge_matched - net_charge\n    logger.debug(\n        f\"Total partial charge in the joint area = {total_partial_charge_matched:.6f}\"\n    )\n\n    # calculate what the correction should be in the alchemical regions\n    r_delta_charge_total = -(total_partial_charge_matched + init_q_app)\n    l_delta_charge_total = -(total_partial_charge_matched + init_q_dis)\n    logger.debug(\n        f\"Total charge imbalance to be distributed in \"\n        f\"dis={l_delta_charge_total:.6f} and app={r_delta_charge_total:.6f}\"\n    )\n\n    if len(l_unmatched) == 0 and l_delta_charge_total != 0:\n        logger.error(\n            \"----------------------------------------------------------------------------------------------\"\n        )\n        logger.error(\n            \"ERROR? AFTER AVERAGING CHARGES, THERE ARE NO UNMATCHED ATOMS TO ASSIGN THE CHARGE TO: \"\n            \"left ligand.\"\n        )\n        logger.error(\n            \"----------------------------------------------------------------------------------------------\"\n        )\n    if len(r_unmatched) == 0 and r_delta_charge_total != 0:\n        logger.error(\n            \"----------------------------------------------------------------------------------------------\"\n        )\n        logger.error(\n            \"ERROR? AFTER AVERAGING CHARGES, THERE ARE NO UNMATCHED ATOMS TO ASSIGN THE CHARGE TO: \"\n            \"right ligand. \"\n        )\n        logger.error(\n            \"----------------------------------------------------------------------------------------------\"\n        )\n\n    # distribute the charges over the alchemical regions\n    if len(l_unmatched) != 0:\n        l_delta_per_atom = float(l_delta_charge_total) / len(l_unmatched)\n    else:\n        # fixme - no unmatching atoms, so there should be no charge to redistribute\n        l_delta_per_atom = 0\n\n    if len(r_unmatched) != 0:\n        r_delta_per_atom = float(r_delta_charge_total) / len(r_unmatched)\n    else:\n        r_delta_per_atom = 0\n        # fixme - no matching atoms, so there should be no charge to redistribute\n    logger.debug(\n        f\"Charge imbalance per atom in dis={l_delta_per_atom:.6f} and app={r_delta_per_atom:.6f}\"\n    )\n\n    # redistribute that delta q over the atoms in the left and right molecule\n    for atom in l_unmatched:\n        atom.charge += l_delta_per_atom\n    for atom in r_unmatched:\n        atom.charge += r_delta_per_atom\n\n    # check if the appearing atoms and the disappearing atoms have the same net charge\n    dis_q_sum = sum(a.charge for a in l_unmatched)\n    app_q_sum = sum(a.charge for a in r_unmatched)\n    logger.debug(\n        f\"Final cumulative charge of the appearing={app_q_sum:.6f}, disappearing={dis_q_sum:.6f} \"\n        f\"alchemical regions\"\n    )\n    if not np.isclose(dis_q_sum, app_q_sum):\n        logger.error(\n            \"The partial charges in app/dis region are not equal to each other. \"\n        )\n        raise Exception(\n            \"The alchemical region in app/dis do not have equal partial charges.\"\n        )\n\n    # note that we are really modifying right now the original nodes.\n    SuperimposedTopology.validate_charges(self.top1, self.top2)\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.contains_same_atoms_symmetric","title":"contains_same_atoms_symmetric","text":"<pre><code>contains_same_atoms_symmetric(other_sup_top)\n</code></pre> <p>The atoms can be paired differently, but they are the same.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def contains_same_atoms_symmetric(self, other_sup_top):\n    \"\"\"\n    The atoms can be paired differently, but they are the same.\n    \"\"\"\n    if len(self.nodes.symmetric_difference(other_sup_top.nodes)) == 0:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of","title":"is_subgraph_of","text":"<pre><code>is_subgraph_of(other_sup_top)\n</code></pre> <p>Checks if this superimposed topology is a subgraph of another superimposed topology. Or if any mirror topology is a subgraph.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_subgraph_of(self, other_sup_top):\n    \"\"\"\n    Checks if this superimposed topology is a subgraph of another superimposed topology.\n    Or if any mirror topology is a subgraph.\n    \"\"\"\n    # subgraph cannot be equivalent self.eq, it is only proper subgraph (ie proper subset)\n    if len(self.matched_pairs) &gt;= len(other_sup_top.matched_pairs):\n        return False\n\n    # self is smaller, so it might be a subgraph\n    if other_sup_top.contains_all(self):\n        return True\n\n    # self is not a subgraph, but it could be a subgraph of one of the mirrors\n    for mirror in self.mirrors:\n        if other_sup_top.contains_all(mirror):\n            return True\n\n    # other is bigger than self, but not a subgraph of self\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.subgraph_relationship","title":"subgraph_relationship","text":"<pre><code>subgraph_relationship(other_sup_top)\n</code></pre> <p>Return 1 if self is a supergraph of other, -1 if self is a subgraph of other 0 if they have the same number of elements (regardless of what the nodes are)</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def subgraph_relationship(self, other_sup_top):\n    \"\"\"\n    Return\n    1 if self is a supergraph of other,\n    -1 if self is a subgraph of other\n    0 if they have the same number of elements (regardless of what the nodes are)\n    \"\"\"\n    if len(self.matched_pairs) == len(other_sup_top.matched_pairs):\n        return 0\n\n    if len(self.matched_pairs) &gt; len(other_sup_top.matched_pairs):\n        # self is bigger than other,\n        # check if self contains all nodes in other\n        if self.contains_all(other_sup_top):\n            return 1\n\n        # other is not a subgraph, but check the mirrors if any of them are\n        for mirror in self.mirrors:\n            if mirror.contains_all(other_sup_top):\n                return 1\n\n        # other is smaller but not a subgraph of this graph or any of its mirrors\n        return 0\n\n    if len(self.matched_pairs) &lt; len(other_sup_top.matched_pairs):\n        # other is bigger, so self might be a subgraph\n        # check if other contains all nodes in self\n        if other_sup_top.contains_all(self):\n            return -1\n\n        # self is not a subgraph, but it could be a subgraph of one of the mirrors\n        for mirror in self.mirrors:\n            if other_sup_top.contains_all(mirror):\n                return -1\n\n        # other is bigger than self, but it is not a subgraph\n        return 0\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.is_mirror_of","title":"is_mirror_of","text":"<pre><code>is_mirror_of(other_sup_top)\n</code></pre> <p>this is a naive check fixme - check if the found superimposed topology is the same (ie the same matches), what then?</p> <p>some of the superimposed topologies represent symmetrical matches, for example, imagine T1A and T1B is a symmetrical version of T2A and T2B, this means that  - the number of nodes in T1A, T1B, T2A, and T2B is the same  - all the nodes in T1A are in T2A,  - all the nodes in T1B are in T2B</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_mirror_of(self, other_sup_top):\n    \"\"\"\n    this is a naive check\n    fixme - check if the found superimposed topology is the same (ie the same matches), what then?\n\n    some of the superimposed topologies represent symmetrical matches,\n    for example, imagine T1A and T1B is a symmetrical version of T2A and T2B,\n    this means that\n     - the number of nodes in T1A, T1B, T2A, and T2B is the same\n     - all the nodes in T1A are in T2A,\n     - all the nodes in T1B are in T2B\n    \"\"\"\n\n    if len(self.matched_pairs) != len(other_sup_top.matched_pairs):\n        return False\n\n    if self.contains_same_atoms_symmetric(other_sup_top):\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.eq","title":"eq","text":"<pre><code>eq(sup_top)\n</code></pre> <p>Check if the superimposed topology is \"the same\". This means that every pair has a corresponding pair in the other topology (but possibly in a different order)</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def eq(self, sup_top):\n    \"\"\"\n    Check if the superimposed topology is \"the same\". This means that every pair has a corresponding pair in the\n    other topology (but possibly in a different order)\n    \"\"\"\n    # fixme - should replace this with networkx\n    if len(self) != len(sup_top):\n        return False\n\n    for pair in self.matched_pairs:\n        # find for every pair the matching pair\n        if not sup_top.contains(pair):\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.SuperimposedTopology.toJSON","title":"toJSON","text":"<pre><code>toJSON()\n</code></pre> <p>\" Extract all the important information and return a json string.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def toJSON(self):\n    \"\"\" \"\n    Extract all the important information and return a json string.\n    \"\"\"\n    summary = {}\n\n    if self.config.unique_atom_names:\n        # renamed atoms, new name : old name\n        summary[\"renamed_atoms\"] = {\n            \"start_ligand\": {(a.name, a.id): a.original_name for a in self.top1},\n            \"end_ligand\": {(a.name, a.id): a.original_name for a in self.top2},\n        }\n\n    # the dual topology information\n    summary[\"superimposition\"] = {\n        \"matched\": {str(n1): str(n2) for n1, n2 in self.matched_pairs},\n        \"matched_id\": {n1.id: n2.id for n1, n2 in self.matched_pairs},\n        \"appearing\": list(map(str, self.get_appearing_atoms())),\n        \"disappearing\": [str(a) for a in self.get_disappearing_atoms()],\n        \"appearing_id\": [a.id for a in self.get_appearing_atoms()],\n        \"disappearing_id\": [a.id for a in self.get_disappearing_atoms()],\n        \"removed\": {  # because of:\n            # replace atoms with their names\n            \"net_charge\": [\n                ((a1.name, a2.name), d)\n                for (a1, a2), d in self._removed_due_to_net_charge\n            ],\n            \"net_charge_id\": [\n                ((a1.id, a2.id), d)\n                for (a1, a2), d in self._removed_due_to_net_charge\n            ],\n            \"pair_q\": [\n                ((a1.name, a2.name), d)\n                for (a1, a2), d in self._removed_pairs_with_charge_difference\n            ],\n            \"pair_q_id\": [\n                ((a1.id, a2.id), d)\n                for (a1, a2), d in self._removed_pairs_with_charge_difference\n            ],\n            \"disjointed\": [\n                ((a1.name, a2.name),)\n                for a1, a2 in self._removed_because_disjointed_cc\n            ],\n            \"disjointed_id\": [\n                ((a1.id, a2.id),) for a1, a2 in self._removed_because_disjointed_cc\n            ],\n            \"bonds\": [\n                ((a1.name, a2.name), d)\n                for (a1, a2), d in self._removed_because_diff_bonds\n            ],\n            \"unmatched_rings\": [\n                ((a1.name, a2.name), d)\n                for (a1, a2), d in self._removed_because_unmatched_rings\n            ],\n        },\n        \"charges_delta\": {\n            \"start_ligand\": {\n                a.name: a.charge - a._original_charge\n                for a in self.top1\n                if a._original_charge != a.charge\n            },\n            \"end_ligand\": {\n                a.name: a.charge - a._original_charge\n                for a in self.top2\n                if a._original_charge != a.charge\n            },\n        },\n    }\n    summary[\"config\"] = self.config.get_serializable()\n    summary[\"internal\"] = \"atoms\"\n\n    return summary\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.get_largest","title":"get_largest","text":"<pre><code>get_largest(lists)\n</code></pre> <p>return a list of largest solutions</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_largest(lists):\n    \"\"\"\n    return a list of largest solutions\n    \"\"\"\n    solution_sizes = [len(st) for st in lists]\n    largest_sol_size = max(solution_sizes)\n    return list(filter(lambda st: len(st) == largest_sol_size, lists))\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.long_merge","title":"long_merge","text":"<pre><code>long_merge(suptop1, suptop2)\n</code></pre> <p>Carry out a merge and apply all checks. Merge suptop2 into suptop1.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def long_merge(suptop1, suptop2):\n    \"\"\"\n    Carry out a merge and apply all checks.\n    Merge suptop2 into suptop1.\n\n    \"\"\"\n    if suptop1 is suptop2:\n        return suptop1\n\n    if suptop1.eq(suptop2):\n        return suptop1\n\n    if suptop2.is_subgraph_of(suptop1):\n        return suptop1\n\n    # check if the two are consistent\n    # ie there is no clashes\n    if not suptop1.is_consistent_with(suptop2):\n        return -1\n\n    # fixme - this can be removed because it is now taken care of in the other functions?\n    # g1, g2 = suptop1.getNxGraphs()\n    # assert len(nx.cycle_basis(g1)) == len(nx.cycle_basis(g2))\n    # g3, g4 = suptop2.getNxGraphs()\n    # assert len(nx.cycle_basis(g3)) == len(nx.cycle_basis(g4))\n    #\n    # assert suptop1.sameCircleNumber()\n    newly_added_pairs = suptop1.merge(suptop2)\n\n    # if not suptop1.sameCircleNumber():\n    #     raise Exception('something off')\n    # # remove sol2 from the solutions:\n    # all_solutions.remove(sol2)\n    return newly_added_pairs\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.merge_compatible_suptops","title":"merge_compatible_suptops","text":"<pre><code>merge_compatible_suptops(suptops)\n</code></pre> <p>Imagine mapping of two carbons C1 and C2 to another pair of carbons C1' and C2'. If C1 was mapped to C1', and C2 to C2', and each craeted a suptop, then we have to join the two suptops.</p> <p>fixme - appears to be doing too many combinations Consider using a queue. Add the new combinations here rather than restarting again and again. You could keep a list of \"combinations\" in a queue, and each time you make a new element,</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def merge_compatible_suptops(suptops):\n    \"\"\"\n    Imagine mapping of two carbons C1 and C2 to another pair of carbons C1' and C2'.\n    If C1 was mapped to C1', and C2 to C2', and each craeted a suptop, then we have to join the two suptops.\n\n    fixme - appears to be doing too many combinations\n    Consider using a queue. Add the new combinations here rather than restarting again and again.\n    You could keep a list of \"combinations\" in a queue, and each time you make a new element,\n\n    \"\"\"\n\n    if len(suptops) == 1:\n        return suptops\n\n    # consier simplifying in case of \"2\"\n\n    # keep track of which suptops have been used to build a bigger one\n    # these can be likely later discarded\n    ingredients = {}\n    excluded = []\n    while True:\n        any_new_suptop = False\n        for st1, st2 in itertools.combinations(suptops, r=2):\n            if {st1, st2} in excluded:\n                continue\n\n            if st1 in ingredients.get(st2, []) or st2 in ingredients.get(st1, []):\n                continue\n\n            if st1.is_subgraph_of(st2) or st2.is_subgraph_of(st1):\n                continue\n\n            # fixme - verify this one\n            if st1.eq(st2):\n                continue\n\n            # check if the two suptops are compatible\n            elif st1.is_consistent_with(st2):\n                # merge them!\n                large_suptop = copy.copy(st1)\n                # add both the pairs and the bonds that are not present in st1\n                large_suptop.merge(st2)\n                suptops.append(large_suptop)\n\n                ingredients[large_suptop] = {st1, st2}.union(\n                    ingredients.get(st1, set())\n                ).union(ingredients.get(st2, set()))\n                excluded.append({st1, st2})\n\n                # break\n                any_new_suptop = True\n\n        if not any_new_suptop:\n            break\n\n    # flatten\n    all_ingredients = list(itertools.chain(*ingredients.values()))\n\n    # return the larger suptops, but not the constituents\n    new_suptops = [st for st in suptops if st not in all_ingredients]\n    return new_suptops\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.superimpose_topologies","title":"superimpose_topologies","text":"<pre><code>superimpose_topologies(top1_nodes, top2_nodes, pair_charge_atol=0.1, use_charges=True, use_coords=True, starting_node_pairs=None, force_mismatch=None, disjoint_components=False, net_charge_filter=True, net_charge_threshold=0.1, redistribute_charges_over_unmatched=True, parmed_ligA=None, parmed_ligB=None, align_molecules=True, partial_rings_allowed=False, ignore_charges_completely=False, ignore_bond_types=True, ignore_coords=False, use_general_type=True, use_only_element=False, starting_pairs_heuristics=0.2, starting_pair_seed=None, logging_key=None, config=None)\n</code></pre> <p>The main function that manages the entire process.</p> <p>TODO: - check if each molecule topology is connected</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def superimpose_topologies(\n    top1_nodes,\n    top2_nodes,\n    pair_charge_atol=0.1,\n    use_charges=True,\n    use_coords=True,\n    starting_node_pairs=None,\n    force_mismatch=None,\n    disjoint_components=False,\n    net_charge_filter=True,\n    net_charge_threshold=0.1,\n    redistribute_charges_over_unmatched=True,\n    parmed_ligA=None,\n    parmed_ligB=None,\n    align_molecules=True,\n    partial_rings_allowed=False,\n    ignore_charges_completely=False,\n    ignore_bond_types=True,\n    ignore_coords=False,\n    use_general_type=True,\n    use_only_element=False,\n    starting_pairs_heuristics=0.2,\n    starting_pair_seed=None,\n    logging_key=None,\n    config=None,\n):\n    \"\"\"\n    The main function that manages the entire process.\n\n    TODO:\n    - check if each molecule topology is connected\n    \"\"\"\n\n    if config is not None and config.logging_breakdown:\n        file_log_handler = logging.FileHandler(config.workdir / f\"{logging_key}.log\")\n        file_log_handler.setLevel(config.logging_level)\n        file_log_handler.setFormatter(config.logging_formatter)\n        logger.addHandler(file_log_handler)\n\n    if not ignore_charges_completely:\n        SuperimposedTopology.validate_charges(top1_nodes, top2_nodes)\n\n    # deal with the situation where the config is not passed\n    if config is None:\n        weights = [1, 1]\n        align_add_removed_mcs = False\n    else:\n        weights = config.weights_ratio\n        align_add_removed_mcs = config.align_add_removed_mcs\n\n    # Get the superimposed topology(/ies).\n    suptops = _superimpose_topologies(\n        top1_nodes,\n        top2_nodes,\n        parmed_ligA,\n        parmed_ligB,\n        starting_node_pairs=starting_node_pairs,\n        ignore_coords=ignore_coords,\n        use_general_type=use_general_type,\n        starting_pairs_heuristics=starting_pairs_heuristics,\n        starting_pairs=starting_pair_seed,\n        weights=weights,\n    )\n    if not suptops:\n        warnings.warn(\"Did not find a single superimposition state.\")\n        return None\n\n    logger.debug(f\"Phase 1: The number of SupTops found: {len(suptops)}\")\n    for i, st in enumerate(suptops):\n        logger.debug(f\"ST - {i} - len: {len(st)} - {st}\")\n\n    # ignore bond types\n    # they are ignored when creating the run file with tleap anyway\n    for st in suptops:\n        # fixme - transition to config\n        st.ignore_bond_types = ignore_bond_types\n\n    # link the suptops to their original molecule data\n    for suptop in suptops:\n        # fixme - transition to config\n        suptop.set_tops(top1_nodes, top2_nodes)\n        suptop.set_parmeds(parmed_ligA, parmed_ligB)\n\n    # align the 3D coordinates before applying further changes\n    # use the largest suptop to align the molecules\n    if align_molecules and not ignore_coords:\n\n        def take_largest(x, y):\n            return x if len(x) &gt; len(y) else y\n\n        reduce(take_largest, suptops).align_ligands_using_mcs()\n        logger.debug(\n            f\"RMSD of the best overlay: {suptops[0].align_ligands_using_mcs():.2f}\"\n        )\n\n    # fixme - you might not need because we are now doing this on the way back\n    # if useCoords:\n    #     for sup_top in sup_tops:\n    #         sup_top.correct_for_coordinates()\n\n    # mismatch atoms as requested\n    if force_mismatch:\n        for sp in suptops:\n            for a1, a2 in sp.matched_pairs[::-1]:\n                if (a1.name, a2.name) in force_mismatch:\n                    sp.remove_node_pair((a1, a2))\n                    logger.debug(f\"Removing the pair: {((a1, a2))}, as requested\")\n\n    # ensure that ring-atoms are not matched to non-ring atoms\n    for st in suptops:\n        st.ringring()\n\n    # introduce exceptions to the atom type types so that certain\n    # different atom types are seen as the same\n    # ie allow to swap cc-cd with cd-cc (and other pairs)\n    for st in suptops:\n        st.match_gaff2_nondirectional_bonds()\n\n    # remove matched atom pairs that have a different specific atom type\n    if not use_only_element:\n        for st in suptops:\n            # fixme - rename\n            st.enforce_matched_atom_types_are_the_same()\n\n    # ensure that the bonds are used correctly.\n    # If the bonds disagree, but atom types are the same, remove both bonded pairs\n    # we cannot have A-B where the bonds are different. In this case, we have A-B=C and A=B-C in a ring,\n    # we could in theory remove A,B,C which makes sense as these will show slightly different behaviour,\n    # and this we we avoid tensions in the bonds, and represent both\n    # fixme - apparently we are not relaying on these?\n    # turned off as this is reflected in the atom type\n    if not ignore_bond_types and False:\n        for st in suptops:\n            removed = st.removeMatchedPairsWithDifferentBonds()\n            if not removed:\n                logger.debug(f\"Removed bonded pairs due to different bonds: {removed}\")\n\n    if not partial_rings_allowed:\n        # remove partial rings, note this is a cascade problem if there are double rings\n        for suptop in suptops:\n            suptop.enforce_no_partial_rings()\n            logger.debug(\n                f\"Removed pairs because partial rings are not allowed {suptop._removed_because_unmatched_rings}\"\n            )\n\n    # note that charges need to be checked before assigning IDs.\n    # ie if charges are different, the matched pair\n    # becomes two different atoms with different IDs\n    if use_charges and not ignore_charges_completely:\n        for sup_top in suptops:\n            removed = sup_top.unmatch_pairs_with_different_charges(\n                atol=pair_charge_atol\n            )\n            if removed:\n                logger.debug(\n                    f\"Removed pairs with charge incompatibility: \"\n                    f\"{[(s[0], f'{s[1]:.3f}') for s in sup_top._removed_pairs_with_charge_difference]}\"\n                )\n\n    if net_charge_filter and not ignore_charges_completely:\n        # Note that we apply this rule to each suptop.\n        # This is because we are only keeping one suptop right now.\n        # However, if disjointed components are allowed, these number might change.\n        # ensure that each suptop component has net charge differences &lt; 0.1\n        # Furthermore, disjointed components has not yet been applied,\n        # even though it might have an effect, fixme - should disjointed be applied first?\n        # to account for this implement #251\n        logger.debug(f\"Accounting for net charge limit of {net_charge_threshold:.3f}\")\n        for suptop in suptops[::-1]:\n            suptop.apply_net_charge_filter(net_charge_threshold)\n\n            # remove the suptop from the list if it's empty\n            if len(suptop) == 0:\n                suptops.remove(suptop)\n                continue\n\n            # Display information\n            if suptop._removed_due_to_net_charge:\n                logger.debug(\n                    f\"SupTop: Removed pairs due to net charge: \"\n                    f\"{[[p[0], f'{p[1]:.3f}'] for p in suptop._removed_due_to_net_charge]}\"\n                )\n\n    # remove the suptops that are empty\n    for st in suptops[::-1]:\n        if len(st) == 0:\n            suptops.remove(st)\n\n    if not disjoint_components:\n        logger.debug(f\"Checking for disjoint components in the {len(suptops)} suptops\")\n        # ensure that each suptop represents one CC\n        # check if the graph was divided after removing any pairs (e.g. due to charge mismatch)\n        # fixme - add the log about which atoms are removed?\n        [st.largest_cc_survives() for st in suptops]\n\n        for st in suptops:\n            logger.debug(\n                f\"Removed disjoint components: {st._removed_because_disjointed_cc}\"\n            )\n\n        # fixme\n        # remove the smaller suptop, or one arbitrary if they are equivalent\n        # if len(suptops) &gt; 1:\n        #     max_len = max([len(suptop) for suptop in suptops])\n        #     for suptop in suptops[::-1]:\n        #         if len(suptop) &lt; max_len:\n        #             suptops.remove(suptop)\n        #\n        #     # if there are equal length suptops left, take only the first one\n        #     if len(suptops) &gt; 1:\n        #         suptops = [suptops[0]]\n        #\n        # assert len(suptops) == 1, suptops\n\n    if len(suptops) == 0:\n        return None\n\n    suptop = extract_best_suptop(\n        suptops, ignore_coords, weights=weights, get_list=False\n    )\n\n    if redistribute_charges_over_unmatched and not ignore_charges_completely:\n        # assume that none of the suptops are disjointed\n        logger.debug(\"Assuming that all suptops are separate at this point\")\n        # fixme: apply distribution of q only on the first st, that's the best one anyway,\n\n        # we only want to apply redistribution once on the largest piece for now\n        suptop.redistribute_charges()\n\n    # atom ID assignment has to come after any removal of atoms due to their mismatching charges\n    suptop.assign_atoms_ids(1)\n\n    # there might be several best solutions, order them according the RMSDs\n    # suptops.sort(key=lambda st: st.rmsd())\n\n    # fixme - remove the hydrogens without attached heavy atoms\n\n    # resolve_sup_top_multiple_match(sup_tops_charges)\n    # sup_top_correct_chirality(sup_tops_charges, sup_tops_no_charges, atol=atol)\n\n    logger.info(\"-------- Summary -----------\")\n    logger.info(\n        f\"Matched pairs: {len(suptop.matched_pairs)} out of {len(top1_nodes)}L/{len(top2_nodes)}R\"\n    )\n    logger.info(\n        f\"Disappearing atoms: {(len(top1_nodes) - len(suptop.matched_pairs)) / len(top1_nodes) * 100:.1f}%\"\n    )\n    logger.info(\n        f\"Appearing atoms: {(len(top2_nodes) - len(suptop.matched_pairs)) / len(top2_nodes) * 100:.1f}%\"\n    )\n\n    # carry out a check. Each\n    if align_molecules and not ignore_coords:\n        main_rmsd = suptop.align_ligands_using_mcs()\n        for mirror in suptop.mirrors:\n            mirror_rmsd = mirror.align_ligands_using_mcs()\n            if mirror_rmsd &lt; main_rmsd:\n                logger.debug(\"THE MIRROR RMSD IS LOWER THAN THE MAIN RMSD\")\n        rmsd = suptop.align_ligands_using_mcs(\n            overwrite_original=True, use_disjointed=align_add_removed_mcs\n        )\n        logger.info(f\"Aligned Common Area RMSD: {rmsd:.2f}\")\n\n    A_minus_B, A_minus_B_max, B_minus_A, B_minus_A_max = (\n        suptop.alchemical_overlap_check()\n    )\n    logger.info(\n        f\"Alchemical Area Overlap:\\n\"\n        f\"\\tRMS(A-B): {A_minus_B:.2f} Angstrom\\n\"\n        f\"\\tmax(A-B): {A_minus_B_max:.2f} Angstrom\\n\"\n        f\"\\tRMS(B-A): {B_minus_A:.2f} Angstrom\\n\"\n        f\"\\tmax(B-A): {B_minus_A_max:.2f} Angstrom\"\n    )\n\n    if config is not None and config.logging_breakdown:\n        logger.removeHandler(file_log_handler)\n\n    return suptop\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.is_mirror_of_one","title":"is_mirror_of_one","text":"<pre><code>is_mirror_of_one(candidate_suptop, suptops, ignore_coords, extract_weight_ratio)\n</code></pre> <p>\"Mirror\" in the sense that it is an alternative topological way to traverse the molecule.</p> <p>extract_weight_ratio: refers to the extract_best_suptop function parameter</p> <p>Depending on the \"better\" fit between the two mirrors, we pick the one that is better.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def is_mirror_of_one(candidate_suptop, suptops, ignore_coords, extract_weight_ratio):\n    \"\"\"\n    \"Mirror\" in the sense that it is an alternative topological way to traverse the molecule.\n\n    extract_weight_ratio: refers to the extract_best_suptop function parameter\n\n    Depending on the \"better\" fit between the two mirrors, we pick the one that is better.\n    \"\"\"\n    for next_suptop in suptops:\n        if next_suptop.is_mirror_of(candidate_suptop):\n            # the suptop saved as the mirror should be the suptop\n            # that is judged to be of a lower quality\n            best_suptop = extract_best_suptop(\n                [candidate_suptop, next_suptop],\n                ignore_coords,\n                weights=extract_weight_ratio,\n            )\n\n            if next_suptop is best_suptop:\n                next_suptop.add_mirror_suptop(candidate_suptop)\n            else:\n                suptops.remove(next_suptop)\n                suptops.append(candidate_suptop)\n\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.generate_nxg_from_list","title":"generate_nxg_from_list","text":"<pre><code>generate_nxg_from_list(atoms)\n</code></pre> <p>Helper function. Generates a graph from a list of atoms @parameter atoms: follow the internal format for atoms</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def generate_nxg_from_list(atoms):\n    \"\"\"\n    Helper function. Generates a graph from a list of atoms\n    @parameter atoms: follow the internal format for atoms\n    \"\"\"\n    g = nx.Graph()\n    # add attoms\n    [g.add_node(a) for a in atoms]\n    # add all the edges\n    for a in atoms:\n        # add the edges from nA\n        for a_bonded in a.bonds:\n            g.add_edge(a, a_bonded.atom)\n\n    return g\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.get_starting_configurations","title":"get_starting_configurations","text":"<pre><code>get_starting_configurations(left_atoms, right_atoms, fraction=0.2, filter_ring_c=True)\n</code></pre> <p>Minimise the number of starting configurations to optimise the process speed. Use:  * the rarity of the specific atom types,  * whether the atoms are bottlenecks (so they do not suffer from symmetry).     The issue with symmetry is that it is impossible to find the proper     symmetry match if you start from the wrong symmetry. @parameter fraction: ensure that the number of atoms used to start the traversal is not more     than the fraction value of the overall number of possible matches, counted as     a fraction of the maximum possible number of pairs (MIN(LEFTNODES, RIGHTNODES)) @parameter filter_ring_c: filter out the carbon elements in the rings to avoid any issues     with the symmetry. This assumes that a ring usually has one N element, etc.</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_starting_configurations(\n    left_atoms, right_atoms, fraction=0.2, filter_ring_c=True\n):\n    \"\"\"\n    Minimise the number of starting configurations to optimise the process speed.\n    Use:\n     * the rarity of the specific atom types,\n     * whether the atoms are bottlenecks (so they do not suffer from symmetry).\n        The issue with symmetry is that it is impossible to find the proper\n        symmetry match if you start from the wrong symmetry.\n    @parameter fraction: ensure that the number of atoms used to start the traversal is not more\n        than the fraction value of the overall number of possible matches, counted as\n        a fraction of the maximum possible number of pairs (MIN(LEFTNODES, RIGHTNODES))\n    @parameter filter_ring_c: filter out the carbon elements in the rings to avoid any issues\n        with the symmetry. This assumes that a ring usually has one N element, etc.\n\n\n    \"\"\"\n    logger.debug(\n        \"Superimposition: optimising the search by narrowing down the starting configuration. \"\n    )\n\n    # ignore hydrogens\n    left_atoms_noh = list(filter(lambda a: a.element != \"H\", left_atoms))\n    right_atoms_noh = list(filter(lambda a: a.element != \"H\", right_atoms))\n\n    # find out which atoms types are common across the two molecules\n    # fixme - consider subclassing atom from MDAnalysis class and adding functions for some of these features\n    # first, find the unique types for each molecule\n    left_types = {left_atom.type for left_atom in left_atoms_noh}\n    right_types = {right_atom.type for right_atom in right_atoms_noh}\n    common_types = left_types.intersection(right_types)\n\n    # for each atom type, check how many maximum atoms can theoretically be matched\n    per_type_max_counter = {}\n    for atom_type in common_types:\n        left_count_by_type = sum(\n            [1 for left_atom in left_atoms if left_atom.type == atom_type]\n        )\n        right_count_by_type = sum(\n            [1 for right_atom in right_atoms if right_atom.type == atom_type]\n        )\n        per_type_max_counter[atom_type] = min(left_count_by_type, right_count_by_type)\n    max_overlap_size = sum(per_type_max_counter.values())\n    logger.debug(f\"Largest MCS size: {max_overlap_size}\")\n\n    left_atoms_starting = left_atoms_noh[:]\n    right_atoms_starting = right_atoms_noh[:]\n\n    # ignore carbons in cycles\n    # fixme - we should not use this for macrocycles, which should be ignored here\n    if filter_ring_c:\n        nxl = generate_nxg_from_list(left_atoms)\n        for cycle in nx.cycle_basis(nxl):\n            # ignore the carbons in the cycle\n            cycle_carbons = list(filter(lambda a: a.element == \"C\", cycle))\n            logger.debug(\n                f\"Superimposition of left atoms: Ignoring carbons as starting configurations because \"\n                f\"they are carbons in a cycle: {cycle_carbons}\"\n            )\n            [\n                left_atoms_starting.remove(a)\n                for a in cycle_carbons\n                if a in left_atoms_starting\n            ]\n        nxr = generate_nxg_from_list(right_atoms_starting)\n        for cycle in nx.cycle_basis(nxr):\n            # ignore the carbons in the cycle\n            cycle_carbons = list(filter(lambda a: a.element == \"C\", cycle))\n            logger.debug(\n                f\"Superimposition of right atoms: Ignoring carbons as starting configurations because \"\n                f\"they are carbons in a cycle: {cycle_carbons}\"\n            )\n            [\n                right_atoms_starting.remove(a)\n                for a in cycle_carbons\n                if a in right_atoms_starting\n            ]\n\n    # find out which atoms types are common across the two molecules\n    # fixme - consider subclassing atom from MDAnalysis class and adding functions for some of these features\n    # first, find the unique types for each molecule\n    left_types = {left_atom.type for left_atom in left_atoms_starting}\n    right_types = {right_atom.type for right_atom in right_atoms_starting}\n    common_types = left_types.intersection(right_types)\n\n    # for each atom type, check how many maximum atoms can theoretically be matched\n    paired_by_type = []\n    max_after_cycle_carbons = 0\n    for atom_type in common_types:\n        picked_left = list(filter(lambda a: a.type == atom_type, left_atoms_starting))\n        picked_right = list(filter(lambda a: a.type == atom_type, right_atoms_starting))\n        paired_by_type.append([picked_left, picked_right])\n        max_after_cycle_carbons += min(len(picked_left), len(picked_right))\n    logger.debug(\n        f\"Superimposition: simple max match of atoms after cycle carbons exclusion: {max_after_cycle_carbons}\"\n    )\n\n    # sort atom according to their type rarity\n    # use the min across, since 1x4 mapping will give 4 options only, so we count this as one,\n    # but 4x4 would give 16,\n    sorted_paired_by_type = sorted(\n        paired_by_type, key=lambda p: min(len(p[0]), len(p[1]))\n    )\n\n    # find the atoms in each type and generate appropriate pairs,\n    # use only a fraction of the maximum theoretical match\n    desired_number_of_pairs = int(fraction * max_overlap_size)\n\n    starting_configurations = []\n    added_counter = 0\n    for rare_left_atoms, rare_right_atoms in sorted_paired_by_type:\n        # starting_configurations\n        starting_configurations.extend(\n            list(itertools.product(rare_left_atoms, rare_right_atoms))\n        )\n        added_counter += min(len(rare_left_atoms), len(rare_right_atoms))\n        if added_counter &gt; desired_number_of_pairs:\n            break\n\n    logger.debug(\n        f\"Superimposition: initial starting pairs for the search: {starting_configurations}\"\n    )\n    return starting_configurations\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.get_atoms_bonds_from_file","title":"get_atoms_bonds_from_file","text":"<pre><code>get_atoms_bonds_from_file(ref_filename, mob_filename, use_general_type=True)\n</code></pre> <p>Use Parmed to load the files.</p>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.get_atoms_bonds_from_file--returns","title":"returns","text":""},{"location":"reference/topology_superimposer/#ties.topology_superimposer.get_atoms_bonds_from_file--1-a-dictionary-with-charges-eg-item-c17-0222903","title":"1) a dictionary with charges, e.g. Item: \"C17\" : -0.222903","text":""},{"location":"reference/topology_superimposer/#ties.topology_superimposer.get_atoms_bonds_from_file--2-a-list-of-bonds","title":"2) a list of bonds","text":"Source code in <code>ties/topology_superimposer.py</code> <pre><code>def get_atoms_bonds_from_file(ref_filename, mob_filename, use_general_type=True):\n    \"\"\"\n    Use Parmed to load the files.\n\n    # returns\n    # 1) a dictionary with charges, e.g. Item: \"C17\" : -0.222903\n    # 2) a list of bonds\n    \"\"\"\n\n    universe_ref_atoms, universe_ref_bonds, ref = get_atoms_bonds_and_parmed_structure(\n        ref_filename, use_general_type=use_general_type\n    )\n    universe_mob_atoms, universe_mob_bonds, mobile = (\n        get_atoms_bonds_and_parmed_structure(\n            mob_filename, use_general_type=use_general_type\n        )\n    )\n\n    return (\n        universe_ref_atoms,\n        universe_ref_bonds,\n        universe_mob_atoms,\n        universe_mob_bonds,\n        ref,\n        mobile,\n    )\n</code></pre>"},{"location":"reference/topology_superimposer/#ties.topology_superimposer.assign_coords_from_pdb","title":"assign_coords_from_pdb","text":"<pre><code>assign_coords_from_pdb(atoms, pdb_atoms)\n</code></pre> <p>Match the atoms from the ParmEd object based on a .pdb file and overwrite the coordinates from ParmEd. :param atoms: internal Atom representation (fixme: refer to it here in docu),     will have their coordinates overwritten. :param pdb_atoms: atoms loaded with ParmEd with the coordinates to be used</p> Source code in <code>ties/topology_superimposer.py</code> <pre><code>def assign_coords_from_pdb(atoms, pdb_atoms):\n    \"\"\"\n    Match the atoms from the ParmEd object based on a .pdb file\n    and overwrite the coordinates from ParmEd.\n    :param atoms: internal Atom representation (fixme: refer to it here in docu),\n        will have their coordinates overwritten.\n    :param pdb_atoms: atoms loaded with ParmEd with the coordinates to be used\n\n    \"\"\"\n    for atom in atoms:\n        # find the corresponding atom\n        found_match = False\n        for pdb_atom in pdb_atoms.atoms:\n            if pdb_atom.name.upper() == atom.name.upper():\n                # charges?\n                atom.position = (pdb_atom.xx, pdb_atom.xy, pdb_atom.xz)\n                found_match = True\n                break\n        if not found_match:\n            logger.error(f\"Did not find atom? {atom.name}\")\n            raise Exception(\"wait a minute\")\n</code></pre>"},{"location":"reference/bb/","title":"Index","text":""},{"location":"reference/bb/#ties.bb","title":"bb","text":"<p>Modules:</p> <ul> <li> <code>atom</code>           \u2013            </li> <li> <code>gaff_atom_types</code>           \u2013            </li> </ul>"},{"location":"reference/bb/atom/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> atom","text":""},{"location":"reference/bb/atom/#ties.bb.atom","title":"atom","text":"<p>Classes:</p> <ul> <li> <code>Atom</code>           \u2013            </li> </ul>"},{"location":"reference/bb/atom/#ties.bb.atom.Atom","title":"Atom","text":"<pre><code>Atom(name, atom_type, charge=0, use_general_type=False)\n</code></pre> <p>Methods:</p> <ul> <li> <code>eq</code>             \u2013              <p>Check if the atoms are of the same type and have a charge within the given absolute tolerance.</p> </li> <li> <code>united_eq</code>             \u2013              <p>Like .eq, but treat the atoms as united atoms.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>united_charge</code>           \u2013            <p>United atom charge: summed charges of this atom and the bonded hydrogens.</p> </li> </ul> Source code in <code>ties/bb/atom.py</code> <pre><code>def __init__(self, name, atom_type, charge=0, use_general_type=False):\n    self._original_name = None\n\n    self._id = None\n    self.name = name\n    self._original_name = name.upper()\n    self.type = atom_type\n\n    self._resname = None\n    self.charge = charge\n    self._original_charge = charge\n\n    self.resid = None\n    self.bonds: Bonds = Bonds()\n    self.use_general_type = use_general_type\n    self.hash_value = None\n\n    self._unique_counter = Atom.counter\n    Atom.counter += 1\n</code></pre>"},{"location":"reference/bb/atom/#ties.bb.atom.Atom.united_charge","title":"united_charge  <code>property</code>","text":"<pre><code>united_charge\n</code></pre> <p>United atom charge: summed charges of this atom and the bonded hydrogens.</p>"},{"location":"reference/bb/atom/#ties.bb.atom.Atom.eq","title":"eq","text":"<pre><code>eq(atom, atol=0)\n</code></pre> <p>Check if the atoms are of the same type and have a charge within the given absolute tolerance.</p> Source code in <code>ties/bb/atom.py</code> <pre><code>def eq(self, atom, atol=0):\n    \"\"\"\n    Check if the atoms are of the same type and have a charge within the given absolute tolerance.\n    \"\"\"\n    if self.type == atom.type and np.isclose(self.charge, atom.charge, atol=atol):\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/bb/atom/#ties.bb.atom.Atom.united_eq","title":"united_eq","text":"<pre><code>united_eq(atom, atol=0)\n</code></pre> <p>Like .eq, but treat the atoms as united atoms. Check if the atoms have the same atom type, and if if their charges are within the absolute tolerance. If the atoms have hydrogens, add up the attached hydrogens and use a united atom representation.</p> Source code in <code>ties/bb/atom.py</code> <pre><code>def united_eq(self, atom, atol=0):\n    \"\"\"\n    Like .eq, but treat the atoms as united atoms.\n    Check if the atoms have the same atom type, and\n    if if their charges are within the absolute tolerance.\n    If the atoms have hydrogens, add up the attached hydrogens and use a united atom representation.\n    \"\"\"\n    if self.type != atom.type:\n        return False\n\n    if not np.isclose(self.united_charge, atom.united_charge, atol=atol):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/bb/bond/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> bond","text":""},{"location":"reference/bb/bond/#ties.bb.bond","title":"bond","text":""},{"location":"reference/bb/gaff_atom_types/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> gaff_atom_types","text":""},{"location":"reference/bb/gaff_atom_types/#ties.bb.gaff_atom_types","title":"gaff_atom_types","text":""},{"location":"reference/docking/","title":"Index","text":""},{"location":"reference/docking/#ties.docking","title":"docking","text":"<p>Modules:</p> <ul> <li> <code>fit</code>           \u2013            <p>Use FEgrow for MCS docking, with TIES for the MCS.</p> </li> <li> <code>mol2sdf</code>           \u2013            <p>Convert MOL2 to SDF file.</p> </li> <li> <code>prep</code>           \u2013            <p>Prepare the structures from smiles:</p> </li> <li> <code>rdmcs</code>           \u2013            <p>Use RDKit to find the MCS score.</p> </li> <li> <code>score</code>           \u2013            <p>Score conformers in the binding pocket using MM potential energy.</p> </li> <li> <code>sdf2mol2</code>           \u2013            <p>Convert SDF to .MOL2 file.</p> </li> </ul>"},{"location":"reference/docking/fit/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fit","text":""},{"location":"reference/docking/fit/#ties.docking.fit","title":"fit","text":"<p>Use FEgrow for MCS docking, with TIES for the MCS.</p> <p>Functions:</p> <ul> <li> <code>load_conformers</code>             \u2013              <p>Load the SDF as one mol with many conformers</p> </li> </ul>"},{"location":"reference/docking/fit/#ties.docking.fit.load_conformers","title":"load_conformers","text":"<pre><code>load_conformers(sdf) -&gt; Mol\n</code></pre> <p>Load the SDF as one mol with many conformers</p> Source code in <code>ties/docking/fit.py</code> <pre><code>def load_conformers(sdf) -&gt; Chem.Mol:\n    \"\"\"\n    Load the SDF as one mol with many conformers\n    \"\"\"\n    mol = None\n    for conf in Chem.SDMolSupplier(sdf, removeHs=False):\n        if mol is None:\n            mol = conf\n\n        mol.AddConformer(conf.GetConformer(), assignId=True)\n\n    return mol\n</code></pre>"},{"location":"reference/docking/mol2sdf/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mol2sdf","text":""},{"location":"reference/docking/mol2sdf/#ties.docking.mol2sdf","title":"mol2sdf","text":"<p>Convert MOL2 to SDF file.</p> <p>Extract the charges and the atom types and save them in the properties.</p>"},{"location":"reference/docking/prep/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> prep","text":""},{"location":"reference/docking/prep/#ties.docking.prep","title":"prep","text":"Prepare the structures from smiles <ul> <li>assign charges</li> <li>create a low energy conformer (minimised)</li> </ul> <p>Use OpenFF stack.</p> Room for improvement <ul> <li>protein binding pocket aware protonation</li> </ul>"},{"location":"reference/docking/rdmcs/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> rdmcs","text":""},{"location":"reference/docking/rdmcs/#ties.docking.rdmcs","title":"rdmcs","text":"<p>Use RDKit to find the MCS score.</p>"},{"location":"reference/docking/score/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> score","text":""},{"location":"reference/docking/score/#ties.docking.score","title":"score","text":"<p>Score conformers in the binding pocket using MM potential energy.</p> <p>Functions:</p> <ul> <li> <code>extract_best_conformer</code>             \u2013              <p>:param mol_mol2: Should contain all the conformers for evaluation</p> </li> </ul>"},{"location":"reference/docking/score/#ties.docking.score.extract_best_conformer","title":"extract_best_conformer","text":"<pre><code>extract_best_conformer(mol: Mol, prody_protein, protein_pdb='fe_rec_final.pdb')\n</code></pre> <p>:param mol_mol2: Should contain all the conformers for evaluation :param prody_protein: :param protein_pdb: :return:</p> Source code in <code>ties/docking/score.py</code> <pre><code>def extract_best_conformer(\n    mol: Chem.Mol, prody_protein, protein_pdb=\"fe_rec_final.pdb\"\n):\n    \"\"\"\n\n    :param mol_mol2: Should contain all the conformers for evaluation\n    :param prody_protein:\n    :param protein_pdb:\n    :return:\n    \"\"\"\n    # convert to FEgrow RMol\n    rmol = fegrow.RMol(mol)\n    rmol.remove_clashing_confs(prody_protein, min_dst_allowed=0.5)\n\n    if rmol.GetNumConformers() == 0:\n        print(\"Warning: no conformers for energy minimisation: \", rmol.GetProp(\"_Name\"))\n        return\n\n    # extract the mcs mapping\n    # we will freeze the MCS area in the ligand before optimisation\n\n    mcs = literal_eval(rmol.GetProp(\"MCS(ref,lig)\"))\n    # extract\n    ligand_atoms_to_freeze = [idx for _, idx in mcs]\n\n    energies = rmol.optimise_in_receptor(\n        receptor_file=protein_pdb,\n        ligand_force_field=\"openff\",\n        use_ani=False,\n        sigma_scale_factor=0.8,\n        relative_permittivity=4,\n        water_model=None,\n        platform_name=\"CPU\",  # or e.g. 'CUDA'\n        ligand_indices_to_freeze=ligand_atoms_to_freeze,\n    )\n\n    # save the lowest energy conformer\n    best = energies[energies.Energy == energies.Energy.min()]\n    best_conf_id = int(best.index.values[0])\n    # print(f\"Optimised, {time.time() - start:.2f}s\")\n\n    # keep the lowest energy conformer\n    for conf in list(rmol.GetConformers()):\n        if conf.GetId() != best_conf_id:\n            rmol.RemoveConformer(conf.GetId())\n\n    return rmol\n</code></pre>"},{"location":"reference/docking/sdf2mol2/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> sdf2mol2","text":""},{"location":"reference/docking/sdf2mol2/#ties.docking.sdf2mol2","title":"sdf2mol2","text":"<p>Convert SDF to .MOL2 file.</p> <p>Extract the charges and the atom types from the properties.</p>"},{"location":"usage/api/","title":"Examples - Python","text":"<p>TIES also offers a python API. Here is a minimal example: </p> <pre><code>from ties import Pair\n\n# load the two ligands and use the default configuration\npair = Pair('l02.mol2', 'l03.mol2')\n# superimpose the ligands passed above\nhybrid = pair.superimpose()\n\n# save the results\nhybrid.write_metadata('meta_l02_l03.json')\nhybrid.write_pdb('l02_l03_morph.pdb')\nhybrid.write_mol2('l02_l03_morph.mol2')\n</code></pre> <p>This minimal example can be extended with the protein to generate the input for the TIES_MD package for the simulations in either NAMD or OpenMM.</p> <p>Note that in this example we do not set any explicit settings. For that we need to employ the Config class which we can then pass to the Pair.</p> <p>Info</p> <p><code>Config</code> contains the settings for all classes in the TIES package, and  therefore can be used to define a protocol.</p> <p>Whereas all settings can be done in :class:<code>Config</code>, for clarity some can be passed separately here to the :class:<code>Pair</code>. This way, it overwrites the settings in the <code>config</code> object:</p> <pre><code>from ties import Pair\nfrom ties import Config\nfrom ties import Protein\n\n\nconfig = Config()\n# configure the two settings\nconfig.workdir = 'ties20'\nconfig.md_engine = 'openmm'\n# set ligand_net_charge as a parameter,\n# which is equivalent to using config.ligand_net_charge\npair = Pair('l02.mol2', 'l03.mol2', ligand_net_charge=-1, config=config)\n# rename atoms to help with any issues\npair.make_atom_names_unique()\n\nhybrid = pair.superimpose()\n\n# save meta data to files\nhybrid.write_metadata()\nhybrid.write_pdb()\nhybrid.write_mol2()\n\n# add the protein for the full RBFE protocol\nconfig.protein = 'protein.pdb'\nconfig.protein_ff = 'leaprc.protein.ff14SB'\nprotein = Protein(config.protein, config)\nhybrid.prepare_inputs(protein=protein)\n</code></pre> <p>Below we show the variation in which we are using :class:<code>Config</code> to pass the net charge of the molecule.</p> <pre><code>from ties import Pair\nfrom ties import Config\n\n# explicitly create config (which will be used by all classes underneath)\nconfig = Config()\nconfig.ligand_net_charge = -1\n\npair = Pair('l02.mol2', 'l03.mol2', config=config)\npair.make_atom_names_unique()\n\n# overwrite the previous config settings with relevant parameters\nhybrid = pair.superimpose(use_element_in_superimposition=True, redistribute_q_over_unmatched=True)\n\n# save meta data to specific locations\nhybrid.write_metadata('result.json')\nhybrid.write_pdb('result.pdb')\nhybrid.write_mol2('result.mol2')\n\nhybrid.prepare_inputs()\n</code></pre> <p>Note that there is also the :class:<code>Ligand</code> that supports additional operations, and can be passed directly to :class:<code>Ligand</code>.</p> <pre><code>from ties import Ligand\n\n\nlig = Ligand('l02_same_atom_name.mol2')\n\n# prepare the .mol2 input\nlig.antechamber_prepare_mol2()\n\n# the final .mol2 file\nassert lig.current.exists()\n</code></pre>"},{"location":"usage/cli/","title":"CLI","text":"<p>TIES can be access via both command line and python interface.</p> <p>In the smallest example one can carry out a superimposition  employing only two ligands <pre><code>ties --ligands l03.mol2 l02.mol2\n</code></pre></p> <p>Ideally these .mol2 files already have a  pre-assigned charges in the last column for each atom.  See for example MCL1 case.</p> <p>In the case of this example, we are working on molecules  that are negatively charges (-1e), and we need to specify it: <pre><code>ties --ligands l03.mol2 l02.mol2 --ligand-net-charge -1\n</code></pre></p> <p>The order the of the ligands matters and more ligands can be passed.  This command creates by default a <code>ties-input</code> directory with all output  files. These include <code>meta_*_*.json</code> files which contain the  details about how the ligands were superimposed, and what  configuration was used. The general directory structure  will look like this:</p> <pre><code>    ties\n    \u251c\u2500\u2500 mol2\n    \u2502    \u251c\u2500\u2500 l02\n    \u2502    \u2514\u2500\u2500 l03\n    \u251c\u2500\u2500 prep\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 ligand_frcmods\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 l02\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 l03\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 morph_frcmods\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 tests\n    \u2502\u00a0\u00a0         \u2514\u2500\u2500 l02_l03\n    \u2514\u2500\u2500 ties-l02-l03\n        \u2514\u2500\u2500 lig\n            \u2514\u2500\u2500 build\n</code></pre> <p>Note that all the output generated by ambertools is stored,  and can be investigated.</p> <p>The full RBFE requires also the protein, as well  as the net charge of the ligands used in the transformation: <pre><code>ties -l l02.mol2 l03.mol2 -nc -1 --protein protein.pdb\n</code></pre></p> <p>Check all the options with <pre><code>ties -h\n</code></pre></p> <p>Warning</p> <p>This code is currently experimental and under active development. If you notice any problems, report them. *</p>"}]}