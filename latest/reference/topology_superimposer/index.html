
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Software for Relative Binding Free Energy calculations">
      
      
      
        <link rel="canonical" href="https://github.com/UCL-CCS/TIES/latest/reference/topology_superimposer/">
      
      
        <link rel="prev" href="../protein/">
      
      
        <link rel="next" href="../../theory/">
      
      
      <link rel="icon" href="../../images/favicon-32x32.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.4">
    
    
      
        <title>topology_superimposer - TIES</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#ties.topology_superimposer" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="TIES" class="md-header__button md-logo" aria-label="TIES" data-md-component="logo">
      
  <img src="../../images/android-chrome-192x192.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            TIES
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> topology_superimposer
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/UCL-CCS/TIES" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    UCL-CCS/TIES
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../.." class="md-tabs__link">
          
  
    
  
  Home

        </a>
      </li>
    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../installation/" class="md-tabs__link">
        
  
    
  
  Installation

      </a>
    </li>
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../publications/" class="md-tabs__link">
        
  
    
  
  Publications

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../usage/cli/" class="md-tabs__link">
          
  
    
  
  Usage

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../api/ligand/" class="md-tabs__link">
          
  
    
  
  API reference

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../theory/" class="md-tabs__link">
          
  
    
  
  Theory

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="TIES" class="md-nav__button md-logo" aria-label="TIES" data-md-component="logo">
      
  <img src="../../images/android-chrome-192x192.png" alt="logo">

    </a>
    TIES
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/UCL-CCS/TIES" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    UCL-CCS/TIES
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../.." class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Home
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../installation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../publications/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Publications
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Usage
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/cli/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLI
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="">
            
  
  <span class="md-ellipsis">
    API reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            API reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../api/ligand/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ligand
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../api/pair/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pair
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../api/config/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Config
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
      
        
      
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_4" checked>
        
          
          <label class="md-nav__link" for="__nav_5_4" id="__nav_5_4_label" tabindex="">
            
  
  <span class="md-ellipsis">
    All
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5_4">
            <span class="md-nav__icon md-icon"></span>
            All
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_4_1" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> ties
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_5_4_1" id="__nav_5_4_1_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_4_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5_4_1">
            <span class="md-nav__icon md-icon"></span>
            <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> ties
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> analysis
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../cli/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> cli
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../config/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> config
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../generator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> generator
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../helpers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> helpers
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ligand/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> ligand
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ligandmap/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> ligandmap
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../md/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> md
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../namd_generator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> namd_generator
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../pair/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> pair
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../protein/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> protein
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> topology_superimposer
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> topology_superimposer
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-class"></code>&nbsp;Atom
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" Atom">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom.united_charge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-attribute"></code>&nbsp;united_charge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom.eq" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom.united_eq" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;united_eq
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.AtomPair" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-class"></code>&nbsp;AtomPair
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-class"></code>&nbsp;SuperimposedTopology
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" SuperimposedTopology">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.mcs_score" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;mcs_score
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.write_metadata" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;write_metadata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.write_pdb" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;write_pdb
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.write_mol2" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;write_mol2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._init_nonoverlapping_cycles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_init_nonoverlapping_cycles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_single_topology_region" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_single_topology_region
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_single_topology_app" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_single_topology_app
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.ringring" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;ringring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_or_was_matched" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_or_was_matched
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_unmatched_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_unmatched_atoms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_unique_atom_count" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_unique_atom_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.align_ligands_using_mcs" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;align_ligands_using_mcs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.rm_matched_pairs_with_different_bonds" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;rm_matched_pairs_with_different_bonds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_dual_topology_bonds" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_dual_topology_bonds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.largest_cc_survives" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;largest_cc_survives
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.assign_atoms_ids" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;assign_atoms_ids
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_appearing_atoms
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_appearing_atoms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_disappearing_atoms
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_disappearing_atoms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-update-to-using-the-node-set" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - update to using the node set
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.remove_lonely_hydrogens" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;remove_lonely_hydrogens
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.match_gaff2_nondirectional_bonds" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;match_gaff2_nondirectional_bonds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_net_charge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_net_charge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_matched_with_diff_q" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_matched_with_diff_q
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;apply_net_charge_filter
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" apply_net_charge_filter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter--specifically-create-copies-for-each-strategy-here-and-try-a-couple-of-them" class="md-nav__link">
    <span class="md-ellipsis">
      Specifically, create copies for each strategy here and try a couple of them.
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._smart_netqtol_pair_picker" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_smart_netqtol_pair_picker
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._sort_pairs_into_categories_qnettol" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_sort_pairs_into_categories_qnettol
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.remove_attached_hydrogens" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;remove_attached_hydrogens
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_lowest_rmsd_mirror" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;find_lowest_rmsd_mirror
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of_global_top" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_subgraph_of_global_top
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.rmsd" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;rmsd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.link_pairs" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;link_pairs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;find_mirror_choices
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" find_mirror_choices">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--ie-ignore-x-b1-search-if-we-repair-from-a-to-b-then-b-to-a-should-be-repaired-too" class="md-nav__link">
    <span class="md-ellipsis">
      ie Ignore (X, B1) search, if we repair from A to B, then B to A should be repaired too
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--fixme-is-this-still-necessary-if-we-are-traversing-all-paths" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - is this still necessary if we are traversing all paths?
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.add_alternative_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;add_alternative_mapping
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;correct_for_coordinates
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" correct_for_coordinates">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates--fixme-ensure-that-each-node-is-used-only-once-at-the-end" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - ensure that each node is used only once at the end
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.enforce_no_partial_rings" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;enforce_no_partial_rings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_remove_unmatched_ring_atoms
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" _remove_unmatched_ring_atoms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_topology_similarity_score
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_topology_similarity_score">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score--fixme-maybe-you-should-use-the-entire-graphs-in-order-to-see-if-this-is-good-or-not" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - maybe you should use the entire graphs in order to see if this is good or not?
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.unmatch_pairs_with_different_charges" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;unmatch_pairs_with_different_charges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_consistent_with" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_consistent_with
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._rename_ligand" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_rename_ligand
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._get_atom_names_counter" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_get_atom_names_counter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_circles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_circles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_original_circles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_original_circles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._get_original_circle" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_get_original_circle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.cycle_spans_multiple_cycles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;cycle_spans_multiple_cycles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.merge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;merge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.validate_charges" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;validate_charges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.redistribute_charges" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;redistribute_charges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.contains_same_atoms_symmetric" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;contains_same_atoms_symmetric
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_subgraph_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.subgraph_relationship" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;subgraph_relationship
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_mirror_of" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_mirror_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.eq" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.toJSON" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;toJSON
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_largest" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;get_largest
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.long_merge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;long_merge
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.merge_compatible_suptops" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;merge_compatible_suptops
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.merge_compatible_suptops_faster" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;merge_compatible_suptops_faster
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer._overlay" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;_overlay
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.superimpose_topologies" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;superimpose_topologies
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.extract_best_suptop" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;extract_best_suptop
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.is_mirror_of_one" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;is_mirror_of_one
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.generate_nxg_from_list" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;generate_nxg_from_list
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_starting_configurations" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;get_starting_configurations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer._superimpose_topologies" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;_superimpose_topologies
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;get_atoms_bonds_from_mol2
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_atoms_bonds_from_mol2">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2--returns" class="md-nav__link">
    <span class="md-ellipsis">
      returns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2--1-a-dictionary-with-charges-eg-item-c17-0222903" class="md-nav__link">
    <span class="md-ellipsis">
      1) a dictionary with charges, e.g. Item: "C17" : -0.222903
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2--2-a-list-of-bonds" class="md-nav__link">
    <span class="md-ellipsis">
      2) a list of bonds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.assign_coords_from_pdb" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;assign_coords_from_pdb
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Theory
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Theory
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../theory/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Theory
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../superimposition/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Superimposition
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-class"></code>&nbsp;Atom
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" Atom">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom.united_charge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-attribute"></code>&nbsp;united_charge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom.eq" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.Atom.united_eq" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;united_eq
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.AtomPair" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-class"></code>&nbsp;AtomPair
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-class"></code>&nbsp;SuperimposedTopology
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" SuperimposedTopology">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.mcs_score" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;mcs_score
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.write_metadata" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;write_metadata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.write_pdb" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;write_pdb
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.write_mol2" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;write_mol2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._init_nonoverlapping_cycles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_init_nonoverlapping_cycles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_single_topology_region" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_single_topology_region
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_single_topology_app" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_single_topology_app
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.ringring" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;ringring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_or_was_matched" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_or_was_matched
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_unmatched_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_unmatched_atoms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_unique_atom_count" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_unique_atom_count
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.align_ligands_using_mcs" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;align_ligands_using_mcs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.rm_matched_pairs_with_different_bonds" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;rm_matched_pairs_with_different_bonds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_dual_topology_bonds" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_dual_topology_bonds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.largest_cc_survives" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;largest_cc_survives
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.assign_atoms_ids" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;assign_atoms_ids
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_appearing_atoms
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_appearing_atoms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_disappearing_atoms
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_disappearing_atoms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-should-check-first-if-atomname-is-unique" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - should check first if atomName is unique
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-update-to-using-the-node-set" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - update to using the node set
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.remove_lonely_hydrogens" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;remove_lonely_hydrogens
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.match_gaff2_nondirectional_bonds" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;match_gaff2_nondirectional_bonds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_net_charge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_net_charge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_matched_with_diff_q" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_matched_with_diff_q
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;apply_net_charge_filter
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" apply_net_charge_filter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter--specifically-create-copies-for-each-strategy-here-and-try-a-couple-of-them" class="md-nav__link">
    <span class="md-ellipsis">
      Specifically, create copies for each strategy here and try a couple of them.
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._smart_netqtol_pair_picker" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_smart_netqtol_pair_picker
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._sort_pairs_into_categories_qnettol" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_sort_pairs_into_categories_qnettol
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.remove_attached_hydrogens" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;remove_attached_hydrogens
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_lowest_rmsd_mirror" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;find_lowest_rmsd_mirror
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of_global_top" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_subgraph_of_global_top
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.rmsd" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;rmsd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.link_pairs" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;link_pairs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;find_mirror_choices
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" find_mirror_choices">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--ie-ignore-x-b1-search-if-we-repair-from-a-to-b-then-b-to-a-should-be-repaired-too" class="md-nav__link">
    <span class="md-ellipsis">
      ie Ignore (X, B1) search, if we repair from A to B, then B to A should be repaired too
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--fixme-is-this-still-necessary-if-we-are-traversing-all-paths" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - is this still necessary if we are traversing all paths?
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.add_alternative_mapping" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;add_alternative_mapping
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;correct_for_coordinates
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" correct_for_coordinates">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates--fixme-ensure-that-each-node-is-used-only-once-at-the-end" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - ensure that each node is used only once at the end
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.enforce_no_partial_rings" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;enforce_no_partial_rings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_remove_unmatched_ring_atoms
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" _remove_unmatched_ring_atoms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_topology_similarity_score
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_topology_similarity_score">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score--fixme-maybe-you-should-use-the-entire-graphs-in-order-to-see-if-this-is-good-or-not" class="md-nav__link">
    <span class="md-ellipsis">
      fixme - maybe you should use the entire graphs in order to see if this is good or not?
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.unmatch_pairs_with_different_charges" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;unmatch_pairs_with_different_charges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_consistent_with" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_consistent_with
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._rename_ligand" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_rename_ligand
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._get_atom_names_counter" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_get_atom_names_counter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_circles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_circles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.get_original_circles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;get_original_circles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology._get_original_circle" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;_get_original_circle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.cycle_spans_multiple_cycles" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;cycle_spans_multiple_cycles
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.merge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;merge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.validate_charges" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;validate_charges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.redistribute_charges" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;redistribute_charges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.contains_same_atoms_symmetric" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;contains_same_atoms_symmetric
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_subgraph_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.subgraph_relationship" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;subgraph_relationship
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.is_mirror_of" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;is_mirror_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.eq" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;eq
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.SuperimposedTopology.toJSON" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-method"></code>&nbsp;toJSON
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_largest" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;get_largest
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.long_merge" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;long_merge
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.merge_compatible_suptops" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;merge_compatible_suptops
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.merge_compatible_suptops_faster" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;merge_compatible_suptops_faster
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer._overlay" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;_overlay
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.superimpose_topologies" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;superimpose_topologies
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.extract_best_suptop" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;extract_best_suptop
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.is_mirror_of_one" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;is_mirror_of_one
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.generate_nxg_from_list" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;generate_nxg_from_list
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_starting_configurations" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;get_starting_configurations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer._superimpose_topologies" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;_superimpose_topologies
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;get_atoms_bonds_from_mol2
    </span>
  </a>
  
    <nav class="md-nav" aria-label=" get_atoms_bonds_from_mol2">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2--returns" class="md-nav__link">
    <span class="md-ellipsis">
      returns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2--1-a-dictionary-with-charges-eg-item-c17-0222903" class="md-nav__link">
    <span class="md-ellipsis">
      1) a dictionary with charges, e.g. Item: "C17" : -0.222903
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ties.topology_superimposer.get_atoms_bonds_from_mol2--2-a-list-of-bonds" class="md-nav__link">
    <span class="md-ellipsis">
      2) a list of bonds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ties.topology_superimposer.assign_coords_from_pdb" class="md-nav__link">
    <span class="md-ellipsis">
      <code class="doc-symbol doc-symbol-toc doc-symbol-function"></code>&nbsp;assign_coords_from_pdb
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<div class="doc doc-object doc-module">



<h1 id="ties.topology_superimposer" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-module"></code>            <span class="doc doc-object-name doc-module-name">topology_superimposer</span>


</h1>

    <div class="doc doc-contents first">

        <p>The main module responsible for the superimposition.</p>







<p><span class="doc-section-title">Classes:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.Atom" href="#ties.topology_superimposer.Atom">Atom</a></code></b>
          –
          <div class="doc-md-description">
            
          </div>
        </li>
        <li class="doc-section-item field-body">
          <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.AtomPair" href="#ties.topology_superimposer.AtomPair">AtomPair</a></code></b>
          –
          <div class="doc-md-description">
            <p>An atom pair for networkx.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology" href="#ties.topology_superimposer.SuperimposedTopology">SuperimposedTopology</a></code></b>
          –
          <div class="doc-md-description">
            <p>SuperimposedTopology contains in the minimal case two sets of nodes S1 and S2, which</p>
          </div>
        </li>
    </ul>




<p><span class="doc-section-title">Functions:</span></p>
    <ul>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.get_largest" href="#ties.topology_superimposer.get_largest">get_largest</a></code></b>
            –
            <div class="doc-md-description">
              <p>return a list of largest solutions</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.long_merge" href="#ties.topology_superimposer.long_merge">long_merge</a></code></b>
            –
            <div class="doc-md-description">
              <p>Carry out a merge and apply all checks.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.merge_compatible_suptops" href="#ties.topology_superimposer.merge_compatible_suptops">merge_compatible_suptops</a></code></b>
            –
            <div class="doc-md-description">
              <p>Imagine mapping of two carbons C1 and C2 to another pair of carbons C1' and C2'.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.merge_compatible_suptops_faster" href="#ties.topology_superimposer.merge_compatible_suptops_faster">merge_compatible_suptops_faster</a></code></b>
            –
            <div class="doc-md-description">
              <p>:param pairing_suptop:</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.superimpose_topologies" href="#ties.topology_superimposer.superimpose_topologies">superimpose_topologies</a></code></b>
            –
            <div class="doc-md-description">
              <p>The main function that manages the entire process.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.extract_best_suptop" href="#ties.topology_superimposer.extract_best_suptop">extract_best_suptop</a></code></b>
            –
            <div class="doc-md-description">
              <p>Assumes that any merging possible already took place.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.is_mirror_of_one" href="#ties.topology_superimposer.is_mirror_of_one">is_mirror_of_one</a></code></b>
            –
            <div class="doc-md-description">
              <p>"Mirror" in the sense that it is an alternative topological way to traverse the molecule.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.generate_nxg_from_list" href="#ties.topology_superimposer.generate_nxg_from_list">generate_nxg_from_list</a></code></b>
            –
            <div class="doc-md-description">
              <p>Helper function. Generates a graph from a list of atoms</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.get_starting_configurations" href="#ties.topology_superimposer.get_starting_configurations">get_starting_configurations</a></code></b>
            –
            <div class="doc-md-description">
              <pre><code>Minimise the number of starting configurations to optimise the process speed.
</code></pre>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.get_atoms_bonds_from_mol2" href="#ties.topology_superimposer.get_atoms_bonds_from_mol2">get_atoms_bonds_from_mol2</a></code></b>
            –
            <div class="doc-md-description">
              <p>Use Parmed to load the files.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.assign_coords_from_pdb" href="#ties.topology_superimposer.assign_coords_from_pdb">assign_coords_from_pdb</a></code></b>
            –
            <div class="doc-md-description">
              <p>Match the atoms from the ParmEd object based on a .pdb file</p>
            </div>
          </li>
    </ul>





  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="ties.topology_superimposer.Atom" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">Atom</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">Atom</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">










<p><span class="doc-section-title">Methods:</span></p>
    <ul>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.Atom.eq" href="#ties.topology_superimposer.Atom.eq">eq</a></code></b>
            –
            <div class="doc-md-description">
              <p>Check if the atoms are of the same type and have a charge within the given absolute tolerance.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.Atom.united_eq" href="#ties.topology_superimposer.Atom.united_eq">united_eq</a></code></b>
            –
            <div class="doc-md-description">
              <p>Like .eq, but treat the atoms as united atoms.</p>
            </div>
          </li>
    </ul>




<p><span class="doc-section-title">Attributes:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.Atom.united_charge" href="#ties.topology_superimposer.Atom.united_charge">united_charge</a></code></b>
          –
          <div class="doc-md-description">
            <p>United atom charge: summed charges of this atom and the bonded hydrogens.</p>
          </div>
        </li>
    </ul>

                  <details class="quote">
                    <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_original_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_original_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">atom_type</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_resname</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">charge</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_original_charge</span> <span class="o">=</span> <span class="n">charge</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">resid</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span><span class="n">Bonds</span> <span class="o">=</span> <span class="n">Bonds</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">use_general_type</span> <span class="o">=</span> <span class="n">use_general_type</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hash_value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_unique_counter</span> <span class="o">=</span> <span class="n">Atom</span><span class="o">.</span><span class="n">counter</span>
    <span class="n">Atom</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></td></tr></table></div>
                  </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ties.topology_superimposer.Atom.united_charge" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>            <span class="doc doc-object-name doc-attribute-name">united_charge</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="n">united_charge</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>United atom charge: summed charges of this atom and the bonded hydrogens.</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.Atom.eq" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">eq</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">eq</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Check if the atoms are of the same type and have a charge within the given absolute tolerance.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the atoms are of the same type and have a charge within the given absolute tolerance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.Atom.united_eq" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">united_eq</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">united_eq</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Like .eq, but treat the atoms as united atoms.
Check if the atoms have the same atom type, and
if if their charges are within the absolute tolerance.
If the atoms have hydrogens, add up the attached hydrogens and use a united atom representation.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">united_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like .eq, but treat the atoms as united atoms.</span>
<span class="sd">    Check if the atoms have the same atom type, and</span>
<span class="sd">    if if their charges are within the absolute tolerance.</span>
<span class="sd">    If the atoms have hydrogens, add up the attached hydrogens and use a united atom representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">united_charge</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">united_charge</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ties.topology_superimposer.AtomPair" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">AtomPair</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">AtomPair</span><span class="p">(</span><span class="n">left_node</span><span class="p">,</span> <span class="n">right_node</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">


        <p>An atom pair for networkx.</p>










                  <details class="quote">
                    <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_node</span><span class="p">,</span> <span class="n">right_node</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">left_atom</span> <span class="o">=</span> <span class="n">left_node</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">right_atom</span> <span class="o">=</span> <span class="n">right_node</span>
    <span class="c1"># generate the hash value for this match</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hash_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_hash</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
                  </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ties.topology_superimposer.SuperimposedTopology" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">SuperimposedTopology</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">SuperimposedTopology</span><span class="p">(</span><span class="n">topology1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">topology2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parmed_ligA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parmed_ligZ</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">


        <p>SuperimposedTopology contains in the minimal case two sets of nodes S1 and S2, which
are paired together and represent a strongly connected component.</p>
<p>However, it can also represent the symmetrical versions that were superimposed.</p>









<p><span class="doc-section-title">Methods:</span></p>
    <ul>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.mcs_score" href="#ties.topology_superimposer.SuperimposedTopology.mcs_score">mcs_score</a></code></b>
            –
            <div class="doc-md-description">
              <p>Raturn a ratio of the superimposed atoms to the number of all atoms.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.write_metadata" href="#ties.topology_superimposer.SuperimposedTopology.write_metadata">write_metadata</a></code></b>
            –
            <div class="doc-md-description">
              <p>Writes a .json file with a summary of which atoms are classified as appearing, disappearing</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.write_pdb" href="#ties.topology_superimposer.SuperimposedTopology.write_pdb">write_pdb</a></code></b>
            –
            <div class="doc-md-description">
              <p>param filename: name or a filepath of the new file. If None, standard preconfigured pattern will be used.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.write_mol2" href="#ties.topology_superimposer.SuperimposedTopology.write_mol2">write_mol2</a></code></b>
            –
            <div class="doc-md-description">
              <p>param filename: str location where the .mol2 file should be saved.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_single_topology_region" href="#ties.topology_superimposer.SuperimposedTopology.get_single_topology_region">get_single_topology_region</a></code></b>
            –
            <div class="doc-md-description">
              <p>Return: matched atoms (even if they were unmatched for any reason)</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_single_topology_app" href="#ties.topology_superimposer.SuperimposedTopology.get_single_topology_app">get_single_topology_app</a></code></b>
            –
            <div class="doc-md-description">
              <p>fixme - called app but gives both app and dis</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.ringring" href="#ties.topology_superimposer.SuperimposedTopology.ringring">ringring</a></code></b>
            –
            <div class="doc-md-description">
              <p>Rings can only be matched to rings.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.is_or_was_matched" href="#ties.topology_superimposer.SuperimposedTopology.is_or_was_matched">is_or_was_matched</a></code></b>
            –
            <div class="doc-md-description">
              <p>A helper function. For whatever reasons atoms get discarded.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_unmatched_atoms" href="#ties.topology_superimposer.SuperimposedTopology.get_unmatched_atoms">get_unmatched_atoms</a></code></b>
            –
            <div class="doc-md-description">
              <p>Find the atoms in both topologies which were unmatched and return them.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_unique_atom_count" href="#ties.topology_superimposer.SuperimposedTopology.get_unique_atom_count">get_unique_atom_count</a></code></b>
            –
            <div class="doc-md-description">
              <p>Requires that the .assign_atoms_ids() was called.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.align_ligands_using_mcs" href="#ties.topology_superimposer.SuperimposedTopology.align_ligands_using_mcs">align_ligands_using_mcs</a></code></b>
            –
            <div class="doc-md-description">
              <p>Align the two ligands using the MCS (Maximum Common Substructure).</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.rm_matched_pairs_with_different_bonds" href="#ties.topology_superimposer.SuperimposedTopology.rm_matched_pairs_with_different_bonds">rm_matched_pairs_with_different_bonds</a></code></b>
            –
            <div class="doc-md-description">
              <p>Scan the matched pairs. Assume you have three pairs</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_dual_topology_bonds" href="#ties.topology_superimposer.SuperimposedTopology.get_dual_topology_bonds">get_dual_topology_bonds</a></code></b>
            –
            <div class="doc-md-description">
              <p>Get the bonds between all the atoms.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.largest_cc_survives" href="#ties.topology_superimposer.SuperimposedTopology.largest_cc_survives">largest_cc_survives</a></code></b>
            –
            <div class="doc-md-description">
              <p>CC - Connected Component.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.assign_atoms_ids" href="#ties.topology_superimposer.SuperimposedTopology.assign_atoms_ids">assign_atoms_ids</a></code></b>
            –
            <div class="doc-md-description">
              <p>Assign an ID to each pair A1-B1. This means that if we request an atom ID</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms" href="#ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms">get_appearing_atoms</a></code></b>
            –
            <div class="doc-md-description">
              <h3 id="ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique">fixme - should check first if atomName is unique</h3>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms" href="#ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms">get_disappearing_atoms</a></code></b>
            –
            <div class="doc-md-description">
              <h3 id="ties.topology_superimposer.SuperimposedTopology--fixme-should-check-first-if-atomname-is-unique">fixme - should check first if atomName is unique</h3>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.remove_lonely_hydrogens" href="#ties.topology_superimposer.SuperimposedTopology.remove_lonely_hydrogens">remove_lonely_hydrogens</a></code></b>
            –
            <div class="doc-md-description">
              <p>You could also remove the hydrogens when you correct charges.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.match_gaff2_nondirectional_bonds" href="#ties.topology_superimposer.SuperimposedTopology.match_gaff2_nondirectional_bonds">match_gaff2_nondirectional_bonds</a></code></b>
            –
            <div class="doc-md-description">
              <p>If needed, swap cc-cd with cd-cc.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_net_charge" href="#ties.topology_superimposer.SuperimposedTopology.get_net_charge">get_net_charge</a></code></b>
            –
            <div class="doc-md-description">
              <p>Calculate the net charge difference across</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_matched_with_diff_q" href="#ties.topology_superimposer.SuperimposedTopology.get_matched_with_diff_q">get_matched_with_diff_q</a></code></b>
            –
            <div class="doc-md-description">
              <p>Returns a list of matched atom pairs that have a different q,</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter" href="#ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter">apply_net_charge_filter</a></code></b>
            –
            <div class="doc-md-description">
              <p>Averaging the charges across paired atoms introduced inequalities.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.remove_attached_hydrogens" href="#ties.topology_superimposer.SuperimposedTopology.remove_attached_hydrogens">remove_attached_hydrogens</a></code></b>
            –
            <div class="doc-md-description">
              <p>The node_pair to which these hydrogens are attached was removed.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.find_lowest_rmsd_mirror" href="#ties.topology_superimposer.SuperimposedTopology.find_lowest_rmsd_mirror">find_lowest_rmsd_mirror</a></code></b>
            –
            <div class="doc-md-description">
              <p>Walk through the different mirrors and out of all options select the one</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.is_subgraph_of_global_top" href="#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of_global_top">is_subgraph_of_global_top</a></code></b>
            –
            <div class="doc-md-description">
              <p>Check if after superimposition, one graph is a subgraph of another</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.rmsd" href="#ties.topology_superimposer.SuperimposedTopology.rmsd">rmsd</a></code></b>
            –
            <div class="doc-md-description">
              <p>For each pair take the distance, and then get rmsd, so root(mean(square(deviation)))</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.link_pairs" href="#ties.topology_superimposer.SuperimposedTopology.link_pairs">link_pairs</a></code></b>
            –
            <div class="doc-md-description">
              <p>This helps take care of the bonds.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.find_mirror_choices" href="#ties.topology_superimposer.SuperimposedTopology.find_mirror_choices">find_mirror_choices</a></code></b>
            –
            <div class="doc-md-description">
              <p>For each pair (A1, B1) find all the other options in the mirrors where (A1, B2)</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.add_alternative_mapping" href="#ties.topology_superimposer.SuperimposedTopology.add_alternative_mapping">add_alternative_mapping</a></code></b>
            –
            <div class="doc-md-description">
              <p>This means that there is another way to traverse and overlap the two molecules,</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates" href="#ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates">correct_for_coordinates</a></code></b>
            –
            <div class="doc-md-description">
              <p>Use the coordinates of the atoms, to figure out which symmetries are the correct ones.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.enforce_no_partial_rings" href="#ties.topology_superimposer.SuperimposedTopology.enforce_no_partial_rings">enforce_no_partial_rings</a></code></b>
            –
            <div class="doc-md-description">
              <p>http://www.alchemistry.org/wiki/Constructing_a_Pathway_of_Intermediate_States</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score" href="#ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score">get_topology_similarity_score</a></code></b>
            –
            <div class="doc-md-description">
              <p>Having the superimposed A(Left) and B(Right), score the match.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.unmatch_pairs_with_different_charges" href="#ties.topology_superimposer.SuperimposedTopology.unmatch_pairs_with_different_charges">unmatch_pairs_with_different_charges</a></code></b>
            –
            <div class="doc-md-description">
              <p>Removes the matched pairs where atom charges are more different</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.is_consistent_with" href="#ties.topology_superimposer.SuperimposedTopology.is_consistent_with">is_consistent_with</a></code></b>
            –
            <div class="doc-md-description">
              <p>Conditions:</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_circles" href="#ties.topology_superimposer.SuperimposedTopology.get_circles">get_circles</a></code></b>
            –
            <div class="doc-md-description">
              <p>Return circles found in the matched pairs.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.get_original_circles" href="#ties.topology_superimposer.SuperimposedTopology.get_original_circles">get_original_circles</a></code></b>
            –
            <div class="doc-md-description">
              <p>Return the original circles present in the input topologies.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.cycle_spans_multiple_cycles" href="#ties.topology_superimposer.SuperimposedTopology.cycle_spans_multiple_cycles">cycle_spans_multiple_cycles</a></code></b>
            –
            <div class="doc-md-description">
              <p>What is the circle is shared?</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.merge" href="#ties.topology_superimposer.SuperimposedTopology.merge">merge</a></code></b>
            –
            <div class="doc-md-description">
              <p>Absorb the other suptop by adding all the node pairs that are not present</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.validate_charges" href="#ties.topology_superimposer.SuperimposedTopology.validate_charges">validate_charges</a></code></b>
            –
            <div class="doc-md-description">
              <p>Check the original charges:</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.redistribute_charges" href="#ties.topology_superimposer.SuperimposedTopology.redistribute_charges">redistribute_charges</a></code></b>
            –
            <div class="doc-md-description">
              <p>After the match is made and the user commits to the superimposed topology,</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.contains_same_atoms_symmetric" href="#ties.topology_superimposer.SuperimposedTopology.contains_same_atoms_symmetric">contains_same_atoms_symmetric</a></code></b>
            –
            <div class="doc-md-description">
              <p>The atoms can be paired differently, but they are the same.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.is_subgraph_of" href="#ties.topology_superimposer.SuperimposedTopology.is_subgraph_of">is_subgraph_of</a></code></b>
            –
            <div class="doc-md-description">
              <p>Checks if this superimposed topology is a subgraph of another superimposed topology.</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.subgraph_relationship" href="#ties.topology_superimposer.SuperimposedTopology.subgraph_relationship">subgraph_relationship</a></code></b>
            –
            <div class="doc-md-description">
              <p>Return</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.is_mirror_of" href="#ties.topology_superimposer.SuperimposedTopology.is_mirror_of">is_mirror_of</a></code></b>
            –
            <div class="doc-md-description">
              <p>this is a naive check</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.eq" href="#ties.topology_superimposer.SuperimposedTopology.eq">eq</a></code></b>
            –
            <div class="doc-md-description">
              <p>Check if the superimposed topology is "the same". This means that every pair has a corresponding pair in the</p>
            </div>
          </li>
          <li class="doc-section-item field-body">
            <b><code><a class="autorefs autorefs-internal" title="ties.topology_superimposer.SuperimposedTopology.toJSON" href="#ties.topology_superimposer.SuperimposedTopology.toJSON">toJSON</a></code></b>
            –
            <div class="doc-md-description">
              <p>"</p>
            </div>
          </li>
    </ul>



                  <details class="quote">
                    <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">topology2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parmed_ligA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parmed_ligZ</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_parmeds</span><span class="p">(</span><span class="n">parmed_ligA</span><span class="p">,</span> <span class="n">parmed_ligZ</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    @superimposed_nodes : a set of pairs of nodes that matched together</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matched_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># TEST: with the list of matching nodes, check if each node was used only once,</span>
    <span class="c1"># the number of unique nodes should be equivalent to 2*len(common_pairs)</span>
    <span class="n">all_matched_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="p">[</span><span class="n">all_matched_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pair</span><span class="p">))</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">matched_pairs</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_matched_nodes</span><span class="p">)</span>

    <span class="c1"># fixme don&#39;t allow for initiating with matching pairs, it&#39;s not used anyway</span>

    <span class="c1"># todo convert to nx? some other graph theory package?</span>
    <span class="n">matched_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span> <span class="o">=</span> <span class="n">matched_pairs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">top1</span> <span class="o">=</span> <span class="n">topology1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">top2</span> <span class="o">=</span> <span class="n">topology2</span>
    <span class="c1"># create graph representation for both in networkx library, initially to track the number of cycles</span>
    <span class="c1"># fixme</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">mirrors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alternative_mappings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># this is a set of all nodes rather than their pairs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_matched_nodes</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes_added_log</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># options</span>
    <span class="c1"># Ambertools ignores the bonds when creating the .prmtop from the hybrid.mol2 file,</span>
    <span class="c1"># so for now we can ignore the bond types</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ignore_bond_types</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># removed because</span>
    <span class="c1"># fixme - make this into a list</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># atom-atom charge decided by qtol</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_disjointed_cc</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># disjointed segment</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_removed_due_to_net_charge</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_unmatched_rings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_diff_bonds</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the atoms pair uses a different bond</span>

    <span class="c1"># save the cycles in the left and right molecules</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_nonoverlapping_cycles</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">SuperimposedTopology</span><span class="o">.</span><span class="n">COUNTER</span>
    <span class="n">SuperimposedTopology</span><span class="o">.</span><span class="n">COUNTER</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></td></tr></table></div>
                  </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.mcs_score" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">mcs_score</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">mcs_score</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Raturn a ratio of the superimposed atoms to the number of all atoms.
Specifically, (superimposed_atoms_number * 2) / (atoms_number_ligandA + atoms_number_ligandB)
:return:</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">mcs_score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raturn a ratio of the superimposed atoms to the number of all atoms.</span>
<span class="sd">    Specifically, (superimposed_atoms_number * 2) / (atoms_number_ligandA + atoms_number_ligandB)</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.write_metadata" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">write_metadata</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">write_metadata</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Writes a .json file with a summary of which atoms are classified as appearing, disappearing
as well as all other metadata relevant to this superimposition/hybrid.
TODO add information:
 - config class in general
 -- relative paths to ligand 1, ligand 2 (the latest copies, ie renamed etc)
 -- general settings used
 - pair? bonds? these can be restractured, so not necessary?</p>
<pre><code>param filename: a location where the metadata should be saved
</code></pre>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">write_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes a .json file with a summary of which atoms are classified as appearing, disappearing</span>
<span class="sd">    as well as all other metadata relevant to this superimposition/hybrid.</span>
<span class="sd">    TODO add information:</span>
<span class="sd">     - config class in general</span>
<span class="sd">     -- relative paths to ligand 1, ligand 2 (the latest copies, ie renamed etc)</span>
<span class="sd">     -- general settings used</span>
<span class="sd">     - pair? bonds? these can be restractured, so not necessary?</span>

<span class="sd">        param filename: a location where the metadata should be saved</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># store at the root for now</span>
    <span class="c1"># fixme - should either be created or generated API</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">matching_json</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">workdir</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;meta_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">ligA</span><span class="o">.</span><span class="n">internal_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">ligZ</span><span class="o">.</span><span class="n">internal_name</span><span class="si">}</span><span class="s1">.json&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">matching_json</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">matching_json</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toJSON</span><span class="p">(),</span> <span class="nb">open</span><span class="p">(</span><span class="n">matching_json</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.write_pdb" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">write_pdb</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">write_pdb</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>param filename: name or a filepath of the new file. If None, standard preconfigured pattern will be used.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">write_pdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        param filename: name or a filepath of the new file. If None, standard preconfigured pattern will be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">morph_pdb_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">workdir</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">ligA</span><span class="o">.</span><span class="n">internal_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">ligZ</span><span class="o">.</span><span class="n">internal_name</span><span class="si">}</span><span class="s1">_morph.pdb&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">morph_pdb_path</span> <span class="o">=</span> <span class="n">filename</span>

    <span class="c1"># def write_morph_top_pdb(filepath, mda_l1, mda_l2, suptop, hybrid_single_dual_top=False):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">use_hybrid_single_dual_top</span><span class="p">:</span>
        <span class="c1"># the NAMD hybrid single dual topology</span>
        <span class="c1"># rename the ligand on the left to INI</span>
        <span class="c1"># and the ligand on the right to END</span>

        <span class="c1"># make a copy of the suptop here to ensure that the modifications won&#39;t affect it</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># first, set all the matched pairs to -2 and 2 (single topology)</span>
        <span class="c1"># regardless of how they were mismatched</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot yet write hybrid single dual topology .pdb file&#39;</span><span class="p">)</span>

        <span class="c1"># then, set the different atoms to -1 and 1 (dual topology)</span>

        <span class="c1"># save in a single PDB file</span>
        <span class="c1"># Note that the atoms from left to right</span>
        <span class="c1"># in the single topology region have to</span>
        <span class="c1"># be separated by the same number</span>
        <span class="c1"># fixme - make a check for that</span>
        <span class="k">return</span>
    <span class="c1"># fixme - find another library that can handle writing to a PDB file, MDAnalysis</span>
    <span class="c1"># save the ligand with all the appropriate atomic positions, write it using the pdb format</span>
    <span class="c1"># pdb file format: http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM</span>
    <span class="c1"># write a dual .pdb file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">morph_pdb_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">FOUT</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parmed_ligA</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            There is only one forcefield which is shared across the two topologies. </span>
<span class="sd">            Basically, we need to check whether the atom is in both topologies. </span>
<span class="sd">            If that is the case, then the atom should have the same name, and therefore appear only once. </span>
<span class="sd">            However, if there is a new atom, it should be specfically be outlined </span>
<span class="sd">            that it is 1) new and 2) the right type</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># write all the atoms if they are matched, that&#39;s the common part</span>
            <span class="c1"># note that ParmEd does not have the information on a residue ID</span>
            <span class="n">REMAINS</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_left_atom</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">idx</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">idx</span><span class="si">:</span><span class="s2">&gt;5d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;3s</span><span class="si">}</span><span class="s2">  &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">&gt;4d</span><span class="si">}</span><span class="s2">    &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">xx</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}{</span><span class="n">atom</span><span class="o">.</span><span class="n">xy</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}{</span><span class="n">atom</span><span class="o">.</span><span class="n">xz</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}</span><span class="s2">&quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">1.0</span><span class="si">:</span><span class="s2">&gt;6.2f</span><span class="si">}{</span><span class="n">REMAINS</span><span class="si">:</span><span class="s2">&gt;6.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="mi">11</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="s1">&#39;  &#39;</span> <span class="o">+</span> <span class="s1">&#39;  &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this atom was not found, this means it disappears, so we should update the</span>
                <span class="n">DISAPPEARING_ATOM</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">idx</span><span class="si">:</span><span class="s2">&gt;5d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;3s</span><span class="si">}</span><span class="s2">  &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">&gt;4d</span><span class="si">}</span><span class="s2">    &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">xx</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}{</span><span class="n">atom</span><span class="o">.</span><span class="n">xy</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}{</span><span class="n">atom</span><span class="o">.</span><span class="n">xz</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}</span><span class="s2">&quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">1.0</span><span class="si">:</span><span class="s2">&gt;6.2f</span><span class="si">}{</span><span class="n">DISAPPEARING_ATOM</span><span class="si">:</span><span class="s2">&gt;6.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> \
                       <span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="mi">11</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="s1">&#39;  &#39;</span> <span class="o">+</span> <span class="s1">&#39;  &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="c1"># add atoms from the right topology,</span>
        <span class="c1"># which are going to be created</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parmed_ligZ</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_right_atom</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">idx</span><span class="p">):</span>
                <span class="n">APPEARING_ATOM</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">idx</span><span class="si">:</span><span class="s2">&gt;5d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;3s</span><span class="si">}</span><span class="s2">  &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">&gt;4d</span><span class="si">}</span><span class="s2">    &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">xx</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}{</span><span class="n">atom</span><span class="o">.</span><span class="n">xy</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}{</span><span class="n">atom</span><span class="o">.</span><span class="n">xz</span><span class="si">:</span><span class="s2">&gt;8.3f</span><span class="si">}</span><span class="s2">&quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">1.0</span><span class="si">:</span><span class="s2">&gt;6.2f</span><span class="si">}{</span><span class="n">APPEARING_ATOM</span><span class="si">:</span><span class="s2">&gt;6.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> \
                       <span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="mi">11</span><span class="p">)</span> <span class="o">+</span> \
                       <span class="s1">&#39;  &#39;</span> <span class="o">+</span> <span class="s1">&#39;  &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pdb</span> <span class="o">=</span> <span class="n">morph_pdb_path</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.write_mol2" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">write_mol2</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">write_mol2</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_left_charges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_left_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>param filename: str location where the .mol2 file should be saved.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">write_mol2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_left_charges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_left_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        param filename: str location where the .mol2 file should be saved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hybrid_mol2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">workdir</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">ligA</span><span class="o">.</span><span class="n">internal_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">ligZ</span><span class="o">.</span><span class="n">internal_name</span><span class="si">}</span><span class="s1">_morph.mol2&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hybrid_mol2</span> <span class="o">=</span> <span class="n">filename</span>

    <span class="c1"># fixme - make this as a method of suptop as well</span>
    <span class="c1"># recreate the mol2 file that is merged and contains the correct atoms from both</span>
    <span class="c1"># mol2 format: http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/mol2.pdf</span>
    <span class="c1"># fixme - build this molecule using the MDAnalysis builder instead of the current approach</span>
    <span class="c1"># however, MDAnalysis currently cannot convert pdb into mol2? ...</span>
    <span class="c1"># where the formatting is done manually</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">hybrid_mol2</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">FOUT</span><span class="p">:</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dual_topology_bonds</span><span class="p">()</span>

        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;MOLECULE &#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>
        <span class="c1"># name of the molecule</span>
        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;HYB &#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>
        <span class="c1"># num_atoms [num_bonds [num_subst [num_feat [num_sets]]]]</span>
        <span class="c1"># fixme this is tricky</span>
        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_unique_atom_count</span><span class="p">()</span><span class="si">:</span><span class="s1">d</span><span class="si">}</span><span class="s1"> &#39;</span>
                   <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="si">:</span><span class="s1">d</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>
        <span class="c1"># mole type</span>
        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;SMALL &#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>
        <span class="c1"># charge_type</span>
        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;NO_CHARGES &#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>
        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>

        <span class="c1"># write the atoms</span>
        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;ATOM &#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>
        <span class="c1"># atom_id atom_name x y z atom_type [subst_id [subst_name [charge [status_bit]]]]</span>
        <span class="c1"># e.g.</span>
        <span class="c1">#       1 O4           3.6010   -50.1310     7.2170 o          1 L39      -0.815300</span>

        <span class="c1"># so from the two topologies all the atoms are needed and they need to have a different atom_id</span>
        <span class="c1"># so we might need to name the atom_id for them, other details are however pretty much the same</span>
        <span class="c1"># the importance of atom_name is difficult to estimate</span>

        <span class="c1"># we are going to assign IDs in the superimposed topology in order to track which atoms have IDs</span>
        <span class="c1"># and which don&#39;t</span>

        <span class="c1"># fixme - for writing, modify things to achieve the desired output</span>
        <span class="c1"># note - we are modifying in place our atoms</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Aligned </span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">original_name</span><span class="si">}</span><span class="s1"> id </span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1"> with </span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">original_name</span><span class="si">}</span><span class="s1"> id </span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_left_charges</span><span class="p">:</span>
                <span class="n">left</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">charge</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_left_coords</span><span class="p">:</span>
                <span class="n">left</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">position</span>

        <span class="n">subst_id</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># resid basically</span>
        <span class="c1"># write all the atoms that were matched first with their IDs</span>
        <span class="c1"># prepare all the atoms, note that we use primarily the left ligand naming</span>
        <span class="n">all_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">left</span> <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unmatched_atoms</span><span class="p">()</span>
        <span class="n">unmatched_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unmatched_atoms</span><span class="p">()</span>
        <span class="c1"># reorder the list according to the ID</span>
        <span class="n">all_atoms</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">atom</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_generated_atom_id</span><span class="p">(</span><span class="n">atom</span><span class="p">))</span>

        <span class="n">resname</span> <span class="o">=</span> <span class="s1">&#39;HYB&#39;</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">all_atoms</span><span class="p">:</span>
            <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_generated_atom_id</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> &#39;</span>
                       <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1"> &#39;</span>
                       <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">subst_id</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">resname</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>

        <span class="c1"># write bonds</span>
        <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;BOND &#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>

        <span class="c1"># we have to list every bond:</span>
        <span class="c1"># 1) all the bonds between the paired atoms, so that part is easy</span>
        <span class="c1"># 2) bonds which link the disappearing atoms, and their connection to the paired atoms</span>
        <span class="c1"># 3) bonds which link the appearing atoms, and their connections to the paired atoms</span>

        <span class="n">bond_counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bond_from_id</span><span class="p">,</span> <span class="n">bond_to_id</span><span class="p">,</span> <span class="n">bond_type</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bonds</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="p">[:</span><span class="mi">2</span><span class="p">]):</span>
            <span class="c1"># Bond Line Format:</span>
            <span class="c1"># bond_id origin_atom_id target_atom_id bond_type [status_bits]</span>
            <span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bond_counter</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">bond_from_id</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">bond_to_id</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">bond_type</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span>
            <span class="n">bond_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">mol2</span> <span class="o">=</span> <span class="n">hybrid_mol2</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology._init_nonoverlapping_cycles" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">_init_nonoverlapping_cycles</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_init_nonoverlapping_cycles</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Compile the cycles separately for the left and right molecule.
Then, across the cycles, remove the nodes that join rings (double rings).</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_init_nonoverlapping_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compile the cycles separately for the left and right molecule.</span>
<span class="sd">    Then, across the cycles, remove the nodes that join rings (double rings).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_cycles</span><span class="p">,</span> <span class="n">r_cycles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_original_circles</span><span class="p">()</span>
    <span class="c1"># remove any nodes that are shared between two cycles</span>
    <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">l_cycles</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">common</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">common</span><span class="p">:</span>
            <span class="n">c1</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">c2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="c1"># same for r_cycles</span>
    <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">r_cycles</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">common</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">common</span><span class="p">:</span>
            <span class="n">c1</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">c2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_nonoverlapping_l_cycles</span> <span class="o">=</span> <span class="n">l_cycles</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_nonoverlapping_r_cycles</span> <span class="o">=</span> <span class="n">r_cycles</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_single_topology_region" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_single_topology_region</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_single_topology_region</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return: matched atoms (even if they were unmatched for any reason)</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_single_topology_region</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return: matched atoms (even if they were unmatched for any reason)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># strip the pairs of the exact information about the charge differences</span>
    <span class="n">removed_pairs_with_charge_difference</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span> <span class="n">q_diff</span> <span class="ow">in</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span><span class="p">]</span>

    <span class="c1"># fixme: this should not work with disjointed cc and others?</span>
    <span class="n">unpaired</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_disjointed_cc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_due_to_net_charge</span> <span class="o">+</span> \
        <span class="n">removed_pairs_with_charge_difference</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span> <span class="o">+</span> <span class="n">unpaired</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_single_topology_app" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_single_topology_app</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_single_topology_app</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>fixme - called app but gives both app and dis
get the appearing and disappearing region in the hybrid single topology
use the single topology region and classify all other atoms not in it
as either appearing or disappearing</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_single_topology_app</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fixme - called app but gives both app and dis</span>
<span class="sd">    get the appearing and disappearing region in the hybrid single topology</span>
<span class="sd">    use the single topology region and classify all other atoms not in it</span>
<span class="sd">    as either appearing or disappearing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">single_top_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_topology_region</span><span class="p">()</span>

    <span class="c1"># turn it into a set</span>
    <span class="n">single_top_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">single_top_area</span><span class="p">:</span>
        <span class="n">single_top_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">single_top_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="c1"># these unmatched atoms could be due to charge etc.</span>
    <span class="c1"># so they historically refer to the dual-topology</span>
    <span class="n">unmatched_app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_appearing_atoms</span><span class="p">()</span>
    <span class="n">app</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">unmatched_app</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">single_top_set</span><span class="p">}</span>
    <span class="n">unmatched_dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_disappearing_atoms</span><span class="p">()</span>
    <span class="n">dis</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">unmatched_dis</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">single_top_set</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">,</span> <span class="n">dis</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.ringring" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">ringring</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">ringring</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Rings can only be matched to rings.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ringring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rings can only be matched to rings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_circles</span><span class="p">,</span> <span class="n">r_circles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_original_circles</span><span class="p">()</span>
    <span class="n">removed_h</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ringring_removed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">removed_h</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">l_ring</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">l</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">l_circles</span><span class="p">])</span>
        <span class="n">r_ring</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">r</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">r_circles</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">l_ring</span> <span class="o">+</span> <span class="n">r_ring</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">removed_h</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_attached_hydrogens</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
            <span class="n">ringring_removed</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ringring_removed</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;(ST</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">) Ring only matches ring filter, removed: </span><span class="si">{</span><span class="n">ringring_removed</span><span class="si">}</span><span class="s1"> with hydrogens </span><span class="si">{</span><span class="n">removed_h</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ringring_removed</span><span class="p">,</span> <span class="n">removed_h</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.is_or_was_matched" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">is_or_was_matched</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">is_or_was_matched</span><span class="p">(</span><span class="n">atom_name1</span><span class="p">,</span> <span class="n">atom_name2</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>A helper function. For whatever reasons atoms get discarded.
E.g. they had a different charge, or were part of the disjointed component, etc.
This function simply checks if the most original match was made between the two atoms.
It helps with verifying the original matching.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_or_was_matched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_name1</span><span class="p">,</span> <span class="n">atom_name2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function. For whatever reasons atoms get discarded.</span>
<span class="sd">    E.g. they had a different charge, or were part of the disjointed component, etc.</span>
<span class="sd">    This function simply checks if the most original match was made between the two atoms.</span>
<span class="sd">    It helps with verifying the original matching.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_atom_name_pair</span><span class="p">(</span><span class="n">atom_name1</span><span class="p">,</span> <span class="n">atom_name2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># check if it was unmatched</span>
    <span class="n">unmatched_lists</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_disjointed_cc</span><span class="p">,</span>
                        <span class="c1"># ignore the charges in this list</span>
                        <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_due_to_net_charge</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span><span class="p">]</span>
                       <span class="p">]</span>
    <span class="k">for</span> <span class="n">unmatched_list</span> <span class="ow">in</span> <span class="n">unmatched_lists</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">unmatched_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">atom_name1</span> <span class="ow">and</span> <span class="n">atom2</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">atom_name2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_unmatched_atoms" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_unmatched_atoms</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_unmatched_atoms</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Find the atoms in both topologies which were unmatched and return them.
These are both, appearing and disappearing.</p>
<p>Note that some atoms were removed due to charges.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_unmatched_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the atoms in both topologies which were unmatched and return them.</span>
<span class="sd">    These are both, appearing and disappearing.</span>

<span class="sd">    Note that some atoms were removed due to charges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unmatched_atoms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">unmatched_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">unmatched_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unmatched_atoms</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_unique_atom_count" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_unique_atom_count</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_unique_atom_count</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Requires that the .assign_atoms_ids() was called.
This should be rewritten. But basically, it needs to count each matched pair as one atom,
and the appearing and disappearing atoms separately.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_unique_atom_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires that the .assign_atoms_ids() was called.</span>
<span class="sd">    This should be rewritten. But basically, it needs to count each matched pair as one atom,</span>
<span class="sd">    and the appearing and disappearing atoms separately.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_count</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.align_ligands_using_mcs" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">align_ligands_using_mcs</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">align_ligands_using_mcs</span><span class="p">(</span><span class="n">overwrite_original</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Align the two ligands using the MCS (Maximum Common Substructure).
The ligA here is the reference (docked) to which the ligZ is aligned.</p>
<p>:param overwrite_original: After aligning by MCS, update the internal coordinates
    which will be saved to a file at the end.
:type overwrite_original: bool</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">align_ligands_using_mcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite_original</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Align the two ligands using the MCS (Maximum Common Substructure).</span>
<span class="sd">    The ligA here is the reference (docked) to which the ligZ is aligned.</span>

<span class="sd">    :param overwrite_original: After aligning by MCS, update the internal coordinates</span>
<span class="sd">        which will be saved to a file at the end.</span>
<span class="sd">    :type overwrite_original: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mda_ligA</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mda_ligB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># todo comment</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span><span class="p">()</span>

    <span class="n">ligA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mda_ligA</span>
    <span class="n">ligB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mda_ligB</span>

    <span class="c1"># back up</span>
    <span class="n">ligA_original_positions</span> <span class="o">=</span> <span class="n">ligA</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:]</span>
    <span class="n">ligB_original_positions</span> <span class="o">=</span> <span class="n">ligB</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:]</span>

    <span class="c1"># select the atoms for the MCS,</span>
    <span class="c1"># the following uses 0-based indexing</span>
    <span class="n">mcs_ligA_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">left</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">]</span>
    <span class="n">mcs_ligB_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">right</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">]</span>

    <span class="n">ligA_fragment</span> <span class="o">=</span> <span class="n">ligA</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">mcs_ligA_ids</span><span class="p">]</span>
    <span class="n">ligB_fragment</span> <span class="o">=</span> <span class="n">ligB</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">mcs_ligB_ids</span><span class="p">]</span>

    <span class="c1"># move all to the origin of the fragment</span>
    <span class="n">ligA_mcs_centre</span> <span class="o">=</span> <span class="n">ligA_fragment</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
    <span class="n">ligA</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">ligA_mcs_centre</span><span class="p">)</span>
    <span class="n">ligB</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">ligB_fragment</span><span class="o">.</span><span class="n">centroid</span><span class="p">())</span>

    <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">rmsd</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">align</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">ligB_fragment</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">ligA_fragment</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

    <span class="c1"># apply the rotation to</span>
    <span class="n">ligB</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">)</span>
    <span class="c1"># move back to ligA</span>
    <span class="n">ligB</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">ligA_mcs_centre</span><span class="p">)</span>

    <span class="c1"># save the superimposed coordinates</span>
    <span class="n">ligB_sup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mda_ligB</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:]</span>

    <span class="c1"># restore the MDAnalysis positions (&quot;working copy&quot;)</span>
    <span class="c1"># in theory you do not need to do this every time</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mda_ligA</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">ligA_original_positions</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mda_ligB</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">ligB_original_positions</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite_original</span><span class="p">:</span>
        <span class="c1"># return the RMSD of the superimposed matched pairs only</span>
        <span class="k">return</span> <span class="n">rmsd</span>

    <span class="c1"># update the atoms with the mapping done via IDs</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Aligned by MCS with the RMSD value </span><span class="si">{</span><span class="n">rmsd</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># use the aligned coordinates</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parmed_ligZ</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">ligB_sup</span>

    <span class="c1"># ideally this would now be done with MDAnalysis which can now write .mol2</span>
    <span class="c1"># overwrite the internal atom positions with the final generated alignment</span>
    <span class="k">for</span> <span class="n">parmed_atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parmed_ligZ</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">idx</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">xz</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">assert</span> <span class="n">found</span>

    <span class="k">return</span> <span class="n">rmsd</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.rm_matched_pairs_with_different_bonds" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">rm_matched_pairs_with_different_bonds</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">rm_matched_pairs_with_different_bonds</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Scan the matched pairs. Assume you have three pairs
A-B=C with the double bond on the right side,
and the alternative bonds
A=B-C remove all A, B and C pairs because of the different bonds
Remove them by finding that A-B is not A=B, and B=C is not B-C</p>
<p>return: the list of removed pairs</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rm_matched_pairs_with_different_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scan the matched pairs. Assume you have three pairs</span>
<span class="sd">    A-B=C with the double bond on the right side,</span>
<span class="sd">    and the alternative bonds</span>
<span class="sd">    A=B-C remove all A, B and C pairs because of the different bonds</span>
<span class="sd">    Remove them by finding that A-B is not A=B, and B=C is not B-C</span>

<span class="sd">    return: the list of removed pairs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># extract the bonds for the matched molecules first</span>
    <span class="n">removed_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">from_pair</span><span class="p">,</span> <span class="n">bonded_pair_list</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="o">.</span><span class="n">items</span><span class="p">())[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">bonded_pair</span><span class="p">,</span> <span class="n">bond_type</span> <span class="ow">in</span> <span class="n">bonded_pair_list</span><span class="p">:</span>
            <span class="c1"># ignore if this combination was already checked</span>
            <span class="k">if</span> <span class="n">bonded_pair</span> <span class="ow">in</span> <span class="n">removed_pairs</span> <span class="ow">and</span> <span class="n">from_pair</span> <span class="ow">in</span> <span class="n">removed_pairs</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">bond_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bond_type</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># resolve this, remove the bonded pair from the matched atoms</span>
                <span class="k">if</span> <span class="n">from_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_pairs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">(</span><span class="n">from_pair</span><span class="p">)</span>
                    <span class="n">removed_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_pair</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bonded_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_pairs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">(</span><span class="n">bonded_pair</span><span class="p">)</span>
                    <span class="n">removed_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bonded_pair</span><span class="p">)</span>

                <span class="c1"># keep the history</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_diff_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">from_pair</span><span class="p">,</span> <span class="n">bonded_pair</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">removed_pairs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_dual_topology_bonds" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_dual_topology_bonds</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_dual_topology_bonds</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Get the bonds between all the atoms.
Use the atom IDs for the bonds.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_dual_topology_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the bonds between all the atoms.</span>
<span class="sd">    Use the atom IDs for the bonds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># fixme - check if the atoms IDs have been generated</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># extract the bonds for the matched molecules first</span>
    <span class="n">bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">from_pair</span><span class="p">,</span> <span class="n">bonded_pair_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">from_pair_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_generated_atom_id</span><span class="p">(</span><span class="n">from_pair</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bonded_pair</span><span class="p">,</span> <span class="n">bond_type</span> <span class="ow">in</span> <span class="n">bonded_pair_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_bond_types</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bond_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bond_type</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ERROR: bond types do not match, even though they apply to the same atoms&#39;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ERROR: left bond is &quot;</span><span class="si">{</span><span class="n">bond_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&quot; and right bond is &quot;</span><span class="si">{</span><span class="n">bond_type</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ERROR: the bonded atoms are </span><span class="si">{</span><span class="n">bonded_pair</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The bond types do not correspond to each other&#39;</span><span class="p">)</span>
            <span class="c1"># every bonded pair has to be in the topology</span>
            <span class="k">assert</span> <span class="n">bonded_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span>
            <span class="n">to_pair_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_generated_atom_id</span><span class="p">(</span><span class="n">bonded_pair</span><span class="p">)</span>
            <span class="c1"># before adding them to bonds, check if they are not already there</span>
            <span class="n">bond_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">from_pair_id</span><span class="p">,</span> <span class="n">to_pair_id</span><span class="p">])</span>
            <span class="n">bond_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond_type</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">bonds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bond_sorted</span><span class="p">))</span>

    <span class="c1"># extract the bond information from the unmatched</span>
    <span class="n">unmatched_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unmatched_atoms</span><span class="p">()</span>
    <span class="c1"># for every atom, check to which &quot;pair&quot; the bond connects,</span>
    <span class="c1"># and use that pair&#39;s ID to make the link</span>

    <span class="c1"># several iterations of walking through the atoms,</span>
    <span class="c1"># this is to ensure that we remove each atom one by one</span>
    <span class="c1"># e.g. imagine this PAIR-SingleA1-SingleA2-SingleA3</span>
    <span class="c1"># so only the first SingleA1 is connected to a pair,</span>
    <span class="c1"># so the first iteration would take care of that,</span>
    <span class="c1"># the next iteration would connect SingleA2 to SingleA1, etc</span>
    <span class="c1"># first, remove the atoms that are connected to pairs</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">unmatched_atoms</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">unmatched_atom_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_generated_atom_id</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="c1"># check if the unmatched atom is bonded to any pair</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_pair_with_atom</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this atom is bound to a pair, so add the bond to the pair</span>
                <span class="n">pair_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_generated_atom_id</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># add the bond between the atom and the pair</span>
                <span class="n">bond_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">unmatched_atom_id</span><span class="p">,</span> <span class="n">pair_id</span><span class="p">])</span>
                <span class="n">bond_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="n">bonds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bond_sorted</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># it is not directly linked to a matched pair,</span>
                <span class="c1"># simply add this missing bond to whatever atom it is bound</span>
                <span class="n">another_unmatched_atom_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_generated_atom_id</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
                <span class="n">bond_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">unmatched_atom_id</span><span class="p">,</span> <span class="n">another_unmatched_atom_id</span><span class="p">])</span>
                <span class="n">bond_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="n">bonds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bond_sorted</span><span class="p">))</span>

    <span class="c1"># fixme - what about circles etc? these bonds</span>
    <span class="c1"># that form circles should probably be added while checking if the circles make sense etc</span>
    <span class="c1"># also, rather than checking if it is a circle, we could check if the new linked atom,</span>
    <span class="c1"># is in a pair to which the new pair refers (the same rule that is used currently)</span>
    <span class="k">return</span> <span class="n">bonds</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.largest_cc_survives" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">largest_cc_survives</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">largest_cc_survives</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>CC - Connected Component.</p>
<p>Removes any disjoint components. Only the largest CC will be left.
In the case of of equal length CCs, an arbitrary is chosen.</p>
<p>How:
Generates the graph where each pair is a single node, connecting the nodes if the bonds exist.
Uses then networkx to find CCs.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">largest_cc_survives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CC - Connected Component.</span>

<span class="sd">    Removes any disjoint components. Only the largest CC will be left.</span>
<span class="sd">    In the case of of equal length CCs, an arbitrary is chosen.</span>

<span class="sd">    How:</span>
<span class="sd">    Generates the graph where each pair is a single node, connecting the nodes if the bonds exist.</span>
<span class="sd">    Uses then networkx to find CCs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup_up</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">tuple_pair</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">is_pair</span><span class="p">(</span><span class="n">tuple_pair</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">pair</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Did not find the AtomPair&#39;</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">atom_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="n">ap</span> <span class="o">=</span> <span class="n">AtomPair</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">atom_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>

    <span class="c1"># connect the atom pairs</span>
    <span class="k">for</span> <span class="n">pair_from</span><span class="p">,</span> <span class="n">pair_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># lookup the corresponding atom pairs</span>
        <span class="n">ap_from</span> <span class="o">=</span> <span class="n">lookup_up</span><span class="p">(</span><span class="n">atom_pairs</span><span class="p">,</span> <span class="n">pair_from</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tuple_pair</span><span class="p">,</span> <span class="n">bond_type</span> <span class="ow">in</span> <span class="n">pair_list</span><span class="p">:</span>
            <span class="n">ap_to</span> <span class="o">=</span> <span class="n">lookup_up</span><span class="p">(</span><span class="n">atom_pairs</span><span class="p">,</span> <span class="n">tuple_pair</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">ap_from</span><span class="p">,</span> <span class="n">ap_to</span><span class="p">)</span>

    <span class="c1"># check for connected components (CC)</span>
    <span class="n">remove_ccs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ccs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
    <span class="n">largest_cc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">])</span>

    <span class="c1"># there are disjoint fragments, remove the smaller one</span>
    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># remove the cc if it smaller than the largest component</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">largest_cc</span><span class="p">:</span>
            <span class="n">remove_ccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">ccs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

    <span class="c1"># remove the cc that have a smaller number of heavy atoms</span>
    <span class="n">largest_heavy_atom_cc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">cc</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_heavy_atom</span><span class="p">()])</span>
                                                    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">cc</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_heavy_atom</span><span class="p">()])</span> <span class="o">&lt;</span> <span class="n">largest_heavy_atom_cc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Found CC that had fewer heavy atoms. Removing. &#39;</span><span class="p">)</span>
            <span class="n">remove_ccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">ccs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

    <span class="c1"># remove the cc that has a smaller number of rings</span>
    <span class="n">largest_cycle_num</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">largest_cycle_num</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Found CC that had fewer cycles. Removing. &#39;</span><span class="p">)</span>
            <span class="n">remove_ccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">ccs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

    <span class="c1"># remove cc that has a smaller number of heavy atoms across rings</span>
    <span class="n">most_heavy_atoms_in_cycles</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># count the heavy atoms across the cycles</span>
        <span class="n">heavy_atom_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">cc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_heavy_atom</span><span class="p">():</span>
                    <span class="n">heavy_atom_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">heavy_atom_counter</span> <span class="o">&gt;</span> <span class="n">most_heavy_atoms_in_cycles</span><span class="p">:</span>
            <span class="n">most_heavy_atoms_in_cycles</span> <span class="o">=</span> <span class="n">heavy_atom_counter</span>

    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># count the heavy atoms across the cycles</span>
        <span class="n">heavy_atom_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">cc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_heavy_atom</span><span class="p">():</span>
                    <span class="n">heavy_atom_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">heavy_atom_counter</span> <span class="o">&lt;</span> <span class="n">most_heavy_atoms_in_cycles</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Found CC that had fewer heavy atoms in cycles. Removing. &#39;</span><span class="p">)</span>
            <span class="n">remove_ccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">ccs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># there are equally large CCs</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The Connected Components are equally large! Picking the first one&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">ccs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">remove_ccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">ccs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;At this point there should be left only one main component&quot;</span>

    <span class="c1"># remove the worse cc</span>
    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">remove_ccs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">atom_pair</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="n">atom_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom_pair</span><span class="o">.</span><span class="n">left_atom</span><span class="p">,</span> <span class="n">atom_pair</span><span class="o">.</span><span class="n">right_atom</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">(</span><span class="n">atom_tuple</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_disjointed_cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_tuple</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">largest_cc</span><span class="p">,</span> <span class="n">remove_ccs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.assign_atoms_ids" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">assign_atoms_ids</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">assign_atoms_ids</span><span class="p">(</span><span class="n">id_start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Assign an ID to each pair A1-B1. This means that if we request an atom ID
for A1 or B1 it will be the same.</p>
<p>Then assign different IDs for the other atoms</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">assign_atoms_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign an ID to each pair A1-B1. This means that if we request an atom ID</span>
<span class="sd">    for A1 or B1 it will be the same.</span>

<span class="sd">    Then assign different IDs for the other atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">id_counter</span> <span class="o">=</span> <span class="n">id_start</span>
    <span class="c1"># for each pair assign an ID</span>
    <span class="k">for</span> <span class="n">left_atom</span><span class="p">,</span> <span class="n">right_atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span><span class="p">[</span><span class="n">left_atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span><span class="p">[</span><span class="n">right_atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_counter</span>
        <span class="c1"># make it possible to look up the atom ID with a pair</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span><span class="p">[(</span><span class="n">left_atom</span><span class="p">,</span> <span class="n">right_atom</span><span class="p">)]</span> <span class="o">=</span> <span class="n">id_counter</span>

        <span class="n">id_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># for each atom that was not mapped to any other atom,</span>
    <span class="c1"># but is still in the topology, generate an ID for it</span>

    <span class="c1"># find the not mapped atoms in the left topology and assign them an atom ID</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">:</span>
        <span class="c1"># check if this node was matched</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_counter</span>
            <span class="n">id_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># find the not mapped atoms in the right topology and assign them an atom ID</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">:</span>
        <span class="c1"># check if this node was matched</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">internal_ids</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_counter</span>
            <span class="n">id_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique_atom_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># return the last atom</span>
    <span class="k">return</span> <span class="n">id_counter</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_appearing_atoms</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_appearing_atoms</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <h4 id="ties.topology_superimposer.SuperimposedTopology.get_appearing_atoms--fixme-should-check-first-if-atomname-is-unique">fixme - should check first if atomName is unique</h4>
<p>Return a list of appearing atoms (atomName) which are the
atoms that are</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_appearing_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # fixme - should check first if atomName is unique</span>
<span class="sd">    Return a list of appearing atoms (atomName) which are the</span>
<span class="sd">    atoms that are</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unmatched</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">top2_atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">:</span>
        <span class="n">is_matched</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">matched_right_ligand_atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top2_atom</span> <span class="ow">is</span> <span class="n">matched_right_ligand_atom</span><span class="p">:</span>
                <span class="n">is_matched</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_matched</span><span class="p">:</span>
            <span class="n">unmatched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top2_atom</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unmatched</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_disappearing_atoms</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_disappearing_atoms</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <h4 id="ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-should-check-first-if-atomname-is-unique">fixme - should check first if atomName is unique</h4>
<h4 id="ties.topology_superimposer.SuperimposedTopology.get_disappearing_atoms--fixme-update-to-using-the-node-set">fixme - update to using the node set</h4>
<p>Return a list of appearing atoms (atomName) which are the
atoms that are found in the topology, and that
are not present in the matched_pairs</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_disappearing_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # fixme - should check first if atomName is unique</span>
<span class="sd">    # fixme - update to using the node set</span>
<span class="sd">    Return a list of appearing atoms (atomName) which are the</span>
<span class="sd">    atoms that are found in the topology, and that</span>
<span class="sd">    are not present in the matched_pairs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unmatched</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">top1_atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">:</span>
        <span class="n">is_matched</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">matched_left_ligand_atom</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top1_atom</span> <span class="ow">is</span> <span class="n">matched_left_ligand_atom</span><span class="p">:</span>
                <span class="n">is_matched</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_matched</span><span class="p">:</span>
            <span class="n">unmatched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top1_atom</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unmatched</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.remove_lonely_hydrogens" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">remove_lonely_hydrogens</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">remove_lonely_hydrogens</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>You could also remove the hydrogens when you correct charges.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">remove_lonely_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    You could also remove the hydrogens when you correct charges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;ERROR: function used that was not verified. It can create errors. &#39;</span>
          <span class="s1">&#39;Please verify that the code works first.&#39;</span><span class="p">)</span>
    <span class="c1"># in order to see any hydrogens that are by themselves, we check for any connection</span>
    <span class="n">removed_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">A1</span><span class="p">,</span> <span class="n">B1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="c1"># fixme - assumes hydrogens start their names with H*</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A1</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># check if any of the bonded atoms can be found in this sup top</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_any</span><span class="p">(</span><span class="n">A1</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">B1</span><span class="o">.</span><span class="n">bonds</span><span class="p">):</span>
            <span class="c1"># we appear disconnected, remove us</span>
            <span class="k">pass</span>
        <span class="k">for</span> <span class="n">bonded_atom</span> <span class="ow">in</span> <span class="n">A1</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">bonded_atom</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">bonded_atom</span><span class="p">):</span>
                <span class="k">continue</span>

    <span class="k">return</span> <span class="n">removed_pairs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.match_gaff2_nondirectional_bonds" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">match_gaff2_nondirectional_bonds</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">match_gaff2_nondirectional_bonds</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>If needed, swap cc-cd with cd-cc.
If two pairs are linked: (CC/CD) - (CD/CC),
replace them according to the left side: (CC/CC) - (CD/CD).
Apply this rule to all other pairs in Table I (b) at http://ambermd.org/antechamber/gaff.html</p>
<p>These two define where the double bond is in a ring.
GAFF decides on which one is cc or cd depending on the arbitrary atom order.
This intervention we ensure that we do not remove atoms based on that arbitrary order.</p>
<p>This method is idempotent.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">match_gaff2_nondirectional_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If needed, swap cc-cd with cd-cc.</span>
<span class="sd">    If two pairs are linked: (CC/CD) - (CD/CC),</span>
<span class="sd">    replace them according to the left side: (CC/CC) - (CD/CD).</span>
<span class="sd">    Apply this rule to all other pairs in Table I (b) at http://ambermd.org/antechamber/gaff.html</span>

<span class="sd">    These two define where the double bond is in a ring.</span>
<span class="sd">    GAFF decides on which one is cc or cd depending on the arbitrary atom order.</span>
<span class="sd">    This intervention we ensure that we do not remove atoms based on that arbitrary order.</span>

<span class="sd">    This method is idempotent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nondirectionals</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;CC&#39;</span><span class="p">,</span> <span class="s1">&#39;CD&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;CE&#39;</span><span class="p">,</span> <span class="s1">&#39;CF&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;CP&#39;</span><span class="p">,</span> <span class="s1">&#39;CQ&#39;</span><span class="p">},</span>
                         <span class="p">{</span><span class="s1">&#39;PC&#39;</span><span class="p">,</span> <span class="s1">&#39;PD&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;PE&#39;</span><span class="p">,</span> <span class="s1">&#39;PF&#39;</span><span class="p">},</span>
                         <span class="p">{</span><span class="s1">&#39;NC&#39;</span><span class="p">,</span> <span class="s1">&#39;ND&#39;</span><span class="p">})</span>

    <span class="k">for</span> <span class="n">no_direction_pair</span> <span class="ow">in</span> <span class="n">nondirectionals</span><span class="p">:</span>
        <span class="n">corrected_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
            <span class="c1"># check if it is the right combination</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">{</span><span class="n">A1</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">A2</span><span class="o">.</span><span class="n">type</span><span class="p">}</span> <span class="o">==</span> <span class="n">no_direction_pair</span> <span class="ow">or</span> <span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">corrected_pairs</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># ignore if they are already the same</span>
            <span class="k">if</span> <span class="n">A2</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">A1</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># fixme - temporary solution</span>
            <span class="c1"># fixme - do we want to check if we are in a ring?</span>
            <span class="c1"># for now we are simply rewriting the types here so that it passes the &quot;specific atom type&quot; checks later</span>
            <span class="c1"># ie so that later CC-CC and CD-CD are compared</span>
            <span class="c1"># fixme - check if .type is used when writing the final output.</span>
            <span class="n">A2</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">A1</span><span class="o">.</span><span class="n">type</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arbitrary atom type correction. &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;Right atom type </span><span class="si">{</span><span class="n">A2</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s1"> (in </span><span class="si">{</span><span class="n">A2</span><span class="si">}</span><span class="s1">) overwritten with left atom type </span><span class="si">{</span><span class="n">A1</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s1"> (in </span><span class="si">{</span><span class="n">A1</span><span class="si">}</span><span class="s1">). &#39;</span><span class="p">)</span>

            <span class="n">corrected_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">))</span>

    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_net_charge" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_net_charge</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_net_charge</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Calculate the net charge difference across
the matched pairs.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_net_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the net charge difference across</span>
<span class="sd">    the matched pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">net_charge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">charge</span> <span class="o">-</span> <span class="n">n2</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">net_charge</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_matched_with_diff_q" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_matched_with_diff_q</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_matched_with_diff_q</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Returns a list of matched atom pairs that have a different q,
sorted in the descending order (the first pair has the largest q diff).</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_matched_with_diff_q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of matched atom pairs that have a different q,</span>
<span class="sd">    sorted in the descending order (the first pair has the largest q diff).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff_q</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">united_charge</span> <span class="o">-</span> <span class="n">n2</span><span class="o">.</span><span class="n">united_charge</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">diff_q</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">united_charge</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">united_charge</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">apply_net_charge_filter</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">apply_net_charge_filter</span><span class="p">(</span><span class="n">net_charge_threshold</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Averaging the charges across paired atoms introduced inequalities.
Check if the sum of the inequalities in charges is below net_charge.
If not, remove pairs until that net_charge is met.
Which pairs are removed depends on the approach.
Greedy removal of the pairs with the highest difference
can create disjoint blocks which creates issues in themselves.</p>
<h4 id="ties.topology_superimposer.SuperimposedTopology.apply_net_charge_filter--specifically-create-copies-for-each-strategy-here-and-try-a-couple-of-them">Specifically, create copies for each strategy here and try a couple of them.</h4>
<p>Returns: a new suptop where the net_charge_threshold is enforced.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_net_charge_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net_charge_threshold</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Averaging the charges across paired atoms introduced inequalities.</span>
<span class="sd">    Check if the sum of the inequalities in charges is below net_charge.</span>
<span class="sd">    If not, remove pairs until that net_charge is met.</span>
<span class="sd">    Which pairs are removed depends on the approach.</span>
<span class="sd">    Greedy removal of the pairs with the highest difference</span>
<span class="sd">    can create disjoint blocks which creates issues in themselves.</span>

<span class="sd">    # Specifically, create copies for each strategy here and try a couple of them.</span>
<span class="sd">    Returns: a new suptop where the net_charge_threshold is enforced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">approaches</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="s1">&#39;terminal_alch_linked&#39;</span><span class="p">,</span> <span class="s1">&#39;terminal&#39;</span><span class="p">,</span> <span class="s1">&#39;alch_linked&#39;</span><span class="p">,</span> <span class="s1">&#39;leftovers&#39;</span><span class="p">,</span> <span class="s1">&#39;smart&#39;</span><span class="p">]</span>
    <span class="n">rm_disjoint_at_each_step</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

    <span class="c1"># best configuration info</span>
    <span class="n">best_approach</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">suptop_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">rm_disjoint_each_step_conf</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># try all confs</span>
    <span class="k">for</span> <span class="n">rm_disjoint_each_step</span> <span class="ow">in</span> <span class="n">rm_disjoint_at_each_step</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">approach</span> <span class="ow">in</span> <span class="n">approaches</span><span class="p">:</span>
            <span class="c1"># make a shallow copy of the suptop</span>
            <span class="n">next_approach</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># first overall</span>
            <span class="k">if</span> <span class="n">rm_disjoint_each_step</span><span class="p">:</span>
                <span class="n">next_approach</span><span class="o">.</span><span class="n">largest_cc_survives</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># try the strategy</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">next_approach</span><span class="o">.</span><span class="n">get_net_charge</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">net_charge_threshold</span><span class="p">:</span>

                <span class="n">best_candidate_with_h</span> <span class="o">=</span> <span class="n">next_approach</span><span class="o">.</span><span class="n">_smart_netqtol_pair_picker</span><span class="p">(</span><span class="n">approach</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">best_candidate_with_h</span><span class="p">:</span>
                    <span class="n">next_approach</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">rm_disjoint_each_step</span><span class="p">:</span>
                    <span class="n">next_approach</span><span class="o">.</span><span class="n">largest_cc_survives</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># regardless of whether the continuous disjoint removal is being tried or not,</span>
            <span class="c1"># it will be applied at the end</span>
            <span class="c1"># so apply it here at the end in order to make this comparison equivalent</span>
            <span class="n">next_approach</span><span class="o">.</span><span class="n">largest_cc_survives</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_approach</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">suptop_size</span><span class="p">:</span>
                <span class="n">suptop_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_approach</span><span class="p">)</span>
                <span class="n">best_approach</span> <span class="o">=</span> <span class="n">approach</span>
                <span class="n">rm_disjoint_each_step_conf</span> <span class="o">=</span> <span class="n">rm_disjoint_each_step</span>

    <span class="c1"># apply the best strategy to this suptop</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Pair removal strategy (q net tol): </span><span class="si">{</span><span class="n">best_approach</span><span class="si">}</span><span class="s1"> with disjoint CC removed at each step: </span><span class="si">{</span><span class="n">rm_disjoint_each_step_conf</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;To meet q net tol: </span><span class="si">{</span><span class="n">best_approach</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">total_diff</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">rm_disjoint_each_step_conf</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">largest_cc_survives</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_net_charge</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">net_charge_threshold</span><span class="p">:</span>
        <span class="n">best_candidate_with_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smart_netqtol_pair_picker</span><span class="p">(</span><span class="n">best_approach</span><span class="p">)</span>

        <span class="c1"># remove them</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">best_candidate_with_h</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
            <span class="n">diff_q_pairs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">united_charge</span> <span class="o">-</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">united_charge</span><span class="p">)</span>
            <span class="c1"># add to the list of removed because of the net charge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_removed_due_to_net_charge</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pair</span><span class="p">,</span> <span class="n">diff_q_pairs</span><span class="p">])</span>
            <span class="n">total_diff</span> <span class="o">+=</span> <span class="n">diff_q_pairs</span>

        <span class="k">if</span> <span class="n">rm_disjoint_each_step_conf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">largest_cc_survives</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">total_diff</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology._smart_netqtol_pair_picker" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">_smart_netqtol_pair_picker</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_smart_netqtol_pair_picker</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>The appearing and disappearing alchemical region have their
cumulative q different by more than the netq (0.1 typically).
Find the next pair with q imbalance that contributes to it.
Instead of using the greedy strategy:
  - avoid bottleneck atoms (the removed atoms split the molecule into smaller parts)
  - use atoms that are close to the already mutating site</p>
<p>@param strategy: 'greedy', 'terminal_alch_linked', 'terminal', 'alch_linked', 'leftovers', 'smart'</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_smart_netqtol_pair_picker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The appearing and disappearing alchemical region have their</span>
<span class="sd">    cumulative q different by more than the netq (0.1 typically).</span>
<span class="sd">    Find the next pair with q imbalance that contributes to it.</span>
<span class="sd">    Instead of using the greedy strategy:</span>
<span class="sd">      - avoid bottleneck atoms (the removed atoms split the molecule into smaller parts)</span>
<span class="sd">      - use atoms that are close to the already mutating site</span>

<span class="sd">    @param strategy: &#39;greedy&#39;, &#39;terminal_alch_linked&#39;, &#39;terminal&#39;, &#39;alch_linked&#39;, &#39;leftovers&#39;, &#39;smart&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get pairs with different charges</span>
    <span class="n">diff_q_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matched_with_diff_q</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_q_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Did not find any pairs with a different q even though the net tol is not met? &#39;</span><span class="p">)</span>

    <span class="c1"># sort the pairs into categories</span>
    <span class="c1"># use 5 pairs with the largest difference</span>
    <span class="n">diff_sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_pairs_into_categories_qnettol</span><span class="p">(</span><span class="n">diff_q_pairs</span><span class="p">,</span> <span class="n">best_cases_num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;smart&#39;</span><span class="p">:</span>
        <span class="c1"># get the most promising category</span>
        <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">diff_sorted</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">diff_sorted</span><span class="p">[</span><span class="n">cat</span><span class="p">]:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="n">diff_sorted</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="c1"># remove the first pair</span>
        <span class="c1"># fixme - double check this</span>
        <span class="k">return</span> <span class="n">category</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># allow removal of pairs even if the differences are small</span>
    <span class="n">diff_sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_pairs_into_categories_qnettol</span><span class="p">(</span><span class="n">diff_q_pairs</span><span class="p">,</span> <span class="n">best_cases_num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="c1"># for other strategies, take the key directly, but only if there is one</span>
    <span class="k">if</span> <span class="n">diff_sorted</span><span class="p">[</span><span class="n">strategy</span><span class="p">]:</span>
        <span class="n">pairs_in_category</span> <span class="o">=</span> <span class="n">diff_sorted</span><span class="p">[</span><span class="n">strategy</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if there is no option in that category, revert to greedy</span>
        <span class="n">pairs_in_category</span> <span class="o">=</span> <span class="n">diff_sorted</span><span class="p">[</span><span class="s1">&#39;greedy&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">pairs_in_category</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology._sort_pairs_into_categories_qnettol" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">_sort_pairs_into_categories_qnettol</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_sort_pairs_into_categories_qnettol</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">best_cases_num</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>This is a helper function which sorts
matched pairs with different charges into categories, which are:
 - terminal_alch_linked
 - terminal: at most one heavy atom bonded
 - alch_linked: at least one bond to the alchemical region
 - leftovers: not terminal or alch_linked,
 - low_diff</p>
<p>Returns: Ordered Dictionary</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_sort_pairs_into_categories_qnettol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">,</span> <span class="n">best_cases_num</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a helper function which sorts</span>
<span class="sd">    matched pairs with different charges into categories, which are:</span>
<span class="sd">     - terminal_alch_linked</span>
<span class="sd">     - terminal: at most one heavy atom bonded</span>
<span class="sd">     - alch_linked: at least one bond to the alchemical region</span>
<span class="sd">     - leftovers: not terminal or alch_linked,</span>
<span class="sd">     - low_diff</span>

<span class="sd">    Returns: Ordered Dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sorted_categories</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;terminal_alch_linked&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;terminal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;alch_linked&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;greedy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;leftovers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;low_diff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">app_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_appearing_atoms</span><span class="p">()</span>
    <span class="n">dis_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_disappearing_atoms</span><span class="p">()</span>

    <span class="c1"># fixme: maybe use a threshold rather than a number of cases?</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[:</span><span class="n">best_cases_num</span><span class="p">]:</span>
        <span class="c1"># ignore hydrogens on their own</span>
        <span class="c1"># if pair[0].element == &#39;H&#39;:</span>
        <span class="c1">#     continue</span>

        <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">bonds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">[</span><span class="n">pair</span><span class="p">]]</span>

        <span class="c1"># ignore hydrogens in these connections (non-consequential)</span>
        <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">neighbours</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span>
        <span class="n">heavy</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">neighbours</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span>

        <span class="c1"># attach the hydrogens to be removed as well</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">+</span> <span class="n">hydrogens</span>

        <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;greedy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>

        <span class="c1"># check if the current pair is linked to the alchemical region</span>
        <span class="n">linked_to_alchemical</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom</span> <span class="ow">in</span> <span class="n">dis_atoms</span><span class="p">:</span>
                <span class="n">linked_to_alchemical</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom</span> <span class="ow">in</span> <span class="n">app_atoms</span><span class="p">:</span>
                <span class="n">linked_to_alchemical</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heavy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">linked_to_alchemical</span><span class="p">:</span>
            <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;terminal_alch_linked&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heavy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;terminal&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linked_to_alchemical</span><span class="p">:</span>
            <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;alch_linked&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heavy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">linked_to_alchemical</span><span class="p">:</span>
            <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;leftovers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>

    <span class="c1"># carry out for the pairs that have a smaller Q diff</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[</span><span class="n">best_cases_num</span><span class="p">:]:</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">bonds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">[</span><span class="n">pair</span><span class="p">]]</span>
        <span class="c1"># consider the attached hydrogens</span>
        <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">neighbours</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span>
        <span class="c1"># attach the hydrogens to be removed as well</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">+</span> <span class="n">hydrogens</span>

        <span class="n">sorted_categories</span><span class="p">[</span><span class="s1">&#39;low_diff&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sorted_categories</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.remove_attached_hydrogens" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">remove_attached_hydrogens</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">remove_attached_hydrogens</span><span class="p">(</span><span class="n">node_pair</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>The node_pair to which these hydrogens are attached was removed.
Remove the dangling hydrogens.</p>
<p>Check if these hydrogen are matched/superimposed. If that is the case. Remove the pairs.</p>
<p>Note that if the hydrogens are paired and attached to node_pairA,
they have to be attached to node_pairB, as a rule of being a match.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1531</span>
<span class="normal">1532</span>
<span class="normal">1533</span>
<span class="normal">1534</span>
<span class="normal">1535</span>
<span class="normal">1536</span>
<span class="normal">1537</span>
<span class="normal">1538</span>
<span class="normal">1539</span>
<span class="normal">1540</span>
<span class="normal">1541</span>
<span class="normal">1542</span>
<span class="normal">1543</span>
<span class="normal">1544</span>
<span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span>
<span class="normal">1551</span>
<span class="normal">1552</span>
<span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">remove_attached_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_pair</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The node_pair to which these hydrogens are attached was removed.</span>
<span class="sd">    Remove the dangling hydrogens.</span>

<span class="sd">    Check if these hydrogen are matched/superimposed. If that is the case. Remove the pairs.</span>

<span class="sd">    Note that if the hydrogens are paired and attached to node_pairA,</span>
<span class="sd">    they have to be attached to node_pairB, as a rule of being a match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># skip if no hydrogens found</span>
    <span class="k">if</span> <span class="n">node_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No dangling hydrogens&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">attached_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">[</span><span class="n">node_pair</span><span class="p">]</span>

    <span class="n">removed_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">bond_types</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attached_pairs</span><span class="p">):</span>
        <span class="c1"># ignore non hydrogens</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Removed dangling hydrogen pair: </span><span class="si">{</span><span class="n">pair</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">removed_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">removed_pairs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.find_lowest_rmsd_mirror" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">find_lowest_rmsd_mirror</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">find_lowest_rmsd_mirror</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Walk through the different mirrors and out of all options select the one
that has the lowest RMSD. This way we increase the chance of getting a better match.
However, long term it will be necessary to use the dihedrals to ensure that we match
the atoms better.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span>
<span class="normal">1580</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_lowest_rmsd_mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Walk through the different mirrors and out of all options select the one</span>
<span class="sd">    that has the lowest RMSD. This way we increase the chance of getting a better match.</span>
<span class="sd">    However, long term it will be necessary to use the dihedrals to ensure that we match</span>
<span class="sd">    the atoms better.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># fixme - you have to also take into account the &quot;weird / other symmetries&quot; besides mirrors</span>
    <span class="n">winner</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="n">lowest_rmsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mirror</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirrors</span><span class="p">:</span>
        <span class="n">mirror_rmsd</span> <span class="o">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">rmsd</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mirror_rmsd</span> <span class="o">&lt;</span> <span class="n">lowest_rmsd</span><span class="p">:</span>
            <span class="n">lowest_rmsd</span> <span class="o">=</span> <span class="n">mirror_rmsd</span>
            <span class="n">winner</span> <span class="o">=</span> <span class="n">mirror</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">winner</span><span class="p">:</span>
        <span class="c1"># False here means that it is not a mirror</span>
        <span class="k">return</span> <span class="n">lowest_rmsd</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lowest_rmsd</span><span class="p">,</span> <span class="n">winner</span><span class="p">,</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.is_subgraph_of_global_top" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">is_subgraph_of_global_top</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">is_subgraph_of_global_top</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Check if after superimposition, one graph is a subgraph of another
:return:</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_subgraph_of_global_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if after superimposition, one graph is a subgraph of another</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check if one topology is a subgraph of another topology</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.rmsd" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">rmsd</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">rmsd</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>For each pair take the distance, and then get rmsd, so root(mean(square(deviation)))</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rmsd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each pair take the distance, and then get rmsd, so root(mean(square(deviation)))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">dsts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atomA</span><span class="p">,</span> <span class="n">atomB</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">((</span><span class="n">atomA</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">atomB</span><span class="o">.</span><span class="n">position</span><span class="p">))))</span>
        <span class="n">dsts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">dsts</span><span class="p">)))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.link_pairs" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">link_pairs</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">link_pairs</span><span class="p">(</span><span class="n">from_pair</span><span class="p">,</span> <span class="n">pairs</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>This helps take care of the bonds.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">link_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_pair</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This helps take care of the bonds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">from_pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span>
    <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">bond_types</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="c1"># the parent pair should have its list of pairs</span>
        <span class="k">assert</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;not found pair </span><span class="si">{</span><span class="n">pair</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="c1"># link X-Y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">[</span><span class="n">from_pair</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pair</span><span class="p">,</span> <span class="n">bond_types</span><span class="p">))</span>
        <span class="c1"># link Y-X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">from_pair</span><span class="p">,</span> <span class="n">bond_types</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.find_mirror_choices" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">find_mirror_choices</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">find_mirror_choices</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>For each pair (A1, B1) find all the other options in the mirrors where (A1, B2)</p>
<h4 id="ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--ie-ignore-x-b1-search-if-we-repair-from-a-to-b-then-b-to-a-should-be-repaired-too">ie Ignore (X, B1) search, if we repair from A to B, then B to A should be repaired too</h4>
<h4 id="ties.topology_superimposer.SuperimposedTopology.find_mirror_choices--fixme-is-this-still-necessary-if-we-are-traversing-all-paths">fixme - is this still necessary if we are traversing all paths?</h4>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_mirror_choices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each pair (A1, B1) find all the other options in the mirrors where (A1, B2)</span>
<span class="sd">    # ie Ignore (X, B1) search, if we repair from A to B, then B to A should be repaired too</span>

<span class="sd">    # fixme - is this still necessary if we are traversing all paths?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">choices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">A1</span><span class="p">,</span> <span class="n">B1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="n">options_for_a1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mirror</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirrors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">A2</span><span class="p">,</span> <span class="n">B2</span> <span class="ow">in</span> <span class="n">mirror</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">A1</span> <span class="ow">is</span> <span class="n">A2</span> <span class="ow">and</span> <span class="n">B1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">B2</span><span class="p">:</span>
                    <span class="n">options_for_a1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">options_for_a1</span><span class="p">:</span>
            <span class="n">options_for_a1</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">B1</span><span class="p">)</span>
            <span class="n">choices</span><span class="p">[</span><span class="n">A1</span><span class="p">]</span> <span class="o">=</span> <span class="n">options_for_a1</span>

    <span class="k">return</span> <span class="n">choices</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.add_alternative_mapping" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">add_alternative_mapping</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">add_alternative_mapping</span><span class="p">(</span><span class="n">weird_symmetry</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>This means that there is another way to traverse and overlap the two molecules,
but that the self is better (e.g. lower rmsd) than the other one</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">add_alternative_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weird_symmetry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This means that there is another way to traverse and overlap the two molecules,</span>
<span class="sd">    but that the self is better (e.g. lower rmsd) than the other one</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">alternative_mappings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weird_symmetry</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">correct_for_coordinates</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">correct_for_coordinates</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Use the coordinates of the atoms, to figure out which symmetries are the correct ones.
Rearrange so that the overall topology represents the one that has appropriate coordinates,
whereas all the mirrors represent the other poor matches.</p>
<h4 id="ties.topology_superimposer.SuperimposedTopology.correct_for_coordinates--fixme-ensure-that-each-node-is-used-only-once-at-the-end">fixme - ensure that each node is used only once at the end</h4>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span>
<span class="normal">1732</span>
<span class="normal">1733</span>
<span class="normal">1734</span>
<span class="normal">1735</span>
<span class="normal">1736</span>
<span class="normal">1737</span>
<span class="normal">1738</span>
<span class="normal">1739</span>
<span class="normal">1740</span>
<span class="normal">1741</span>
<span class="normal">1742</span>
<span class="normal">1743</span>
<span class="normal">1744</span>
<span class="normal">1745</span>
<span class="normal">1746</span>
<span class="normal">1747</span>
<span class="normal">1748</span>
<span class="normal">1749</span>
<span class="normal">1750</span>
<span class="normal">1751</span>
<span class="normal">1752</span>
<span class="normal">1753</span>
<span class="normal">1754</span>
<span class="normal">1755</span>
<span class="normal">1756</span>
<span class="normal">1757</span>
<span class="normal">1758</span>
<span class="normal">1759</span>
<span class="normal">1760</span>
<span class="normal">1761</span>
<span class="normal">1762</span>
<span class="normal">1763</span>
<span class="normal">1764</span>
<span class="normal">1765</span>
<span class="normal">1766</span>
<span class="normal">1767</span>
<span class="normal">1768</span>
<span class="normal">1769</span>
<span class="normal">1770</span>
<span class="normal">1771</span>
<span class="normal">1772</span>
<span class="normal">1773</span>
<span class="normal">1774</span>
<span class="normal">1775</span>
<span class="normal">1776</span>
<span class="normal">1777</span>
<span class="normal">1778</span>
<span class="normal">1779</span>
<span class="normal">1780</span>
<span class="normal">1781</span>
<span class="normal">1782</span>
<span class="normal">1783</span>
<span class="normal">1784</span>
<span class="normal">1785</span>
<span class="normal">1786</span>
<span class="normal">1787</span>
<span class="normal">1788</span>
<span class="normal">1789</span>
<span class="normal">1790</span>
<span class="normal">1791</span>
<span class="normal">1792</span>
<span class="normal">1793</span>
<span class="normal">1794</span>
<span class="normal">1795</span>
<span class="normal">1796</span>
<span class="normal">1797</span>
<span class="normal">1798</span>
<span class="normal">1799</span>
<span class="normal">1800</span>
<span class="normal">1801</span>
<span class="normal">1802</span>
<span class="normal">1803</span>
<span class="normal">1804</span>
<span class="normal">1805</span>
<span class="normal">1806</span>
<span class="normal">1807</span>
<span class="normal">1808</span>
<span class="normal">1809</span>
<span class="normal">1810</span>
<span class="normal">1811</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">correct_for_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the coordinates of the atoms, to figure out which symmetries are the correct ones.</span>
<span class="sd">    Rearrange so that the overall topology represents the one that has appropriate coordinates,</span>
<span class="sd">    whereas all the mirrors represent the other poor matches.</span>

<span class="sd">    # fixme - ensure that each node is used only once at the end</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check if you have coordinates</span>
    <span class="c1"># fixme - rn we have it, check</span>

    <span class="c1"># superimpose the coordinates, ensure a good match</span>
    <span class="c1"># fixme - this was done before, so let&#39;s leave this way for now</span>

    <span class="c1"># fixme - consider putting this conf as a mirror, and then modifying this</span>

    <span class="c1"># check which are preferable for each of the mirrors</span>
    <span class="c1"># we have to match mirrors to each other, ie say we have (O1=O3) and (O2=O4)</span>
    <span class="c1"># we should find the mirror matching (O1=O4) and (O2=O3)</span>
    <span class="c1"># so note that we have a closure here: All 4 atoms are used in both cases, and each time are paired differently.</span>
    <span class="c1"># So this is how we defined the mirror - and therefore we can reduce this issue to the minimal mirrors.</span>
    <span class="c1"># fixme - is this a cycle? O1-O3-O2-O4-O1</span>
    <span class="c1"># Let&#39;s try to define a chain: O1 =O3, and O1 =O4, and O2 is =O3 or =O4</span>
    <span class="c1"># So we have to define how to find O1 matching to different parts, and then decide</span>
    <span class="n">choices_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_mirror_choices</span><span class="p">()</span>

    <span class="c1"># fixme - rewrite this method to eliminate one by one the hydrogens that fit in perfectly,</span>
    <span class="c1"># some of them will have a plural significant match, while others might be hazy,</span>
    <span class="c1"># so we have to eliminate them one by one, searching the best matches and then eliminating them</span>

    <span class="n">removed_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">A1</span><span class="p">,</span> <span class="n">choices</span> <span class="ow">in</span> <span class="n">choices_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># remove the old tuple</span>
        <span class="c1"># fixme - not sure if this is the right way to go,</span>
        <span class="c1"># but we break all the rules when applying this simplistic strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">((</span><span class="n">A1</span><span class="p">,</span> <span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">removed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span>
        <span class="n">removed_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">shortest_dsts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">added_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># better matches</span>
    <span class="c1"># for each atom that mismatches, scan all molecules and find the best match and eliminate it</span>
    <span class="n">blacklisted_bxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">choices_mapping</span><span class="p">)):</span>
        <span class="c1"># fixme - optimisation of this could be such that if they two atoms are within 0.2A or something</span>
        <span class="c1"># then they are straight away fixed</span>
        <span class="n">closest_dst</span> <span class="o">=</span> <span class="mi">9999999</span>
        <span class="n">closest_a1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">closest_bx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">A1</span><span class="p">,</span> <span class="n">choices</span> <span class="ow">in</span> <span class="n">choices_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># so we have several choices for A1, and now naively we are taking the one that is closest, and</span>
            <span class="c1"># assuming the superimposition is easy, this would work</span>

            <span class="c1"># FIXME - you cannot use simply distances, if for A1 and A2 the best is BX, then BX there should be</span>
            <span class="c1"># rules for that</span>
            <span class="k">for</span> <span class="n">BX</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">BX</span> <span class="ow">in</span> <span class="n">blacklisted_bxs</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># use the distance_array because of PBC correction and speed</span>
                <span class="n">a1_bx_dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">A1</span><span class="o">.</span><span class="n">position</span><span class="o">-</span><span class="n">BX</span><span class="o">.</span><span class="n">position</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">a1_bx_dst</span> <span class="o">&lt;</span> <span class="n">closest_dst</span><span class="p">:</span>
                    <span class="n">closest_dst</span> <span class="o">=</span> <span class="n">a1_bx_dst</span>
                    <span class="n">closest_bx</span> <span class="o">=</span> <span class="n">BX</span>
                    <span class="n">closest_a1</span> <span class="o">=</span> <span class="n">A1</span>

        <span class="c1"># across all the possible choices, found the best match now:</span>
        <span class="n">blacklisted_bxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_bx</span><span class="p">)</span>
        <span class="n">shortest_dsts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_dst</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">closest_a1</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> is matching best with </span><span class="si">{</span><span class="n">closest_bx</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># remove the old tuple and insert the new one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node_pair</span><span class="p">((</span><span class="n">closest_a1</span><span class="p">,</span> <span class="n">closest_bx</span><span class="p">))</span>
        <span class="n">added_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">closest_a1</span><span class="p">)</span>
        <span class="n">added_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">closest_bx</span><span class="p">)</span>
        <span class="c1"># remove from consideration</span>
        <span class="k">del</span> <span class="n">choices_mapping</span><span class="p">[</span><span class="n">closest_a1</span><span class="p">]</span>
        <span class="c1"># blacklist</span>

    <span class="c1"># fixme - check that the added and the removed nodes are the same set</span>
    <span class="k">assert</span> <span class="n">removed_nodes</span> <span class="o">==</span> <span class="n">added_nodes</span>

    <span class="c1"># this is the corrected region score (there might not be any)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shortest_dsts</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">avg_dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shortest_dsts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fixme</span>
        <span class="n">avg_dst</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">avg_dst</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.enforce_no_partial_rings" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">enforce_no_partial_rings</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">enforce_no_partial_rings</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>http://www.alchemistry.org/wiki/Constructing_a_Pathway_of_Intermediate_States
It is the opening or closing of the rings that is an issue.
This means that if any atom on a ring disappears, it breaks the ring,
and therefore the entire ring should be removed and appeared again.</p>
<p>If any atom is removed, it should check if it affects other rings,
therefore cascading removing further rings.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1824</span>
<span class="normal">1825</span>
<span class="normal">1826</span>
<span class="normal">1827</span>
<span class="normal">1828</span>
<span class="normal">1829</span>
<span class="normal">1830</span>
<span class="normal">1831</span>
<span class="normal">1832</span>
<span class="normal">1833</span>
<span class="normal">1834</span>
<span class="normal">1835</span>
<span class="normal">1836</span>
<span class="normal">1837</span>
<span class="normal">1838</span>
<span class="normal">1839</span>
<span class="normal">1840</span>
<span class="normal">1841</span>
<span class="normal">1842</span>
<span class="normal">1843</span>
<span class="normal">1844</span>
<span class="normal">1845</span>
<span class="normal">1846</span>
<span class="normal">1847</span>
<span class="normal">1848</span>
<span class="normal">1849</span>
<span class="normal">1850</span>
<span class="normal">1851</span>
<span class="normal">1852</span>
<span class="normal">1853</span>
<span class="normal">1854</span>
<span class="normal">1855</span>
<span class="normal">1856</span>
<span class="normal">1857</span>
<span class="normal">1858</span>
<span class="normal">1859</span>
<span class="normal">1860</span>
<span class="normal">1861</span>
<span class="normal">1862</span>
<span class="normal">1863</span>
<span class="normal">1864</span>
<span class="normal">1865</span>
<span class="normal">1866</span>
<span class="normal">1867</span>
<span class="normal">1868</span>
<span class="normal">1869</span>
<span class="normal">1870</span>
<span class="normal">1871</span>
<span class="normal">1872</span>
<span class="normal">1873</span>
<span class="normal">1874</span>
<span class="normal">1875</span>
<span class="normal">1876</span>
<span class="normal">1877</span>
<span class="normal">1878</span>
<span class="normal">1879</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">enforce_no_partial_rings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    http://www.alchemistry.org/wiki/Constructing_a_Pathway_of_Intermediate_States</span>
<span class="sd">    It is the opening or closing of the rings that is an issue.</span>
<span class="sd">    This means that if any atom on a ring disappears, it breaks the ring,</span>
<span class="sd">    and therefore the entire ring should be removed and appeared again.</span>

<span class="sd">    If any atom is removed, it should check if it affects other rings,</span>
<span class="sd">    therefore cascading removing further rings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAX_CIRCLE_SIZE</span> <span class="o">=</span> <span class="mi">7</span>

    <span class="c1"># get circles in the original ligands</span>
    <span class="n">l_circles</span><span class="p">,</span> <span class="n">r_circles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_original_circles</span><span class="p">()</span>
    <span class="n">l_matched_circles</span><span class="p">,</span> <span class="n">r_matched_circles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circles</span><span class="p">()</span>

    <span class="c1"># right now we are filtering out circles that are larger than 7 atoms,</span>
    <span class="n">l_circles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MAX_CIRCLE_SIZE</span><span class="p">,</span> <span class="n">l_circles</span><span class="p">))</span>
    <span class="n">r_circles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MAX_CIRCLE_SIZE</span><span class="p">,</span> <span class="n">r_circles</span><span class="p">))</span>
    <span class="n">l_matched_circles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MAX_CIRCLE_SIZE</span><span class="p">,</span> <span class="n">l_matched_circles</span><span class="p">))</span>
    <span class="n">r_matched_circles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MAX_CIRCLE_SIZE</span><span class="p">,</span> <span class="n">r_matched_circles</span><span class="p">))</span>

    <span class="c1"># first, see which matched circles eliminate themselves (simply matched circles)</span>
    <span class="n">correct_circles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l_matched_circle</span> <span class="ow">in</span> <span class="n">l_matched_circles</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">r_matched_circle</span> <span class="ow">in</span> <span class="n">r_matched_circles</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">are_matched_sets</span><span class="p">(</span><span class="n">l_matched_circle</span><span class="p">,</span> <span class="n">r_matched_circle</span><span class="p">):</span>
                <span class="c1"># These two circles fully overlap, so they are fine</span>
                <span class="n">l_matched_circles</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_matched_circle</span><span class="p">)</span>
                <span class="n">r_matched_circles</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r_matched_circle</span><span class="p">)</span>
                <span class="c1"># update the original circles</span>
                <span class="n">l_circles</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l_matched_circle</span><span class="p">)</span>
                <span class="n">r_circles</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r_matched_circle</span><span class="p">)</span>
                <span class="n">correct_circles</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">l_matched_circle</span><span class="p">,</span> <span class="n">r_matched_circle</span><span class="p">))</span>

    <span class="c1"># at this point, we should not have any matched circles, in either R and L</span>
    <span class="c1"># this is because we do not allow one ligand to have a matched circle, while another ligand not</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_matched_circles</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_matched_circles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># so now we have to work with the original rings which have not been overlapped,</span>
        <span class="c1"># these most likely means that there are mutations preventing it from overlapping</span>
        <span class="n">l_removed_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_unmatched_ring_atoms</span><span class="p">(</span><span class="n">l_circles</span><span class="p">)</span>
        <span class="n">r_removed_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_unmatched_ring_atoms</span><span class="p">(</span><span class="n">r_circles</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l_circle</span><span class="p">,</span> <span class="n">r_circle</span> <span class="ow">in</span> <span class="n">correct_circles</span><span class="p">:</span>
            <span class="c1"># checked if any removed atom affected any of the correct circles</span>
            <span class="n">affected_l_circle</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">l_atom</span> <span class="ow">in</span> <span class="n">l_circle</span> <span class="k">for</span> <span class="n">l_atom</span><span class="p">,</span> <span class="n">r_atom</span> <span class="ow">in</span> <span class="n">l_removed_pairs</span><span class="p">)</span>
            <span class="n">affected_r_circle</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">r_atom</span> <span class="ow">in</span> <span class="n">r_circle</span> <span class="k">for</span> <span class="n">l_atom</span><span class="p">,</span> <span class="n">r_atom</span> <span class="ow">in</span> <span class="n">r_removed_pairs</span><span class="p">)</span>
            <span class="c1"># add the circle to be disassembled</span>
            <span class="k">if</span> <span class="n">affected_l_circle</span> <span class="ow">or</span> <span class="n">affected_r_circle</span><span class="p">:</span>
                <span class="n">l_circles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_circle</span><span class="p">)</span>
                <span class="n">r_circles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_circle</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_removed_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_removed_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">_remove_unmatched_ring_atoms</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_remove_unmatched_ring_atoms</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>A helper function. Removes pairs with the given atoms.</p>
<p>The removed atoms are classified as unmatched_rings.</p>
<h5 id="ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms--parameters">Parameters</h5>
<p>circles : list
    A list of iterables. Each atom in a circle, if matched, is removed together with
    the corresponding atom from the suptop.
    The user should ensure that the rings/circles are partial</p>
<h5 id="ties.topology_superimposer.SuperimposedTopology._remove_unmatched_ring_atoms--returns">Returns</h5>
<p>removed : bool
    True if any atom was removed. False otherwise.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1881</span>
<span class="normal">1882</span>
<span class="normal">1883</span>
<span class="normal">1884</span>
<span class="normal">1885</span>
<span class="normal">1886</span>
<span class="normal">1887</span>
<span class="normal">1888</span>
<span class="normal">1889</span>
<span class="normal">1890</span>
<span class="normal">1891</span>
<span class="normal">1892</span>
<span class="normal">1893</span>
<span class="normal">1894</span>
<span class="normal">1895</span>
<span class="normal">1896</span>
<span class="normal">1897</span>
<span class="normal">1898</span>
<span class="normal">1899</span>
<span class="normal">1900</span>
<span class="normal">1901</span>
<span class="normal">1902</span>
<span class="normal">1903</span>
<span class="normal">1904</span>
<span class="normal">1905</span>
<span class="normal">1906</span>
<span class="normal">1907</span>
<span class="normal">1908</span>
<span class="normal">1909</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_remove_unmatched_ring_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">circles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function. Removes pairs with the given atoms.</span>

<span class="sd">    The removed atoms are classified as unmatched_rings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    circles : list</span>
<span class="sd">        A list of iterables. Each atom in a circle, if matched, is removed together with</span>
<span class="sd">        the corresponding atom from the suptop.</span>
<span class="sd">        The user should ensure that the rings/circles are partial</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    removed : bool</span>
<span class="sd">        True if any atom was removed. False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">removed_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">circle</span> <span class="ow">in</span> <span class="n">circles</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">unmatched_ring_atom</span> <span class="ow">in</span> <span class="n">circle</span><span class="p">:</span>
            <span class="c1"># find if the ring has a match</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">unmatched_ring_atom</span><span class="p">):</span>
                <span class="c1"># remove the pair from matched</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pair_with_atom</span><span class="p">(</span><span class="n">unmatched_ring_atom</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_unmatched_rings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                <span class="n">removed_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">removed_pairs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_topology_similarity_score</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_topology_similarity_score</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Having the superimposed A(Left) and B(Right), score the match.
This is a rather naive approach. It compares A-B match by checking
if any of the node X and X' in A and B have a bond to another node Y that is
not present in A-B, but that is directly reachable from X and X' in a similar way.
We ignore the charge of Y and focus here only on the topology.</p>
<p>For every "external bond" from the component we try to see if topologically it scores well.
So for any matched pair, we extend the topology and the score is equal to the size of
such an component. Then we do this for all other matching nodes and sum the score.</p>
<h4 id="ties.topology_superimposer.SuperimposedTopology.get_topology_similarity_score--fixme-maybe-you-should-use-the-entire-graphs-in-order-to-see-if-this-is-good-or-not">fixme - maybe you should use the entire graphs in order to see if this is good or not?</h4>
<p>so the simpler approach is to ignore charges for a second to only understand the relative place in the topology,
in other words, the question is, how similar are two nodes A and B vs A and C? let's traverse A and B together,
and then A and C together, and while doing that, ignore the charges. In this case, A and B could
get together 20 parts, whereas A and C traverses together 22 parts, meaning that topologically,
it is a more suitable one, because it closer corresponds to the actual atom.
Note that this approach has problem:
- you can imagine A and B traversing where B is in a completely wrong global place, but it
happens to have a bigger part common to A, than C which globally is correct. Answer to this:
at the same time, ideally B would be excluded, because it should have been already matched to another
topology.</p>
<p>Alternative approach: take into consideration other components and the distance from this component
to them. Specifically, allows mismatches</p>
<p>FIXME - allow flexible mismatches. Meaning if someone mutates one bonded atom, then it might be noticed
that</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1920</span>
<span class="normal">1921</span>
<span class="normal">1922</span>
<span class="normal">1923</span>
<span class="normal">1924</span>
<span class="normal">1925</span>
<span class="normal">1926</span>
<span class="normal">1927</span>
<span class="normal">1928</span>
<span class="normal">1929</span>
<span class="normal">1930</span>
<span class="normal">1931</span>
<span class="normal">1932</span>
<span class="normal">1933</span>
<span class="normal">1934</span>
<span class="normal">1935</span>
<span class="normal">1936</span>
<span class="normal">1937</span>
<span class="normal">1938</span>
<span class="normal">1939</span>
<span class="normal">1940</span>
<span class="normal">1941</span>
<span class="normal">1942</span>
<span class="normal">1943</span>
<span class="normal">1944</span>
<span class="normal">1945</span>
<span class="normal">1946</span>
<span class="normal">1947</span>
<span class="normal">1948</span>
<span class="normal">1949</span>
<span class="normal">1950</span>
<span class="normal">1951</span>
<span class="normal">1952</span>
<span class="normal">1953</span>
<span class="normal">1954</span>
<span class="normal">1955</span>
<span class="normal">1956</span>
<span class="normal">1957</span>
<span class="normal">1958</span>
<span class="normal">1959</span>
<span class="normal">1960</span>
<span class="normal">1961</span>
<span class="normal">1962</span>
<span class="normal">1963</span>
<span class="normal">1964</span>
<span class="normal">1965</span>
<span class="normal">1966</span>
<span class="normal">1967</span>
<span class="normal">1968</span>
<span class="normal">1969</span>
<span class="normal">1970</span>
<span class="normal">1971</span>
<span class="normal">1972</span>
<span class="normal">1973</span>
<span class="normal">1974</span>
<span class="normal">1975</span>
<span class="normal">1976</span>
<span class="normal">1977</span>
<span class="normal">1978</span>
<span class="normal">1979</span>
<span class="normal">1980</span>
<span class="normal">1981</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_topology_similarity_score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Having the superimposed A(Left) and B(Right), score the match.</span>
<span class="sd">    This is a rather naive approach. It compares A-B match by checking</span>
<span class="sd">    if any of the node X and X&#39; in A and B have a bond to another node Y that is</span>
<span class="sd">    not present in A-B, but that is directly reachable from X and X&#39; in a similar way.</span>
<span class="sd">    We ignore the charge of Y and focus here only on the topology.</span>

<span class="sd">    For every &quot;external bond&quot; from the component we try to see if topologically it scores well.</span>
<span class="sd">    So for any matched pair, we extend the topology and the score is equal to the size of</span>
<span class="sd">    such an component. Then we do this for all other matching nodes and sum the score.</span>

<span class="sd">    # fixme - maybe you should use the entire graphs in order to see if this is good or not?</span>
<span class="sd">    so the simpler approach is to ignore charges for a second to only understand the relative place in the topology,</span>
<span class="sd">    in other words, the question is, how similar are two nodes A and B vs A and C? let&#39;s traverse A and B together,</span>
<span class="sd">    and then A and C together, and while doing that, ignore the charges. In this case, A and B could</span>
<span class="sd">    get together 20 parts, whereas A and C traverses together 22 parts, meaning that topologically,</span>
<span class="sd">    it is a more suitable one, because it closer corresponds to the actual atom.</span>
<span class="sd">    Note that this approach has problem:</span>
<span class="sd">    - you can imagine A and B traversing where B is in a completely wrong global place, but it</span>
<span class="sd">    happens to have a bigger part common to A, than C which globally is correct. Answer to this:</span>
<span class="sd">    at the same time, ideally B would be excluded, because it should have been already matched to another</span>
<span class="sd">    topology.</span>

<span class="sd">    Alternative approach: take into consideration other components and the distance from this component</span>
<span class="sd">    to them. Specifically, allows mismatches</span>

<span class="sd">    FIXME - allow flexible mismatches. Meaning if someone mutates one bonded atom, then it might be noticed</span>
<span class="sd">    that</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">overall_score</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span> <span class="n">node_b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="c1"># for every neighbour in Left</span>
        <span class="k">for</span> <span class="n">a_bond</span> <span class="ow">in</span> <span class="n">node_a</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="c1"># if this bonded atom is present in this superimposed topology (or component), ignore</span>
            <span class="c1"># fixme - surely this can be done better, you could have &quot;contains this atom or something&quot;</span>
            <span class="n">in_this_sup_top</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">other_a</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a_bond</span><span class="o">.</span><span class="n">atom</span> <span class="o">==</span> <span class="n">other_a</span><span class="p">:</span>
                    <span class="n">in_this_sup_top</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">in_this_sup_top</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># a candidate is found that could make the node_a and node_b more similar,</span>
            <span class="c1"># so check if it is also present in node_b,</span>
            <span class="c1"># ignore the charges to focus only on the topology and put aside the parameterisation</span>
            <span class="k">for</span> <span class="n">b_bond</span> <span class="ow">in</span> <span class="n">node_b</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="c1"># fixme - what if the atom is mutated into a different atom? we have to be able</span>
                <span class="c1"># to relies on other measures than just this one, here the situation is that the topology</span>
                <span class="c1"># is enough to answer the question (because only charges were modified),</span>
                <span class="c1"># however, this gets more tricky</span>
                <span class="c1"># fixme - hardcoded</span>
                <span class="n">score</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_overlay</span><span class="p">(</span><span class="n">a_bond</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">b_bond</span><span class="o">.</span><span class="n">atom</span><span class="p">))</span>

                <span class="c1"># this is a purely topology based score, the bigger the overlap the better the match</span>
                <span class="n">overall_score</span> <span class="o">+=</span> <span class="n">score</span>

            <span class="c1"># check if the neighbour points to any node X that is not used in Left,</span>

            <span class="c1"># if node_b leads to the same node X</span>
    <span class="k">return</span> <span class="n">overall_score</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.unmatch_pairs_with_different_charges" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">unmatch_pairs_with_different_charges</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">unmatch_pairs_with_different_charges</span><span class="p">(</span><span class="n">atol</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Removes the matched pairs where atom charges are more different
than the provided absolute tolerance atol (units in Electrons).</p>
<p>remove_dangling_h: After removing any pair it also removes any bound hydrogen(s).</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1983</span>
<span class="normal">1984</span>
<span class="normal">1985</span>
<span class="normal">1986</span>
<span class="normal">1987</span>
<span class="normal">1988</span>
<span class="normal">1989</span>
<span class="normal">1990</span>
<span class="normal">1991</span>
<span class="normal">1992</span>
<span class="normal">1993</span>
<span class="normal">1994</span>
<span class="normal">1995</span>
<span class="normal">1996</span>
<span class="normal">1997</span>
<span class="normal">1998</span>
<span class="normal">1999</span>
<span class="normal">2000</span>
<span class="normal">2001</span>
<span class="normal">2002</span>
<span class="normal">2003</span>
<span class="normal">2004</span>
<span class="normal">2005</span>
<span class="normal">2006</span>
<span class="normal">2007</span>
<span class="normal">2008</span>
<span class="normal">2009</span>
<span class="normal">2010</span>
<span class="normal">2011</span>
<span class="normal">2012</span>
<span class="normal">2013</span>
<span class="normal">2014</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">unmatch_pairs_with_different_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes the matched pairs where atom charges are more different</span>
<span class="sd">    than the provided absolute tolerance atol (units in Electrons).</span>

<span class="sd">    remove_dangling_h: After removing any pair it also removes any bound hydrogen(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">removed_hydrogen_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node1</span><span class="o">.</span><span class="n">united_eq</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">removed_hydrogen_pairs</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># remove this pair</span>
        <span class="c1"># use full logging for this kind of information</span>
        <span class="c1"># print(&#39;Q: removing nodes&#39;, (node1, node2)) # to do - consider making this into a logging feature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">((</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">))</span>

        <span class="c1"># keep track of the removed atoms due to the charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">((</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">node2</span><span class="o">.</span><span class="n">united_charge</span> <span class="o">-</span> <span class="n">node1</span><span class="o">.</span><span class="n">united_charge</span><span class="p">)))</span>

        <span class="c1"># Removed functionality: remove the dangling hydrogens</span>
        <span class="n">removed_h_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_attached_hydrogens</span><span class="p">((</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">))</span>
        <span class="n">removed_hydrogen_pairs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">removed_h_pairs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">h_pair</span> <span class="ow">in</span> <span class="n">removed_h_pairs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">h_pair</span><span class="p">,</span> <span class="s1">&#39;dangling&#39;</span><span class="p">))</span>

    <span class="c1"># sort the removed in a descending order</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.is_consistent_with" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">is_consistent_with</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">is_consistent_with</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">



<details class="conditions" open>
  <summary>Conditions</summary>
  <ul>
<li>There should be a minimal overlap of at least 1 node.</li>
<li>There is no pair (Na=Nb) in this sup top such that (Na=Nc) or (Nb=Nc) for some Nc in the other suptop.</li>
<li>The number of cycles in this suptop and the other suptop must be the same (?removing for now, fixme)</li>
<li>merging cannot lead to new cycles?? (fixme). What is the reasoning behind this?
    I mean, I guess the assumption is that, if the cycles were compatible,
    they would be created during the search, rather than now while merging. ??</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2040</span>
<span class="normal">2041</span>
<span class="normal">2042</span>
<span class="normal">2043</span>
<span class="normal">2044</span>
<span class="normal">2045</span>
<span class="normal">2046</span>
<span class="normal">2047</span>
<span class="normal">2048</span>
<span class="normal">2049</span>
<span class="normal">2050</span>
<span class="normal">2051</span>
<span class="normal">2052</span>
<span class="normal">2053</span>
<span class="normal">2054</span>
<span class="normal">2055</span>
<span class="normal">2056</span>
<span class="normal">2057</span>
<span class="normal">2058</span>
<span class="normal">2059</span>
<span class="normal">2060</span>
<span class="normal">2061</span>
<span class="normal">2062</span>
<span class="normal">2063</span>
<span class="normal">2064</span>
<span class="normal">2065</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_consistent_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suptop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conditions:</span>
<span class="sd">        - There should be a minimal overlap of at least 1 node.</span>
<span class="sd">        - There is no pair (Na=Nb) in this sup top such that (Na=Nc) or (Nb=Nc) for some Nc in the other suptop.</span>
<span class="sd">        - The number of cycles in this suptop and the other suptop must be the same (?removing for now, fixme)</span>
<span class="sd">        - merging cannot lead to new cycles?? (fixme). What is the reasoning behind this?</span>
<span class="sd">            I mean, I guess the assumption is that, if the cycles were compatible,</span>
<span class="sd">            they would be created during the search, rather than now while merging. ??</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># confirm that there is no mismatches, ie (A=B) in suptop1 and (A=C) in suptop2 where (C!=B)</span>
    <span class="k">for</span> <span class="n">st1Na</span><span class="p">,</span> <span class="n">st1Nb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">st2Na</span><span class="p">,</span> <span class="n">st2Nb</span> <span class="ow">in</span> <span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">st1Na</span> <span class="ow">is</span> <span class="n">st2Na</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">st1Nb</span> <span class="ow">is</span> <span class="n">st2Nb</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">st1Nb</span> <span class="ow">is</span> <span class="n">st2Nb</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">st1Na</span> <span class="ow">is</span> <span class="n">st2Na</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># ensure there is at least one common pair</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_common_node_pairs</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># why do we need this?</span>
    <span class="c1"># if not self.is_consistent_cycles(suptop):</span>
    <span class="c1">#     return False</span>

    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology._rename_ligand" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">_rename_ligand</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_rename_ligand</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">name_counter</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>name_counter: a dictionary with atom as the key such as 'N', 'C', etc,
the counter keeps track of the last used counter for each name.
Empty means that the counting will start from 1.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2067</span>
<span class="normal">2068</span>
<span class="normal">2069</span>
<span class="normal">2070</span>
<span class="normal">2071</span>
<span class="normal">2072</span>
<span class="normal">2073</span>
<span class="normal">2074</span>
<span class="normal">2075</span>
<span class="normal">2076</span>
<span class="normal">2077</span>
<span class="normal">2078</span>
<span class="normal">2079</span>
<span class="normal">2080</span>
<span class="normal">2081</span>
<span class="normal">2082</span>
<span class="normal">2083</span>
<span class="normal">2084</span>
<span class="normal">2085</span>
<span class="normal">2086</span>
<span class="normal">2087</span>
<span class="normal">2088</span>
<span class="normal">2089</span>
<span class="normal">2090</span>
<span class="normal">2091</span>
<span class="normal">2092</span>
<span class="normal">2093</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_rename_ligand</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">name_counter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    name_counter: a dictionary with atom as the key such as &#39;N&#39;, &#39;C&#39;, etc,</span>
<span class="sd">    the counter keeps track of the last used counter for each name.</span>
<span class="sd">    Empty means that the counting will start from 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name_counter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name_counter</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="c1"># get the first letters that is not a character</span>
        <span class="n">after_letters</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">atom_name</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="n">after_letters</span><span class="p">]</span>
        <span class="n">last_used_counter</span> <span class="o">=</span> <span class="n">name_counter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">atom_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># rename</span>
        <span class="n">last_used_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">new_atom_name</span> <span class="o">=</span> <span class="n">atom_name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_used_counter</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Renaming </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">new_atom_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_atom_name</span>

        <span class="c1"># update the counter</span>
        <span class="n">name_counter</span><span class="p">[</span><span class="n">atom_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_used_counter</span>

    <span class="k">return</span> <span class="n">name_counter</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology._get_atom_names_counter" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">_get_atom_names_counter</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_get_atom_names_counter</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>name_counter: a dictionary with atom as the key such as 'N', 'C', etc,
the counter keeps track of the last used counter for each name.
Ie if there are C1, C2, C3, this will return {'C':3} as the last counter.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2095</span>
<span class="normal">2096</span>
<span class="normal">2097</span>
<span class="normal">2098</span>
<span class="normal">2099</span>
<span class="normal">2100</span>
<span class="normal">2101</span>
<span class="normal">2102</span>
<span class="normal">2103</span>
<span class="normal">2104</span>
<span class="normal">2105</span>
<span class="normal">2106</span>
<span class="normal">2107</span>
<span class="normal">2108</span>
<span class="normal">2109</span>
<span class="normal">2110</span>
<span class="normal">2111</span>
<span class="normal">2112</span>
<span class="normal">2113</span>
<span class="normal">2114</span>
<span class="normal">2115</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_get_atom_names_counter</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    name_counter: a dictionary with atom as the key such as &#39;N&#39;, &#39;C&#39;, etc,</span>
<span class="sd">    the counter keeps track of the last used counter for each name.</span>
<span class="sd">    Ie if there are C1, C2, C3, this will return {&#39;C&#39;:3} as the last counter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_counter</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="c1"># get the first letters that is not a character</span>
        <span class="n">after_letters</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">atom_name</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="n">after_letters</span><span class="p">]</span>
        <span class="n">atom_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">after_letters</span><span class="p">:])</span>
        <span class="n">last_used_counter</span> <span class="o">=</span> <span class="n">name_counter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">atom_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># update the counter</span>
        <span class="n">name_counter</span><span class="p">[</span><span class="n">atom_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">last_used_counter</span><span class="p">,</span> <span class="n">atom_number</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">name_counter</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_circles" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_circles</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_circles</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return circles found in the matched pairs.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2187</span>
<span class="normal">2188</span>
<span class="normal">2189</span>
<span class="normal">2190</span>
<span class="normal">2191</span>
<span class="normal">2192</span>
<span class="normal">2193</span>
<span class="normal">2194</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_circles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return circles found in the matched pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gl</span><span class="p">,</span> <span class="n">gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nx_graphs</span><span class="p">()</span>
    <span class="n">gl_circles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span> <span class="k">for</span> <span class="n">circle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">gl</span><span class="p">)]</span>
    <span class="n">gr_circles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span> <span class="k">for</span> <span class="n">circle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">gr</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">gl_circles</span><span class="p">,</span> <span class="n">gr_circles</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.get_original_circles" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_original_circles</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_original_circles</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return the original circles present in the input topologies.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2196</span>
<span class="normal">2197</span>
<span class="normal">2198</span>
<span class="normal">2199</span>
<span class="normal">2200</span>
<span class="normal">2201</span>
<span class="normal">2202</span>
<span class="normal">2203</span>
<span class="normal">2204</span>
<span class="normal">2205</span>
<span class="normal">2206</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_original_circles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the original circles present in the input topologies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create a circles</span>
    <span class="n">l_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_original_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">)</span>
    <span class="n">r_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_original_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">)</span>

    <span class="n">l_circles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span> <span class="k">for</span> <span class="n">circle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">l_original</span><span class="p">)]</span>
    <span class="n">r_circles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span> <span class="k">for</span> <span class="n">circle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">r_original</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">l_circles</span><span class="p">,</span> <span class="n">r_circles</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology._get_original_circle" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">_get_original_circle</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_get_original_circle</span><span class="p">(</span><span class="n">atom_list</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Create a networkx circle out of the list
atom_list - list of AtomNode</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2208</span>
<span class="normal">2209</span>
<span class="normal">2210</span>
<span class="normal">2211</span>
<span class="normal">2212</span>
<span class="normal">2213</span>
<span class="normal">2214</span>
<span class="normal">2215</span>
<span class="normal">2216</span>
<span class="normal">2217</span>
<span class="normal">2218</span>
<span class="normal">2219</span>
<span class="normal">2220</span>
<span class="normal">2221</span>
<span class="normal">2222</span>
<span class="normal">2223</span>
<span class="normal">2224</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_get_original_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a networkx circle out of the list</span>
<span class="sd">    atom_list - list of AtomNode</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="c1"># add each node</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="c1"># add all the edges</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
        <span class="c1"># add the edges from nA</span>
        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">atom_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">bound_to</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.cycle_spans_multiple_cycles" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">cycle_spans_multiple_cycles</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">cycle_spans_multiple_cycles</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>What is the circle is shared?
We are using cycles which excluded atoms that join different rings.
fixme - could this lead to a special case?</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2237</span>
<span class="normal">2238</span>
<span class="normal">2239</span>
<span class="normal">2240</span>
<span class="normal">2241</span>
<span class="normal">2242</span>
<span class="normal">2243</span>
<span class="normal">2244</span>
<span class="normal">2245</span>
<span class="normal">2246</span>
<span class="normal">2247</span>
<span class="normal">2248</span>
<span class="normal">2249</span>
<span class="normal">2250</span>
<span class="normal">2251</span>
<span class="normal">2252</span>
<span class="normal">2253</span>
<span class="normal">2254</span>
<span class="normal">2255</span>
<span class="normal">2256</span>
<span class="normal">2257</span>
<span class="normal">2258</span>
<span class="normal">2259</span>
<span class="normal">2260</span>
<span class="normal">2261</span>
<span class="normal">2262</span>
<span class="normal">2263</span>
<span class="normal">2264</span>
<span class="normal">2265</span>
<span class="normal">2266</span>
<span class="normal">2267</span>
<span class="normal">2268</span>
<span class="normal">2269</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cycle_spans_multiple_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># This filter checks whether a newly created suptop cycle spans multiple cycles</span>
    <span class="c1"># this is one of the filters (#106)</span>
    <span class="c1"># fixme - should this be applied whenever we work with more than 1 cycle?</span>
    <span class="c1"># it checks whether any cycles in the left molecule,</span>
    <span class="c1"># is paired with more than one cycle in the right molecule</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    What is the circle is shared?</span>
<span class="sd">    We are using cycles which excluded atoms that join different rings.</span>
<span class="sd">    fixme - could this lead to a special case?</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">l_cycle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonoverlapping_l_cycles</span><span class="p">:</span>
        <span class="n">overlap_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r_cycle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonoverlapping_r_cycles</span><span class="p">:</span>
            <span class="c1"># check if the cycles overlap</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycles_overlap</span><span class="p">(</span><span class="n">l_cycle</span><span class="p">,</span> <span class="n">r_cycle</span><span class="p">):</span>
                <span class="n">overlap_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">overlap_counter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">r_cycle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonoverlapping_r_cycles</span><span class="p">:</span>
        <span class="n">overlap_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l_cycle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonoverlapping_l_cycles</span><span class="p">:</span>
            <span class="c1"># check if the cycles overlap</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycles_overlap</span><span class="p">(</span><span class="n">l_cycle</span><span class="p">,</span> <span class="n">r_cycle</span><span class="p">):</span>
                <span class="n">overlap_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">overlap_counter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.merge" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">merge</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">merge</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Absorb the other suptop by adding all the node pairs that are not present
in the current sup top.</p>
<p>WARNING: ensure that the other suptop is consistent with this sup top.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2280</span>
<span class="normal">2281</span>
<span class="normal">2282</span>
<span class="normal">2283</span>
<span class="normal">2284</span>
<span class="normal">2285</span>
<span class="normal">2286</span>
<span class="normal">2287</span>
<span class="normal">2288</span>
<span class="normal">2289</span>
<span class="normal">2290</span>
<span class="normal">2291</span>
<span class="normal">2292</span>
<span class="normal">2293</span>
<span class="normal">2294</span>
<span class="normal">2295</span>
<span class="normal">2296</span>
<span class="normal">2297</span>
<span class="normal">2298</span>
<span class="normal">2299</span>
<span class="normal">2300</span>
<span class="normal">2301</span>
<span class="normal">2302</span>
<span class="normal">2303</span>
<span class="normal">2304</span>
<span class="normal">2305</span>
<span class="normal">2306</span>
<span class="normal">2307</span>
<span class="normal">2308</span>
<span class="normal">2309</span>
<span class="normal">2310</span>
<span class="normal">2311</span>
<span class="normal">2312</span>
<span class="normal">2313</span>
<span class="normal">2314</span>
<span class="normal">2315</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suptop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Absorb the other suptop by adding all the node pairs that are not present</span>
<span class="sd">    in the current sup top.</span>

<span class="sd">    WARNING: ensure that the other suptop is consistent with this sup top.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># assert self.is_consistent_with(suptop)</span>

    <span class="c1"># print(&quot;About the merge two sup tops&quot;)</span>
    <span class="c1"># self.print_summary()</span>
    <span class="c1"># other_suptop.print_summary()</span>

    <span class="n">merged_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="c1"># check if this pair is present</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
            <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">pair</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;already uses that node&#39;</span><span class="p">)</span>
            <span class="c1"># pass the bonded pairs here</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node_pair</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
            <span class="n">merged_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
    <span class="c1"># after adding all the nodes, now add the bonds</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">merged_pairs</span><span class="p">:</span>
        <span class="c1"># add the connections</span>
        <span class="n">bonded_pairs</span> <span class="o">=</span> <span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs_bonds</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bonded_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">link_pairs</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">bonded_pairs</span><span class="p">)</span>

    <span class="c1"># removed from the &quot;merged&quot; the ones that agree, so it contains only the new stuff</span>
    <span class="c1"># to make it easier to read</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes_added_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;merged with&quot;</span><span class="p">,</span> <span class="n">merged_pairs</span><span class="p">))</span>

    <span class="c1"># check for duplication, fixme - temporary</span>
    <span class="k">return</span> <span class="n">merged_pairs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.validate_charges" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">validate_charges</span>


  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">validate_charges</span><span class="p">(</span><span class="n">atom_list_l</span><span class="p">,</span> <span class="n">atom_list_right</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Check the original charges:
- ensure that the total charge of L and R are integers
- ensure that they are equal to the same integer</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2317</span>
<span class="normal">2318</span>
<span class="normal">2319</span>
<span class="normal">2320</span>
<span class="normal">2321</span>
<span class="normal">2322</span>
<span class="normal">2323</span>
<span class="normal">2324</span>
<span class="normal">2325</span>
<span class="normal">2326</span>
<span class="normal">2327</span>
<span class="normal">2328</span>
<span class="normal">2329</span>
<span class="normal">2330</span>
<span class="normal">2331</span>
<span class="normal">2332</span>
<span class="normal">2333</span>
<span class="normal">2334</span>
<span class="normal">2335</span>
<span class="normal">2336</span>
<span class="normal">2337</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_charges</span><span class="p">(</span><span class="n">atom_list_l</span><span class="p">,</span> <span class="n">atom_list_right</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the original charges:</span>
<span class="sd">    - ensure that the total charge of L and R are integers</span>
<span class="sd">    - ensure that they are equal to the same integer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">whole_left_charge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atom_list_l</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">whole_left_charge</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">whole_left_charge</span><span class="p">),</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                   <span class="n">err_msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;left charges are not integral. Expected </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">whole_left_charge</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                                           <span class="sa">f</span><span class="s1">&#39; but found </span><span class="si">{</span><span class="n">whole_left_charge</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">whole_right_charge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atom_list_right</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">whole_right_charge</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">whole_right_charge</span><span class="p">),</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                   <span class="n">err_msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;right charges are not integral. Expected </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">whole_right_charge</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                                           <span class="sa">f</span><span class="s1">&#39; but found </span><span class="si">{</span><span class="n">whole_right_charge</span><span class="si">}</span><span class="s1">&#39;</span>
                                   <span class="p">)</span>
    <span class="c1"># same integer</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">whole_left_charge</span><span class="p">,</span> <span class="n">whole_right_charge</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">whole_left_charge</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.redistribute_charges" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">redistribute_charges</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">redistribute_charges</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>After the match is made and the user commits to the superimposed topology,
the charges can be revised.
We calculate the average charges between every match, and check how that affects
the rest of the molecule (the unmatched atoms).
Then, we distribute the charges to the unmatched atoms to get
the net charge as a whole number/integer.</p>
<p>This function should be called after removing the matches for whatever reason.
ie at the end of anything that could modify the atom pairing.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2339</span>
<span class="normal">2340</span>
<span class="normal">2341</span>
<span class="normal">2342</span>
<span class="normal">2343</span>
<span class="normal">2344</span>
<span class="normal">2345</span>
<span class="normal">2346</span>
<span class="normal">2347</span>
<span class="normal">2348</span>
<span class="normal">2349</span>
<span class="normal">2350</span>
<span class="normal">2351</span>
<span class="normal">2352</span>
<span class="normal">2353</span>
<span class="normal">2354</span>
<span class="normal">2355</span>
<span class="normal">2356</span>
<span class="normal">2357</span>
<span class="normal">2358</span>
<span class="normal">2359</span>
<span class="normal">2360</span>
<span class="normal">2361</span>
<span class="normal">2362</span>
<span class="normal">2363</span>
<span class="normal">2364</span>
<span class="normal">2365</span>
<span class="normal">2366</span>
<span class="normal">2367</span>
<span class="normal">2368</span>
<span class="normal">2369</span>
<span class="normal">2370</span>
<span class="normal">2371</span>
<span class="normal">2372</span>
<span class="normal">2373</span>
<span class="normal">2374</span>
<span class="normal">2375</span>
<span class="normal">2376</span>
<span class="normal">2377</span>
<span class="normal">2378</span>
<span class="normal">2379</span>
<span class="normal">2380</span>
<span class="normal">2381</span>
<span class="normal">2382</span>
<span class="normal">2383</span>
<span class="normal">2384</span>
<span class="normal">2385</span>
<span class="normal">2386</span>
<span class="normal">2387</span>
<span class="normal">2388</span>
<span class="normal">2389</span>
<span class="normal">2390</span>
<span class="normal">2391</span>
<span class="normal">2392</span>
<span class="normal">2393</span>
<span class="normal">2394</span>
<span class="normal">2395</span>
<span class="normal">2396</span>
<span class="normal">2397</span>
<span class="normal">2398</span>
<span class="normal">2399</span>
<span class="normal">2400</span>
<span class="normal">2401</span>
<span class="normal">2402</span>
<span class="normal">2403</span>
<span class="normal">2404</span>
<span class="normal">2405</span>
<span class="normal">2406</span>
<span class="normal">2407</span>
<span class="normal">2408</span>
<span class="normal">2409</span>
<span class="normal">2410</span>
<span class="normal">2411</span>
<span class="normal">2412</span>
<span class="normal">2413</span>
<span class="normal">2414</span>
<span class="normal">2415</span>
<span class="normal">2416</span>
<span class="normal">2417</span>
<span class="normal">2418</span>
<span class="normal">2419</span>
<span class="normal">2420</span>
<span class="normal">2421</span>
<span class="normal">2422</span>
<span class="normal">2423</span>
<span class="normal">2424</span>
<span class="normal">2425</span>
<span class="normal">2426</span>
<span class="normal">2427</span>
<span class="normal">2428</span>
<span class="normal">2429</span>
<span class="normal">2430</span>
<span class="normal">2431</span>
<span class="normal">2432</span>
<span class="normal">2433</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">redistribute_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    After the match is made and the user commits to the superimposed topology,</span>
<span class="sd">    the charges can be revised.</span>
<span class="sd">    We calculate the average charges between every match, and check how that affects</span>
<span class="sd">    the rest of the molecule (the unmatched atoms).</span>
<span class="sd">    Then, we distribute the charges to the unmatched atoms to get</span>
<span class="sd">    the net charge as a whole number/integer.</span>

<span class="sd">    This function should be called after removing the matches for whatever reason.</span>
<span class="sd">    ie at the end of anything that could modify the atom pairing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SuperimposedTopology</span><span class="o">.</span><span class="n">validate_charges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">)</span>

    <span class="c1"># find the integral net charge of the molecule</span>
    <span class="n">net_charge</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">))</span>
    <span class="n">net_charge_test</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">net_charge</span> <span class="o">!=</span> <span class="n">net_charge_test</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The internally computed net charges of the molecules are different&#39;</span><span class="p">)</span>
    <span class="c1"># fixme - use the one passed by the user?</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Internally computed net charge: </span><span class="si">{</span><span class="n">net_charge</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># the total charge in the matched region before the changes</span>
    <span class="n">matched_total_charge_l</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span>
    <span class="n">matched_total_charge_r</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span>

    <span class="c1"># get the unmatched atoms in Left and Right</span>
    <span class="n">l_unmatched</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_disappearing_atoms</span><span class="p">()</span>
    <span class="n">r_unmatched</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_appearing_atoms</span><span class="p">()</span>

    <span class="n">init_q_dis</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">l_unmatched</span><span class="p">)</span>
    <span class="n">init_q_app</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">r_unmatched</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial cumulative charge of the appearing=</span><span class="si">{</span><span class="n">init_q_app</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">, disappearing=</span><span class="si">{</span><span class="n">init_q_dis</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> &#39;</span>
          <span class="sa">f</span><span class="s1">&#39;alchemical regions&#39;</span><span class="p">)</span>

    <span class="c1"># average the charges between matched atoms in the joint area of the dual topology</span>
    <span class="n">total_charge_matched</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># represents the net charge of the joint area minus molecule charge</span>
    <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="n">avg_charge</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">charge</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># write the new charge</span>
        <span class="n">left</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">avg_charge</span>
        <span class="n">total_charge_matched</span> <span class="o">+=</span> <span class="n">avg_charge</span>
    <span class="c1"># total_partial_charge_matched e.g. -0.9 (partial charges) - -1 (net molecule charge) = 0.1</span>
    <span class="n">total_partial_charge_matched</span> <span class="o">=</span> <span class="n">total_charge_matched</span> <span class="o">-</span> <span class="n">net_charge</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Total partial charge in the joint area = </span><span class="si">{</span><span class="n">total_partial_charge_matched</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># calculate what the correction should be in the alchemical regions</span>
    <span class="n">r_delta_charge_total</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_partial_charge_matched</span> <span class="o">+</span> <span class="n">init_q_app</span><span class="p">)</span>
    <span class="n">l_delta_charge_total</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_partial_charge_matched</span> <span class="o">+</span> <span class="n">init_q_dis</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Total charge imbalance to be distributed in &#39;</span>
          <span class="sa">f</span><span class="s1">&#39;dis=</span><span class="si">{</span><span class="n">l_delta_charge_total</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> and app=</span><span class="si">{</span><span class="n">r_delta_charge_total</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_unmatched</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">l_delta_charge_total</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;ERROR? AFTER AVERAGING CHARGES, THERE ARE NO UNMATCHED ATOMS TO ASSIGN THE CHARGE TO: &#39;</span>
              <span class="s1">&#39;left ligand.&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_unmatched</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">r_delta_charge_total</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;ERROR? AFTER AVERAGING CHARGES, THERE ARE NO UNMATCHED ATOMS TO ASSIGN THE CHARGE TO: &#39;</span>
              <span class="s1">&#39;right ligand. &#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------------------------------------------&#39;</span><span class="p">)</span>

    <span class="c1"># distribute the charges over the alchemical regions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_unmatched</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">l_delta_per_atom</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">l_delta_charge_total</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_unmatched</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fixme - no unmatching atoms, so there should be no charge to redistribute</span>
        <span class="n">l_delta_per_atom</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_unmatched</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r_delta_per_atom</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">r_delta_charge_total</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_unmatched</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r_delta_per_atom</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># fixme - no matching atoms, so there should be no charge to redistribute</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Charge imbalance per atom in dis=</span><span class="si">{</span><span class="n">l_delta_per_atom</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> and app=</span><span class="si">{</span><span class="n">r_delta_per_atom</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># redistribute that delta q over the atoms in the left and right molecule</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">l_unmatched</span><span class="p">:</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">charge</span> <span class="o">+=</span> <span class="n">l_delta_per_atom</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">r_unmatched</span><span class="p">:</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">charge</span> <span class="o">+=</span> <span class="n">r_delta_per_atom</span>

    <span class="c1"># check if the appearing atoms and the disappearing atoms have the same net charge</span>
    <span class="n">dis_q_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">l_unmatched</span><span class="p">)</span>
    <span class="n">app_q_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">r_unmatched</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Final cumulative charge of the appearing=</span><span class="si">{</span><span class="n">app_q_sum</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">, disappearing=</span><span class="si">{</span><span class="n">dis_q_sum</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> &#39;</span>
          <span class="sa">f</span><span class="s1">&#39;alchemical regions&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dis_q_sum</span><span class="p">,</span> <span class="n">app_q_sum</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;The partial charges in app/dis region are not equal to each other. &#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The alchemical region in app/dis do not have equal partial charges.&#39;</span><span class="p">)</span>

    <span class="c1"># note that we are really modifying right now the original nodes.</span>
    <span class="n">SuperimposedTopology</span><span class="o">.</span><span class="n">validate_charges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.contains_same_atoms_symmetric" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">contains_same_atoms_symmetric</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">contains_same_atoms_symmetric</span><span class="p">(</span><span class="n">other_sup_top</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>The atoms can be paired differently, but they are the same.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2506</span>
<span class="normal">2507</span>
<span class="normal">2508</span>
<span class="normal">2509</span>
<span class="normal">2510</span>
<span class="normal">2511</span>
<span class="normal">2512</span>
<span class="normal">2513</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">contains_same_atoms_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_sup_top</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The atoms can be paired differently, but they are the same.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">other_sup_top</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.is_subgraph_of" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">is_subgraph_of</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">is_subgraph_of</span><span class="p">(</span><span class="n">other_sup_top</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Checks if this superimposed topology is a subgraph of another superimposed topology.
Or if any mirror topology is a subgraph.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2557</span>
<span class="normal">2558</span>
<span class="normal">2559</span>
<span class="normal">2560</span>
<span class="normal">2561</span>
<span class="normal">2562</span>
<span class="normal">2563</span>
<span class="normal">2564</span>
<span class="normal">2565</span>
<span class="normal">2566</span>
<span class="normal">2567</span>
<span class="normal">2568</span>
<span class="normal">2569</span>
<span class="normal">2570</span>
<span class="normal">2571</span>
<span class="normal">2572</span>
<span class="normal">2573</span>
<span class="normal">2574</span>
<span class="normal">2575</span>
<span class="normal">2576</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_subgraph_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_sup_top</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if this superimposed topology is a subgraph of another superimposed topology.</span>
<span class="sd">    Or if any mirror topology is a subgraph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># subgraph cannot be equivalent self.eq, it is only proper subgraph (ie proper subset)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_sup_top</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># self is smaller, so it might be a subgraph</span>
    <span class="k">if</span> <span class="n">other_sup_top</span><span class="o">.</span><span class="n">contains_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># self is not a subgraph, but it could be a subgraph of one of the mirrors</span>
    <span class="k">for</span> <span class="n">mirror</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirrors</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">other_sup_top</span><span class="o">.</span><span class="n">contains_all</span><span class="p">(</span><span class="n">mirror</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># other is bigger than self, but not a subgraph of self</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.subgraph_relationship" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">subgraph_relationship</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">subgraph_relationship</span><span class="p">(</span><span class="n">other_sup_top</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Return
1 if self is a supergraph of other,
-1 if self is a subgraph of other
0 if they have the same number of elements (regardless of what the nodes are)</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2578</span>
<span class="normal">2579</span>
<span class="normal">2580</span>
<span class="normal">2581</span>
<span class="normal">2582</span>
<span class="normal">2583</span>
<span class="normal">2584</span>
<span class="normal">2585</span>
<span class="normal">2586</span>
<span class="normal">2587</span>
<span class="normal">2588</span>
<span class="normal">2589</span>
<span class="normal">2590</span>
<span class="normal">2591</span>
<span class="normal">2592</span>
<span class="normal">2593</span>
<span class="normal">2594</span>
<span class="normal">2595</span>
<span class="normal">2596</span>
<span class="normal">2597</span>
<span class="normal">2598</span>
<span class="normal">2599</span>
<span class="normal">2600</span>
<span class="normal">2601</span>
<span class="normal">2602</span>
<span class="normal">2603</span>
<span class="normal">2604</span>
<span class="normal">2605</span>
<span class="normal">2606</span>
<span class="normal">2607</span>
<span class="normal">2608</span>
<span class="normal">2609</span>
<span class="normal">2610</span>
<span class="normal">2611</span>
<span class="normal">2612</span>
<span class="normal">2613</span>
<span class="normal">2614</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">subgraph_relationship</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_sup_top</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return</span>
<span class="sd">    1 if self is a supergraph of other,</span>
<span class="sd">    -1 if self is a subgraph of other</span>
<span class="sd">    0 if they have the same number of elements (regardless of what the nodes are)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_sup_top</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_sup_top</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">):</span>
        <span class="c1"># self is bigger than other,</span>
        <span class="c1"># check if self contains all nodes in other</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_all</span><span class="p">(</span><span class="n">other_sup_top</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="c1"># other is not a subgraph, but check the mirrors if any of them are</span>
        <span class="k">for</span> <span class="n">mirror</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirrors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mirror</span><span class="o">.</span><span class="n">contains_all</span><span class="p">(</span><span class="n">other_sup_top</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span>

        <span class="c1"># other is smaller but not a subgraph of this graph or any of its mirrors</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_sup_top</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">):</span>
        <span class="c1"># other is bigger, so self might be a subgraph</span>
        <span class="c1"># check if other contains all nodes in self</span>
        <span class="k">if</span> <span class="n">other_sup_top</span><span class="o">.</span><span class="n">contains_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># self is not a subgraph, but it could be a subgraph of one of the mirrors</span>
        <span class="k">for</span> <span class="n">mirror</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirrors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other_sup_top</span><span class="o">.</span><span class="n">contains_all</span><span class="p">(</span><span class="n">mirror</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># other is bigger than self, but it is not a subgraph</span>
        <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.is_mirror_of" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">is_mirror_of</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">is_mirror_of</span><span class="p">(</span><span class="n">other_sup_top</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>this is a naive check
fixme - check if the found superimposed topology is the same (ie the same matches), what then?</p>
<p>some of the superimposed topologies represent symmetrical matches,
for example, imagine T1A and T1B is a symmetrical version of T2A and T2B,
this means that
 - the number of nodes in T1A, T1B, T2A, and T2B is the same
 - all the nodes in T1A are in T2A,
 - all the nodes in T1B are in T2B</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2616</span>
<span class="normal">2617</span>
<span class="normal">2618</span>
<span class="normal">2619</span>
<span class="normal">2620</span>
<span class="normal">2621</span>
<span class="normal">2622</span>
<span class="normal">2623</span>
<span class="normal">2624</span>
<span class="normal">2625</span>
<span class="normal">2626</span>
<span class="normal">2627</span>
<span class="normal">2628</span>
<span class="normal">2629</span>
<span class="normal">2630</span>
<span class="normal">2631</span>
<span class="normal">2632</span>
<span class="normal">2633</span>
<span class="normal">2634</span>
<span class="normal">2635</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_mirror_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_sup_top</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    this is a naive check</span>
<span class="sd">    fixme - check if the found superimposed topology is the same (ie the same matches), what then?</span>

<span class="sd">    some of the superimposed topologies represent symmetrical matches,</span>
<span class="sd">    for example, imagine T1A and T1B is a symmetrical version of T2A and T2B,</span>
<span class="sd">    this means that</span>
<span class="sd">     - the number of nodes in T1A, T1B, T2A, and T2B is the same</span>
<span class="sd">     - all the nodes in T1A are in T2A,</span>
<span class="sd">     - all the nodes in T1B are in T2B</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_sup_top</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_same_atoms_symmetric</span><span class="p">(</span><span class="n">other_sup_top</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.eq" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">eq</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">eq</span><span class="p">(</span><span class="n">sup_top</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Check if the superimposed topology is "the same". This means that every pair has a corresponding pair in the
other topology (but possibly in a different order)</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2652</span>
<span class="normal">2653</span>
<span class="normal">2654</span>
<span class="normal">2655</span>
<span class="normal">2656</span>
<span class="normal">2657</span>
<span class="normal">2658</span>
<span class="normal">2659</span>
<span class="normal">2660</span>
<span class="normal">2661</span>
<span class="normal">2662</span>
<span class="normal">2663</span>
<span class="normal">2664</span>
<span class="normal">2665</span>
<span class="normal">2666</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sup_top</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the superimposed topology is &quot;the same&quot;. This means that every pair has a corresponding pair in the</span>
<span class="sd">    other topology (but possibly in a different order)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># fixme - should replace this with networkx</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sup_top</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
        <span class="c1"># find for every pair the matching pair</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sup_top</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ties.topology_superimposer.SuperimposedTopology.toJSON" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">toJSON</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">toJSON</span><span class="p">()</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>"
Extract all the important information and return a json string.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2668</span>
<span class="normal">2669</span>
<span class="normal">2670</span>
<span class="normal">2671</span>
<span class="normal">2672</span>
<span class="normal">2673</span>
<span class="normal">2674</span>
<span class="normal">2675</span>
<span class="normal">2676</span>
<span class="normal">2677</span>
<span class="normal">2678</span>
<span class="normal">2679</span>
<span class="normal">2680</span>
<span class="normal">2681</span>
<span class="normal">2682</span>
<span class="normal">2683</span>
<span class="normal">2684</span>
<span class="normal">2685</span>
<span class="normal">2686</span>
<span class="normal">2687</span>
<span class="normal">2688</span>
<span class="normal">2689</span>
<span class="normal">2690</span>
<span class="normal">2691</span>
<span class="normal">2692</span>
<span class="normal">2693</span>
<span class="normal">2694</span>
<span class="normal">2695</span>
<span class="normal">2696</span>
<span class="normal">2697</span>
<span class="normal">2698</span>
<span class="normal">2699</span>
<span class="normal">2700</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">toJSON</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">        Extract all the important information and return a json string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># metadata</span>
        <span class="c1"># renamed atoms, new name : old name</span>
        <span class="s1">&#39;renamed_atoms&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;start_ligand&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">original_name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span><span class="p">},</span>
            <span class="s1">&#39;end_ligand&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">original_name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span><span class="p">},</span>
        <span class="p">},</span>
        <span class="c1"># the dual topology information</span>
        <span class="s1">&#39;superimposition&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;matched&#39;</span><span class="p">:</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">n1</span><span class="p">):</span> <span class="nb">str</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">},</span>
            <span class="s1">&#39;appearing&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_appearing_atoms</span><span class="p">())),</span>
            <span class="s1">&#39;disappearing&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_disappearing_atoms</span><span class="p">())),</span>
            <span class="s1">&#39;removed&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># because of:</span>
                <span class="c1"># replace atoms with their names</span>
                <span class="s1">&#39;net_charge&#39;</span><span class="p">:</span> <span class="p">[((</span><span class="n">a1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">),</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_due_to_net_charge</span><span class="p">],</span>
                <span class="s1">&#39;pair_q&#39;</span><span class="p">:</span> <span class="p">[((</span><span class="n">a1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">),</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span><span class="p">],</span>
                <span class="s1">&#39;disjointed&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="n">a1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_disjointed_cc</span><span class="p">],</span>
                <span class="s1">&#39;bonds&#39;</span><span class="p">:</span> <span class="p">[((</span><span class="n">a1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">),</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_diff_bonds</span><span class="p">],</span>
                <span class="s1">&#39;unmatched_rings&#39;</span><span class="p">:</span> <span class="p">[((</span><span class="n">a1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">),</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_removed_because_unmatched_rings</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="s1">&#39;charges_delta&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;start_ligand&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">_original_charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top1</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">_original_charge</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">charge</span><span class="p">},</span>
                <span class="s1">&#39;end_ligand&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">charge</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">_original_charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top2</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">_original_charge</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">charge</span><span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="s1">&#39;config&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_serializable</span><span class="p">(),</span>
        <span class="s1">&#39;internal&#39;</span><span class="p">:</span> <span class="s1">&#39;atoms&#39;</span> <span class="c1"># fixme</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">summary</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.get_largest" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">get_largest</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_largest</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>return a list of largest solutions</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2703</span>
<span class="normal">2704</span>
<span class="normal">2705</span>
<span class="normal">2706</span>
<span class="normal">2707</span>
<span class="normal">2708</span>
<span class="normal">2709</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_largest</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return a list of largest solutions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solution_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">]</span>
    <span class="n">largest_sol_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">solution_sizes</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">st</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="n">largest_sol_size</span><span class="p">,</span> <span class="n">lists</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.long_merge" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">long_merge</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">long_merge</span><span class="p">(</span><span class="n">suptop1</span><span class="p">,</span> <span class="n">suptop2</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Carry out a merge and apply all checks.
Merge suptop2 into suptop1.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2712</span>
<span class="normal">2713</span>
<span class="normal">2714</span>
<span class="normal">2715</span>
<span class="normal">2716</span>
<span class="normal">2717</span>
<span class="normal">2718</span>
<span class="normal">2719</span>
<span class="normal">2720</span>
<span class="normal">2721</span>
<span class="normal">2722</span>
<span class="normal">2723</span>
<span class="normal">2724</span>
<span class="normal">2725</span>
<span class="normal">2726</span>
<span class="normal">2727</span>
<span class="normal">2728</span>
<span class="normal">2729</span>
<span class="normal">2730</span>
<span class="normal">2731</span>
<span class="normal">2732</span>
<span class="normal">2733</span>
<span class="normal">2734</span>
<span class="normal">2735</span>
<span class="normal">2736</span>
<span class="normal">2737</span>
<span class="normal">2738</span>
<span class="normal">2739</span>
<span class="normal">2740</span>
<span class="normal">2741</span>
<span class="normal">2742</span>
<span class="normal">2743</span>
<span class="normal">2744</span>
<span class="normal">2745</span>
<span class="normal">2746</span>
<span class="normal">2747</span>
<span class="normal">2748</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">long_merge</span><span class="p">(</span><span class="n">suptop1</span><span class="p">,</span> <span class="n">suptop2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Carry out a merge and apply all checks.</span>
<span class="sd">    Merge suptop2 into suptop1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">suptop1</span> <span class="ow">is</span> <span class="n">suptop2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">suptop1</span>

    <span class="k">if</span> <span class="n">suptop1</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">suptop2</span><span class="p">):</span>
        <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Merge: the two are the equal. Ignoring&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">suptop1</span>

    <span class="k">if</span> <span class="n">suptop2</span><span class="o">.</span><span class="n">is_subgraph_of</span><span class="p">(</span><span class="n">suptop1</span><span class="p">):</span>
        <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Merge: this is already a superset. Ignoring&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">suptop1</span>

    <span class="c1"># check if the two are consistent</span>
    <span class="c1"># ie there is no clashes</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">suptop1</span><span class="o">.</span><span class="n">is_consistent_with</span><span class="p">(</span><span class="n">suptop2</span><span class="p">):</span>
        <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Merge: cannot merge - not consistent&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># fixme - this can be removed because it is now taken care of in the other functions?</span>
    <span class="c1"># g1, g2 = suptop1.getNxGraphs()</span>
    <span class="c1"># assert len(nx.cycle_basis(g1)) == len(nx.cycle_basis(g2))</span>
    <span class="c1"># g3, g4 = suptop2.getNxGraphs()</span>
    <span class="c1"># assert len(nx.cycle_basis(g3)) == len(nx.cycle_basis(g4))</span>
    <span class="c1">#</span>
    <span class="c1"># assert suptop1.sameCircleNumber()</span>
    <span class="n">newly_added_pairs</span> <span class="o">=</span> <span class="n">suptop1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">suptop2</span><span class="p">)</span>

    <span class="c1"># if not suptop1.sameCircleNumber():</span>
    <span class="c1">#     raise Exception(&#39;something off&#39;)</span>
    <span class="c1"># # remove sol2 from the solutions:</span>
    <span class="c1"># all_solutions.remove(sol2)</span>
    <span class="k">return</span> <span class="n">newly_added_pairs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.merge_compatible_suptops" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">merge_compatible_suptops</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">merge_compatible_suptops</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Imagine mapping of two carbons C1 and C2 to another pair of carbons C1' and C2'.
If C1 was mapped to C1', and C2 to C2', and each craeted a suptop, then we have to join the two suptops.</p>
<p>fixme - appears to be doing too many combinations
Consider using a queue. Add the new combinations here rather than restarting again and again.
You could keep a list of "combinations" in a queue, and each time you make a new element,</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2750</span>
<span class="normal">2751</span>
<span class="normal">2752</span>
<span class="normal">2753</span>
<span class="normal">2754</span>
<span class="normal">2755</span>
<span class="normal">2756</span>
<span class="normal">2757</span>
<span class="normal">2758</span>
<span class="normal">2759</span>
<span class="normal">2760</span>
<span class="normal">2761</span>
<span class="normal">2762</span>
<span class="normal">2763</span>
<span class="normal">2764</span>
<span class="normal">2765</span>
<span class="normal">2766</span>
<span class="normal">2767</span>
<span class="normal">2768</span>
<span class="normal">2769</span>
<span class="normal">2770</span>
<span class="normal">2771</span>
<span class="normal">2772</span>
<span class="normal">2773</span>
<span class="normal">2774</span>
<span class="normal">2775</span>
<span class="normal">2776</span>
<span class="normal">2777</span>
<span class="normal">2778</span>
<span class="normal">2779</span>
<span class="normal">2780</span>
<span class="normal">2781</span>
<span class="normal">2782</span>
<span class="normal">2783</span>
<span class="normal">2784</span>
<span class="normal">2785</span>
<span class="normal">2786</span>
<span class="normal">2787</span>
<span class="normal">2788</span>
<span class="normal">2789</span>
<span class="normal">2790</span>
<span class="normal">2791</span>
<span class="normal">2792</span>
<span class="normal">2793</span>
<span class="normal">2794</span>
<span class="normal">2795</span>
<span class="normal">2796</span>
<span class="normal">2797</span>
<span class="normal">2798</span>
<span class="normal">2799</span>
<span class="normal">2800</span>
<span class="normal">2801</span>
<span class="normal">2802</span>
<span class="normal">2803</span>
<span class="normal">2804</span>
<span class="normal">2805</span>
<span class="normal">2806</span>
<span class="normal">2807</span>
<span class="normal">2808</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge_compatible_suptops</span><span class="p">(</span><span class="n">suptops</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Imagine mapping of two carbons C1 and C2 to another pair of carbons C1&#39; and C2&#39;.</span>
<span class="sd">    If C1 was mapped to C1&#39;, and C2 to C2&#39;, and each craeted a suptop, then we have to join the two suptops.</span>

<span class="sd">    fixme - appears to be doing too many combinations</span>
<span class="sd">    Consider using a queue. Add the new combinations here rather than restarting again and again.</span>
<span class="sd">    You could keep a list of &quot;combinations&quot; in a queue, and each time you make a new element,</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">suptops</span>

    <span class="c1"># consier simplifying in case of &quot;2&quot;</span>

    <span class="c1"># keep track of which suptops have been used to build a bigger one</span>
    <span class="c1"># these can be likely later discarded</span>
    <span class="n">ingredients</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">excluded</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">any_new_suptop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">st1</span><span class="p">,</span> <span class="n">st2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">suptops</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">{</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">}</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">st1</span> <span class="ow">in</span> <span class="n">ingredients</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">or</span> <span class="n">st2</span> <span class="ow">in</span> <span class="n">ingredients</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">st1</span><span class="o">.</span><span class="n">is_subgraph_of</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">st2</span><span class="o">.</span><span class="n">is_subgraph_of</span><span class="p">(</span><span class="n">st1</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># fixme - verify this one</span>
            <span class="k">if</span> <span class="n">st1</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">st2</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># check if the two suptops are compatible</span>
            <span class="k">elif</span> <span class="n">st1</span><span class="o">.</span><span class="n">is_consistent_with</span><span class="p">(</span><span class="n">st2</span><span class="p">):</span>
                <span class="c1"># merge them!</span>
                <span class="n">large_suptop</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">st1</span><span class="p">)</span>
                <span class="c1"># add both the pairs and the bonds that are not present in st1</span>
                <span class="n">large_suptop</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
                <span class="n">suptops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">large_suptop</span><span class="p">)</span>

                <span class="n">ingredients</span><span class="p">[</span><span class="n">large_suptop</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">}</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">ingredients</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">ingredients</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>
                <span class="n">excluded</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">})</span>

                <span class="c1"># break</span>
                <span class="n">any_new_suptop</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">any_new_suptop</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># flatten</span>
    <span class="n">all_ingredients</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">ingredients</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># return the larger suptops, but not the constituents</span>
    <span class="n">new_suptops</span> <span class="o">=</span> <span class="p">[</span><span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span> <span class="k">if</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_ingredients</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_suptops</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.merge_compatible_suptops_faster" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">merge_compatible_suptops_faster</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">merge_compatible_suptops_faster</span><span class="p">(</span><span class="n">pairing_suptop</span><span class="p">:</span> <span class="n"><span title="typing.Dict">Dict</span></span><span class="p">,</span> <span class="n">min_bonds</span><span class="p">:</span> <span class="n">int</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>:param pairing_suptop:
:param min_bonds: if the End molecule at this point has only two bonds, they can be mapped to two other bonds
    in the start molecule.
:return:</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2818</span>
<span class="normal">2819</span>
<span class="normal">2820</span>
<span class="normal">2821</span>
<span class="normal">2822</span>
<span class="normal">2823</span>
<span class="normal">2824</span>
<span class="normal">2825</span>
<span class="normal">2826</span>
<span class="normal">2827</span>
<span class="normal">2828</span>
<span class="normal">2829</span>
<span class="normal">2830</span>
<span class="normal">2831</span>
<span class="normal">2832</span>
<span class="normal">2833</span>
<span class="normal">2834</span>
<span class="normal">2835</span>
<span class="normal">2836</span>
<span class="normal">2837</span>
<span class="normal">2838</span>
<span class="normal">2839</span>
<span class="normal">2840</span>
<span class="normal">2841</span>
<span class="normal">2842</span>
<span class="normal">2843</span>
<span class="normal">2844</span>
<span class="normal">2845</span>
<span class="normal">2846</span>
<span class="normal">2847</span>
<span class="normal">2848</span>
<span class="normal">2849</span>
<span class="normal">2850</span>
<span class="normal">2851</span>
<span class="normal">2852</span>
<span class="normal">2853</span>
<span class="normal">2854</span>
<span class="normal">2855</span>
<span class="normal">2856</span>
<span class="normal">2857</span>
<span class="normal">2858</span>
<span class="normal">2859</span>
<span class="normal">2860</span>
<span class="normal">2861</span>
<span class="normal">2862</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge_compatible_suptops_faster</span><span class="p">(</span><span class="n">pairing_suptop</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">min_bonds</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param pairing_suptop:</span>
<span class="sd">    :param min_bonds: if the End molecule at this point has only two bonds, they can be mapped to two other bonds</span>
<span class="sd">        in the start molecule.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairing_suptop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pairing_suptop</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># any to any</span>
    <span class="n">all_pairings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">pairing_suptop</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">r</span><span class="o">=</span><span class="n">min_bonds</span><span class="p">))</span>

    <span class="n">selected_pairings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pairings</span> <span class="ow">in</span> <span class="n">all_pairings</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pairing</span> <span class="ow">in</span> <span class="n">pairings</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pairing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">n</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pairing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairings</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">selected_pairings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pairings</span><span class="p">)</span>

    <span class="c1"># attempt to combine the different traversals</span>
    <span class="n">built_topologies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">selected_pairings</span><span class="p">:</span>
        <span class="c1"># mapping the different bonds to different bonds</span>

        <span class="c1"># check if the suptops are consistent with each other</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">are_consistent_topologies</span><span class="p">([</span><span class="n">pairing_suptop</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">]):</span>
            <span class="k">continue</span>

        <span class="c1"># merge them!</span>
        <span class="n">large_suptop</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pairing_suptop</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">next_map</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">next_suptop</span> <span class="o">=</span> <span class="n">pairing_suptop</span><span class="p">[</span><span class="n">next_map</span><span class="p">]</span>

            <span class="c1"># add both the pairs and the bonds that are not present in st1</span>
            <span class="n">large_suptop</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">next_suptop</span><span class="p">)</span>

        <span class="n">built_topologies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">large_suptop</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">built_topologies</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer._overlay" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">_overlay</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_overlay</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">parent_n1</span><span class="p">,</span> <span class="n">parent_n2</span><span class="p">,</span> <span class="n">bond_types</span><span class="p">,</span> <span class="n">suptop</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_element_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exact_coords_cue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Jointly and recursively traverse the molecule while building up the suptop.</p>
<p>If n1 and n2 are the same, we will be traversing through both graphs, marking the jointly travelled areas.</p>
<p>Return the topology of the common substructure between the two molecules.</p>
<p><em>n1 from the left molecule,
</em>n2 from the right molecule</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2969</span>
<span class="normal">2970</span>
<span class="normal">2971</span>
<span class="normal">2972</span>
<span class="normal">2973</span>
<span class="normal">2974</span>
<span class="normal">2975</span>
<span class="normal">2976</span>
<span class="normal">2977</span>
<span class="normal">2978</span>
<span class="normal">2979</span>
<span class="normal">2980</span>
<span class="normal">2981</span>
<span class="normal">2982</span>
<span class="normal">2983</span>
<span class="normal">2984</span>
<span class="normal">2985</span>
<span class="normal">2986</span>
<span class="normal">2987</span>
<span class="normal">2988</span>
<span class="normal">2989</span>
<span class="normal">2990</span>
<span class="normal">2991</span>
<span class="normal">2992</span>
<span class="normal">2993</span>
<span class="normal">2994</span>
<span class="normal">2995</span>
<span class="normal">2996</span>
<span class="normal">2997</span>
<span class="normal">2998</span>
<span class="normal">2999</span>
<span class="normal">3000</span>
<span class="normal">3001</span>
<span class="normal">3002</span>
<span class="normal">3003</span>
<span class="normal">3004</span>
<span class="normal">3005</span>
<span class="normal">3006</span>
<span class="normal">3007</span>
<span class="normal">3008</span>
<span class="normal">3009</span>
<span class="normal">3010</span>
<span class="normal">3011</span>
<span class="normal">3012</span>
<span class="normal">3013</span>
<span class="normal">3014</span>
<span class="normal">3015</span>
<span class="normal">3016</span>
<span class="normal">3017</span>
<span class="normal">3018</span>
<span class="normal">3019</span>
<span class="normal">3020</span>
<span class="normal">3021</span>
<span class="normal">3022</span>
<span class="normal">3023</span>
<span class="normal">3024</span>
<span class="normal">3025</span>
<span class="normal">3026</span>
<span class="normal">3027</span>
<span class="normal">3028</span>
<span class="normal">3029</span>
<span class="normal">3030</span>
<span class="normal">3031</span>
<span class="normal">3032</span>
<span class="normal">3033</span>
<span class="normal">3034</span>
<span class="normal">3035</span>
<span class="normal">3036</span>
<span class="normal">3037</span>
<span class="normal">3038</span>
<span class="normal">3039</span>
<span class="normal">3040</span>
<span class="normal">3041</span>
<span class="normal">3042</span>
<span class="normal">3043</span>
<span class="normal">3044</span>
<span class="normal">3045</span>
<span class="normal">3046</span>
<span class="normal">3047</span>
<span class="normal">3048</span>
<span class="normal">3049</span>
<span class="normal">3050</span>
<span class="normal">3051</span>
<span class="normal">3052</span>
<span class="normal">3053</span>
<span class="normal">3054</span>
<span class="normal">3055</span>
<span class="normal">3056</span>
<span class="normal">3057</span>
<span class="normal">3058</span>
<span class="normal">3059</span>
<span class="normal">3060</span>
<span class="normal">3061</span>
<span class="normal">3062</span>
<span class="normal">3063</span>
<span class="normal">3064</span>
<span class="normal">3065</span>
<span class="normal">3066</span>
<span class="normal">3067</span>
<span class="normal">3068</span>
<span class="normal">3069</span>
<span class="normal">3070</span>
<span class="normal">3071</span>
<span class="normal">3072</span>
<span class="normal">3073</span>
<span class="normal">3074</span>
<span class="normal">3075</span>
<span class="normal">3076</span>
<span class="normal">3077</span>
<span class="normal">3078</span>
<span class="normal">3079</span>
<span class="normal">3080</span>
<span class="normal">3081</span>
<span class="normal">3082</span>
<span class="normal">3083</span>
<span class="normal">3084</span>
<span class="normal">3085</span>
<span class="normal">3086</span>
<span class="normal">3087</span>
<span class="normal">3088</span>
<span class="normal">3089</span>
<span class="normal">3090</span>
<span class="normal">3091</span>
<span class="normal">3092</span>
<span class="normal">3093</span>
<span class="normal">3094</span>
<span class="normal">3095</span>
<span class="normal">3096</span>
<span class="normal">3097</span>
<span class="normal">3098</span>
<span class="normal">3099</span>
<span class="normal">3100</span>
<span class="normal">3101</span>
<span class="normal">3102</span>
<span class="normal">3103</span>
<span class="normal">3104</span>
<span class="normal">3105</span>
<span class="normal">3106</span>
<span class="normal">3107</span>
<span class="normal">3108</span>
<span class="normal">3109</span>
<span class="normal">3110</span>
<span class="normal">3111</span>
<span class="normal">3112</span>
<span class="normal">3113</span>
<span class="normal">3114</span>
<span class="normal">3115</span>
<span class="normal">3116</span>
<span class="normal">3117</span>
<span class="normal">3118</span>
<span class="normal">3119</span>
<span class="normal">3120</span>
<span class="normal">3121</span>
<span class="normal">3122</span>
<span class="normal">3123</span>
<span class="normal">3124</span>
<span class="normal">3125</span>
<span class="normal">3126</span>
<span class="normal">3127</span>
<span class="normal">3128</span>
<span class="normal">3129</span>
<span class="normal">3130</span>
<span class="normal">3131</span>
<span class="normal">3132</span>
<span class="normal">3133</span>
<span class="normal">3134</span>
<span class="normal">3135</span>
<span class="normal">3136</span>
<span class="normal">3137</span>
<span class="normal">3138</span>
<span class="normal">3139</span>
<span class="normal">3140</span>
<span class="normal">3141</span>
<span class="normal">3142</span>
<span class="normal">3143</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_overlay</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">parent_n1</span><span class="p">,</span> <span class="n">parent_n2</span><span class="p">,</span> <span class="n">bond_types</span><span class="p">,</span> <span class="n">suptop</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_element_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">exact_coords_cue</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jointly and recursively traverse the molecule while building up the suptop.</span>

<span class="sd">    If n1 and n2 are the same, we will be traversing through both graphs, marking the jointly travelled areas.</span>

<span class="sd">    Return the topology of the common substructure between the two molecules.</span>

<span class="sd">    *n1 from the left molecule,</span>
<span class="sd">    *n2 from the right molecule</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ignore if either of the nodes is part of the suptop</span>
    <span class="k">if</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">use_element_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">n1</span><span class="o">.</span><span class="n">same_element</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># make more specific, ie if &quot;use_specific_type&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_element_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">n1</span><span class="o">.</span><span class="n">same_type</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check for cycles</span>
    <span class="c1"># if a new cycle is created by adding this node,</span>
    <span class="c1"># then the cycle should be present in both, left and right ligand</span>
    <span class="n">safe</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># if n1 is linked with node in suptop other than parent</span>
    <span class="k">for</span> <span class="n">b1</span> <span class="ow">in</span> <span class="n">n1</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="c1"># if this bound atom is not a parent and is already a suptop</span>
        <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">atom</span> <span class="o">!=</span> <span class="n">parent_n1</span> <span class="ow">and</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">atom</span><span class="p">):</span>
            <span class="n">safe</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># n1 forms cycle, now need to check n2</span>
            <span class="k">for</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">n2</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b2</span><span class="o">.</span><span class="n">atom</span> <span class="o">!=</span> <span class="n">parent_n2</span> <span class="ow">and</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">atom</span><span class="p">):</span>
                    <span class="c1"># b2 forms cycle, now need to check it&#39;s the same in both</span>
                    <span class="k">if</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">atom</span><span class="p">)):</span>
                        <span class="n">safe</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">safe</span><span class="p">:</span>  <span class="c1"># only n1 forms a cycle</span>
                <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">safe</span><span class="p">:</span>  <span class="c1"># either only n1 forms cycle or both do but different cycles</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># now the same for any remaining unchecked bonds in n2</span>
    <span class="n">safe</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">n2</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b2</span><span class="o">.</span><span class="n">atom</span> <span class="o">!=</span> <span class="n">parent_n2</span> <span class="ow">and</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">atom</span><span class="p">):</span>
            <span class="n">safe</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">b1</span> <span class="ow">in</span> <span class="n">n1</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">atom</span> <span class="o">!=</span> <span class="n">parent_n1</span> <span class="ow">and</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains_node</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">atom</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">atom</span><span class="p">)):</span>
                        <span class="n">safe</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">safe</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">safe</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># check if the cycle spans multiple cycles present in the left and right molecule,</span>
    <span class="k">if</span> <span class="n">suptop</span><span class="o">.</span><span class="n">cycle_spans_multiple_cycles</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Found a cycle spanning multiple cycles&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span><span class="si">}</span><span class="s2"> to suptop.matched_pairs&quot;</span><span class="p">)</span>

    <span class="c1"># all looks good, create a new copy for this suptop</span>
    <span class="n">suptop</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span>

    <span class="c1"># append both nodes as a pair to ensure that we keep track of the mapping</span>
    <span class="c1"># having both nodes appended also ensure that we do not revisit/read neither n1 and n2</span>
    <span class="n">suptop</span><span class="o">.</span><span class="n">add_node_pair</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">parent_n1</span> <span class="ow">is</span> <span class="n">parent_n2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># fixme - adding a node pair should automatically take care of the bond, maybe using inner data?</span>
        <span class="c1"># fixme why is this link different than a normal link?</span>
        <span class="n">suptop</span><span class="o">.</span><span class="n">link_with_parent</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span> <span class="p">(</span><span class="n">parent_n1</span><span class="p">,</span> <span class="n">parent_n2</span><span class="p">),</span> <span class="n">bond_types</span><span class="p">)</span>

    <span class="c1"># the extra bonds are legitimate</span>
    <span class="c1"># so let&#39;s make sure they are added</span>
    <span class="c1"># fixme: add function get_bonds_without_parent? or maybe make them &quot;subtractable&quot; even without the type</span>
    <span class="c1"># for this it would be enough that the bonds is an object too, it will make it more managable</span>
    <span class="c1"># bookkeeping? Ideally adding &quot;add_node_pair&quot; would take care of this</span>
    <span class="k">for</span> <span class="n">n1_bonded</span> <span class="ow">in</span> <span class="n">n1</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="c1"># ignore left parent</span>
        <span class="k">if</span> <span class="n">n1_bonded</span><span class="o">.</span><span class="n">atom</span> <span class="ow">is</span> <span class="n">parent_n1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">n2_bonded</span> <span class="ow">in</span> <span class="n">n2</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="c1"># ignore right parent</span>
            <span class="k">if</span> <span class="n">n2_bonded</span><span class="o">.</span><span class="n">atom</span> <span class="ow">is</span> <span class="n">parent_n2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># if the pair exists, add a bond between the two pairs</span>
            <span class="k">if</span> <span class="n">suptop</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="n">n1_bonded</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">n2_bonded</span><span class="o">.</span><span class="n">atom</span><span class="p">)):</span>
                <span class="c1"># fixme: this linking of pairs should also be corrected</span>
                <span class="c1"># 1) add &quot;pair&quot; as an object rather than a tuple (n1, n2)</span>
                <span class="c1"># 2) this always has to happen, ie it is impossible to find (n1, n2)</span>
                <span class="c1"># ie make it into a more sensible method,</span>
                <span class="c1"># fixme: this does not link pairs?</span>
                <span class="n">suptop</span><span class="o">.</span><span class="n">link_pairs</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span>
                                  <span class="p">[((</span><span class="n">n1_bonded</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">n2_bonded</span><span class="o">.</span><span class="n">atom</span><span class="p">),</span> <span class="p">(</span><span class="n">n1_bonded</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">n2_bonded</span><span class="o">.</span><span class="n">type</span><span class="p">)),</span> <span class="p">])</span>

    <span class="c1"># fixme: sort so that heavy atoms go first</span>
    <span class="n">p1_bonds</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">without</span><span class="p">(</span><span class="n">parent_n1</span><span class="p">)</span>
    <span class="n">p2_bonds</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">without</span><span class="p">(</span><span class="n">parent_n2</span><span class="p">)</span>
    <span class="n">candidate_pairings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">p1_bonds</span><span class="p">,</span> <span class="n">p2_bonds</span><span class="p">))</span>

    <span class="c1"># check if any of the pairs have exactly the same location, use that as a hidden signal</span>
    <span class="c1"># it is possible at this stage to use predetermine the distances</span>
    <span class="c1"># and trick it to use the ones that have exactly the same distances,</span>
    <span class="c1"># and treat that as a signal</span>
    <span class="c1"># now the issue here is that someone might &quot;predetermine&quot; one part, ia CA1 mapping to CB1 rathern than CB2</span>
    <span class="c1"># but if CA1 and CA2 is present, and CA2 is not matched to CB2 in a predetermined manner, than CB2 should not be deleted</span>
    <span class="c1"># so we have to delete only the offers where CA1 = CB2 which would not be correct to pursue</span>
    <span class="k">if</span> <span class="n">exact_coords_cue</span><span class="p">:</span>
        <span class="n">predetermined</span> <span class="o">=</span> <span class="p">{</span><span class="n">a1</span><span class="p">:</span> <span class="n">a2</span> <span class="k">for</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="ow">in</span> <span class="n">candidate_pairings</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">)}</span>
        <span class="n">predetermined</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">predetermined</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">predetermined</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

        <span class="c1"># skip atom pairings that have been predetermined for other atoms</span>
        <span class="k">for</span> <span class="n">n1_bond</span><span class="p">,</span> <span class="n">n2_bond</span> <span class="ow">in</span> <span class="n">candidate_pairings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n1_bond</span> <span class="ow">in</span> <span class="n">predetermined</span> <span class="ow">or</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">predetermined</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">predetermined</span><span class="p">[</span><span class="n">n1_bond</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n2_bond</span> <span class="ow">or</span> <span class="n">predetermined</span><span class="p">[</span><span class="n">n2_bond</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n1_bond</span><span class="p">:</span>
                    <span class="n">candidate_pairings</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">n1_bond</span><span class="p">,</span> <span class="n">n2_bond</span><span class="p">))</span>

    <span class="c1"># but they will be considered as a group</span>
    <span class="n">larger_suptops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pairing_and_suptop</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n1_bond</span><span class="p">,</span> <span class="n">n2_bond</span> <span class="ow">in</span> <span class="n">candidate_pairings</span><span class="p">:</span>
        <span class="c1"># fixme - ideally we would allow other typing than just the chemical element</span>
        <span class="k">if</span> <span class="n">n1_bond</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">n2_bond</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sampling </span><span class="si">{</span><span class="n">n1_bond</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">n2_bond</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># create a copy of the sup_top to allow for different traversals</span>
        <span class="c1"># fixme: note that you could just send bonds, and that would have both parent etc with a bit of work</span>
        <span class="n">larger_suptop</span> <span class="o">=</span> <span class="n">_overlay</span><span class="p">(</span><span class="n">n1_bond</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">n2_bond</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span>
                                  <span class="n">parent_n1</span><span class="o">=</span><span class="n">n1</span><span class="p">,</span> <span class="n">parent_n2</span><span class="o">=</span><span class="n">n2</span><span class="p">,</span>
                                  <span class="n">bond_types</span><span class="o">=</span><span class="p">(</span><span class="n">n1_bond</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">n2_bond</span><span class="o">.</span><span class="n">type</span><span class="p">),</span>
                                  <span class="n">suptop</span><span class="o">=</span><span class="n">suptop</span><span class="p">,</span>
                                  <span class="n">ignore_coords</span><span class="o">=</span><span class="n">ignore_coords</span><span class="p">,</span>
                                  <span class="n">use_element_type</span><span class="o">=</span><span class="n">use_element_type</span><span class="p">,</span>
                                  <span class="n">exact_coords_cue</span><span class="o">=</span><span class="n">exact_coords_cue</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">larger_suptop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">larger_suptops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">larger_suptop</span><span class="p">)</span>
            <span class="n">pairing_and_suptop</span><span class="p">[(</span><span class="n">n1_bond</span><span class="p">,</span> <span class="n">n2_bond</span><span class="p">)]</span> <span class="o">=</span> <span class="n">larger_suptop</span>

    <span class="c1"># todo</span>
    <span class="c1"># check for &quot;predetermined&quot; atoms. Ie if they have the same coordinates,</span>
    <span class="c1"># then that&#39;s the path to take, rather than a competing path??</span>

    <span class="c1"># nothing further grown out of this suptop, so it is final</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">larger_suptops</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">suptop</span>

    <span class="c1"># fixme: compare every two pairs of returned suptops, if they are compatible, join them</span>
    <span class="c1"># fixme - note that we are repeating this partly below</span>
    <span class="c1"># it also removes subgraph suptops</span>
    <span class="c1">#all_solutions = merge_compatible_suptops(larger_suptops)</span>
    <span class="n">all_solutions</span> <span class="o">=</span> <span class="n">merge_compatible_suptops_faster</span><span class="p">(</span><span class="n">pairing_and_suptop</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p1_bonds</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p2_bonds</span><span class="p">)))</span>

    <span class="c1"># if you couldn&#39;t merge any solutions, return the largest one</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">all_solutions</span><span class="p">:</span>
        <span class="n">all_solutions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pairing_and_suptop</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># sort in the descending order</span>
    <span class="n">all_solutions</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">st</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sol1</span><span class="p">,</span> <span class="n">sol2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">all_solutions</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sol1</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">sol2</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found the same solution and removing, solution: </span><span class="si">{</span><span class="n">sol1</span><span class="o">.</span><span class="n">matched_pairs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sol2</span> <span class="ow">in</span> <span class="n">all_solutions</span><span class="p">:</span>
                <span class="n">all_solutions</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sol2</span><span class="p">)</span>

    <span class="n">best_suptop</span> <span class="o">=</span> <span class="n">extract_best_suptop</span><span class="p">(</span><span class="n">all_solutions</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">best_suptop</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.superimpose_topologies" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">superimpose_topologies</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">superimpose_topologies</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">,</span> <span class="n">pair_charge_atol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">use_charges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">starting_node_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">disjoint_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">net_charge_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">net_charge_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">redistribute_charges_over_unmatched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parmed_ligA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parmed_ligZ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">align_molecules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">partial_rings_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_charges_completely</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_bond_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_only_element</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_atom_names_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">starting_pairs_heuristics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">starting_pair_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>The main function that manages the entire process.</p>
<p>TODO:
- check if each molecule topology is connected</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3146</span>
<span class="normal">3147</span>
<span class="normal">3148</span>
<span class="normal">3149</span>
<span class="normal">3150</span>
<span class="normal">3151</span>
<span class="normal">3152</span>
<span class="normal">3153</span>
<span class="normal">3154</span>
<span class="normal">3155</span>
<span class="normal">3156</span>
<span class="normal">3157</span>
<span class="normal">3158</span>
<span class="normal">3159</span>
<span class="normal">3160</span>
<span class="normal">3161</span>
<span class="normal">3162</span>
<span class="normal">3163</span>
<span class="normal">3164</span>
<span class="normal">3165</span>
<span class="normal">3166</span>
<span class="normal">3167</span>
<span class="normal">3168</span>
<span class="normal">3169</span>
<span class="normal">3170</span>
<span class="normal">3171</span>
<span class="normal">3172</span>
<span class="normal">3173</span>
<span class="normal">3174</span>
<span class="normal">3175</span>
<span class="normal">3176</span>
<span class="normal">3177</span>
<span class="normal">3178</span>
<span class="normal">3179</span>
<span class="normal">3180</span>
<span class="normal">3181</span>
<span class="normal">3182</span>
<span class="normal">3183</span>
<span class="normal">3184</span>
<span class="normal">3185</span>
<span class="normal">3186</span>
<span class="normal">3187</span>
<span class="normal">3188</span>
<span class="normal">3189</span>
<span class="normal">3190</span>
<span class="normal">3191</span>
<span class="normal">3192</span>
<span class="normal">3193</span>
<span class="normal">3194</span>
<span class="normal">3195</span>
<span class="normal">3196</span>
<span class="normal">3197</span>
<span class="normal">3198</span>
<span class="normal">3199</span>
<span class="normal">3200</span>
<span class="normal">3201</span>
<span class="normal">3202</span>
<span class="normal">3203</span>
<span class="normal">3204</span>
<span class="normal">3205</span>
<span class="normal">3206</span>
<span class="normal">3207</span>
<span class="normal">3208</span>
<span class="normal">3209</span>
<span class="normal">3210</span>
<span class="normal">3211</span>
<span class="normal">3212</span>
<span class="normal">3213</span>
<span class="normal">3214</span>
<span class="normal">3215</span>
<span class="normal">3216</span>
<span class="normal">3217</span>
<span class="normal">3218</span>
<span class="normal">3219</span>
<span class="normal">3220</span>
<span class="normal">3221</span>
<span class="normal">3222</span>
<span class="normal">3223</span>
<span class="normal">3224</span>
<span class="normal">3225</span>
<span class="normal">3226</span>
<span class="normal">3227</span>
<span class="normal">3228</span>
<span class="normal">3229</span>
<span class="normal">3230</span>
<span class="normal">3231</span>
<span class="normal">3232</span>
<span class="normal">3233</span>
<span class="normal">3234</span>
<span class="normal">3235</span>
<span class="normal">3236</span>
<span class="normal">3237</span>
<span class="normal">3238</span>
<span class="normal">3239</span>
<span class="normal">3240</span>
<span class="normal">3241</span>
<span class="normal">3242</span>
<span class="normal">3243</span>
<span class="normal">3244</span>
<span class="normal">3245</span>
<span class="normal">3246</span>
<span class="normal">3247</span>
<span class="normal">3248</span>
<span class="normal">3249</span>
<span class="normal">3250</span>
<span class="normal">3251</span>
<span class="normal">3252</span>
<span class="normal">3253</span>
<span class="normal">3254</span>
<span class="normal">3255</span>
<span class="normal">3256</span>
<span class="normal">3257</span>
<span class="normal">3258</span>
<span class="normal">3259</span>
<span class="normal">3260</span>
<span class="normal">3261</span>
<span class="normal">3262</span>
<span class="normal">3263</span>
<span class="normal">3264</span>
<span class="normal">3265</span>
<span class="normal">3266</span>
<span class="normal">3267</span>
<span class="normal">3268</span>
<span class="normal">3269</span>
<span class="normal">3270</span>
<span class="normal">3271</span>
<span class="normal">3272</span>
<span class="normal">3273</span>
<span class="normal">3274</span>
<span class="normal">3275</span>
<span class="normal">3276</span>
<span class="normal">3277</span>
<span class="normal">3278</span>
<span class="normal">3279</span>
<span class="normal">3280</span>
<span class="normal">3281</span>
<span class="normal">3282</span>
<span class="normal">3283</span>
<span class="normal">3284</span>
<span class="normal">3285</span>
<span class="normal">3286</span>
<span class="normal">3287</span>
<span class="normal">3288</span>
<span class="normal">3289</span>
<span class="normal">3290</span>
<span class="normal">3291</span>
<span class="normal">3292</span>
<span class="normal">3293</span>
<span class="normal">3294</span>
<span class="normal">3295</span>
<span class="normal">3296</span>
<span class="normal">3297</span>
<span class="normal">3298</span>
<span class="normal">3299</span>
<span class="normal">3300</span>
<span class="normal">3301</span>
<span class="normal">3302</span>
<span class="normal">3303</span>
<span class="normal">3304</span>
<span class="normal">3305</span>
<span class="normal">3306</span>
<span class="normal">3307</span>
<span class="normal">3308</span>
<span class="normal">3309</span>
<span class="normal">3310</span>
<span class="normal">3311</span>
<span class="normal">3312</span>
<span class="normal">3313</span>
<span class="normal">3314</span>
<span class="normal">3315</span>
<span class="normal">3316</span>
<span class="normal">3317</span>
<span class="normal">3318</span>
<span class="normal">3319</span>
<span class="normal">3320</span>
<span class="normal">3321</span>
<span class="normal">3322</span>
<span class="normal">3323</span>
<span class="normal">3324</span>
<span class="normal">3325</span>
<span class="normal">3326</span>
<span class="normal">3327</span>
<span class="normal">3328</span>
<span class="normal">3329</span>
<span class="normal">3330</span>
<span class="normal">3331</span>
<span class="normal">3332</span>
<span class="normal">3333</span>
<span class="normal">3334</span>
<span class="normal">3335</span>
<span class="normal">3336</span>
<span class="normal">3337</span>
<span class="normal">3338</span>
<span class="normal">3339</span>
<span class="normal">3340</span>
<span class="normal">3341</span>
<span class="normal">3342</span>
<span class="normal">3343</span>
<span class="normal">3344</span>
<span class="normal">3345</span>
<span class="normal">3346</span>
<span class="normal">3347</span>
<span class="normal">3348</span>
<span class="normal">3349</span>
<span class="normal">3350</span>
<span class="normal">3351</span>
<span class="normal">3352</span>
<span class="normal">3353</span>
<span class="normal">3354</span>
<span class="normal">3355</span>
<span class="normal">3356</span>
<span class="normal">3357</span>
<span class="normal">3358</span>
<span class="normal">3359</span>
<span class="normal">3360</span>
<span class="normal">3361</span>
<span class="normal">3362</span>
<span class="normal">3363</span>
<span class="normal">3364</span>
<span class="normal">3365</span>
<span class="normal">3366</span>
<span class="normal">3367</span>
<span class="normal">3368</span>
<span class="normal">3369</span>
<span class="normal">3370</span>
<span class="normal">3371</span>
<span class="normal">3372</span>
<span class="normal">3373</span>
<span class="normal">3374</span>
<span class="normal">3375</span>
<span class="normal">3376</span>
<span class="normal">3377</span>
<span class="normal">3378</span>
<span class="normal">3379</span>
<span class="normal">3380</span>
<span class="normal">3381</span>
<span class="normal">3382</span>
<span class="normal">3383</span>
<span class="normal">3384</span>
<span class="normal">3385</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">superimpose_topologies</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span>
                           <span class="n">top2_nodes</span><span class="p">,</span>
                           <span class="n">pair_charge_atol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                           <span class="n">use_charges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">use_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">starting_node_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">force_mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">disjoint_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">net_charge_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">net_charge_threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                           <span class="n">redistribute_charges_over_unmatched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">parmed_ligA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">parmed_ligZ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">align_molecules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">partial_rings_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">ignore_charges_completely</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">ignore_bond_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">ignore_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">use_general_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">use_only_element</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">check_atom_names_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">starting_pairs_heuristics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">starting_pair_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The main function that manages the entire process.</span>

<span class="sd">    TODO:</span>
<span class="sd">    - check if each molecule topology is connected</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_charges_completely</span><span class="p">:</span>
        <span class="n">whole_charge</span> <span class="o">=</span> <span class="n">SuperimposedTopology</span><span class="o">.</span><span class="n">validate_charges</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">)</span>

    <span class="c1"># ensure that none of the atom names across the two molecules are the different</span>
    <span class="k">if</span> <span class="n">check_atom_names_unique</span><span class="p">:</span>
        <span class="n">same_atom_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">top1_nodes</span><span class="p">}</span><span class="o">.</span><span class="n">intersection</span><span class="p">({</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">top2_nodes</span><span class="p">})</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">same_atom_names</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The atoms across the two ligands have the same atom names. &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;This might make it harder to trace back any problems. &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;Please ensure atom names are unique across the two ligands. : </span><span class="si">{</span><span class="n">same_atom_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">weights</span>

    <span class="c1"># Get the superimposed topology(/ies).</span>
    <span class="n">suptops</span> <span class="o">=</span> <span class="n">_superimpose_topologies</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">,</span> <span class="n">parmed_ligA</span><span class="p">,</span> <span class="n">parmed_ligZ</span><span class="p">,</span>
                                      <span class="n">starting_node_pairs</span><span class="o">=</span><span class="n">starting_node_pairs</span><span class="p">,</span>
                                      <span class="n">ignore_coords</span><span class="o">=</span><span class="n">ignore_coords</span><span class="p">,</span>
                                      <span class="n">use_general_type</span><span class="o">=</span><span class="n">use_general_type</span><span class="p">,</span>
                                      <span class="n">starting_pairs_heuristics</span><span class="o">=</span><span class="n">starting_pairs_heuristics</span><span class="p">,</span>
                                      <span class="n">starting_pair_seed</span><span class="o">=</span><span class="n">starting_pair_seed</span><span class="p">,</span>
                                      <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">suptops</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Did not find a single superimposition state.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Phase 1: The number of SupTops found: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SupTops lengths:  </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;ST</span><span class="si">{</span><span class="n">st</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">suptops</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># ignore bond types</span>
    <span class="c1"># they are ignored when creating the run file with tleap anyway</span>
    <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
        <span class="c1"># fixme - transition to config</span>
        <span class="n">st</span><span class="o">.</span><span class="n">ignore_bond_types</span> <span class="o">=</span> <span class="n">ignore_bond_types</span>

    <span class="c1"># link the suptops to their original molecule data</span>
    <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
        <span class="c1"># fixme - transition to config</span>
        <span class="n">suptop</span><span class="o">.</span><span class="n">set_tops</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">)</span>
        <span class="n">suptop</span><span class="o">.</span><span class="n">set_parmeds</span><span class="p">(</span><span class="n">parmed_ligA</span><span class="p">,</span> <span class="n">parmed_ligZ</span><span class="p">)</span>

    <span class="c1"># align the 3D coordinates before applying further changes</span>
    <span class="c1"># use the largest suptop to align the molecules</span>
    <span class="k">if</span> <span class="n">align_molecules</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_coords</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">take_largest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
        <span class="n">reduce</span><span class="p">(</span><span class="n">take_largest</span><span class="p">,</span> <span class="n">suptops</span><span class="p">)</span><span class="o">.</span><span class="n">align_ligands_using_mcs</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;RMSD of the best overlay: </span><span class="si">{</span><span class="n">suptops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">align_ligands_using_mcs</span><span class="p">()</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># fixme - you might not need because we are now doing this on the way back</span>
    <span class="c1"># if useCoords:</span>
    <span class="c1">#     for sup_top in sup_tops:</span>
    <span class="c1">#         sup_top.correct_for_coordinates()</span>

    <span class="c1"># mismatch atoms as requested</span>
    <span class="k">if</span> <span class="n">force_mismatch</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sp</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">force_mismatch</span><span class="p">:</span>
                    <span class="n">sp</span><span class="o">.</span><span class="n">remove_node_pair</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Removing the pair: </span><span class="si">{</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">))</span><span class="si">}</span><span class="s1">, as requested&#39;</span><span class="p">)</span>

    <span class="c1"># ensure that ring-atoms are not matched to non-ring atoms</span>
    <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">ringring</span><span class="p">()</span>

    <span class="c1"># introduce exceptions to the atom type types so that certain</span>
    <span class="c1"># different atom types are seen as the same</span>
    <span class="c1"># ie allow to swap cc-cd with cd-cc (and other pairs)</span>
    <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">match_gaff2_nondirectional_bonds</span><span class="p">()</span>

    <span class="c1"># remove matched atom pairs that have a different specific atom type</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_only_element</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="c1"># fixme - rename</span>
            <span class="n">st</span><span class="o">.</span><span class="n">enforce_matched_atom_types_are_the_same</span><span class="p">()</span>

    <span class="c1"># ensure that the bonds are used correctly.</span>
    <span class="c1"># If the bonds disagree, but atom types are the same, remove both bonded pairs</span>
    <span class="c1"># we cannot have A-B where the bonds are different. In this case, we have A-B=C and A=B-C in a ring,</span>
    <span class="c1"># we could in theory remove A,B,C which makes sense as these will show slightly different behaviour,</span>
    <span class="c1"># and this we we avoid tensions in the bonds, and represent both</span>
    <span class="c1"># fixme - apparently we are not relaying on these?</span>
    <span class="c1"># turned off as this is reflected in the atom type</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_bond_types</span> <span class="ow">and</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">removeMatchedPairsWithDifferentBonds</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">removed</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Removed bonded pairs due to different bonds: </span><span class="si">{</span><span class="n">removed</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_rings_allowed</span><span class="p">:</span>
        <span class="c1"># remove partial rings, note this is a cascade problem if there are double rings</span>
        <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="n">suptop</span><span class="o">.</span><span class="n">enforce_no_partial_rings</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Removed pairs because partial rings are not allowed </span><span class="si">{</span><span class="n">suptop</span><span class="o">.</span><span class="n">_removed_because_unmatched_rings</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># note that charges need to be checked before assigning IDs.</span>
    <span class="c1"># ie if charges are different, the matched pair</span>
    <span class="c1"># becomes two different atoms with different IDs</span>
    <span class="k">if</span> <span class="n">use_charges</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_charges_completely</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sup_top</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="n">sup_top</span><span class="o">.</span><span class="n">unmatch_pairs_with_different_charges</span><span class="p">(</span><span class="n">atol</span><span class="o">=</span><span class="n">pair_charge_atol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">removed</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Removed pairs with charge incompatibility: &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="p">[(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">sup_top</span><span class="o">.</span><span class="n">_removed_pairs_with_charge_difference</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_rings_allowed</span><span class="p">:</span>
        <span class="c1"># We once again check if partial rings were created due to different charges on atoms.</span>
        <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="n">suptop</span><span class="o">.</span><span class="n">enforce_no_partial_rings</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Removed pairs because partial rings are not allowed </span><span class="si">{</span><span class="n">suptop</span><span class="o">.</span><span class="n">_removed_because_unmatched_rings</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">net_charge_filter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_charges_completely</span><span class="p">:</span>
        <span class="c1"># Note that we apply this rule to each suptop.</span>
        <span class="c1"># This is because we are only keeping one suptop right now.</span>
        <span class="c1"># However, if disjointed components are allowed, these number might change.</span>
        <span class="c1"># ensure that each suptop component has net charge differences &lt; 0.1</span>
        <span class="c1"># Furthermore, disjointed components has not yet been applied,</span>
        <span class="c1"># even though it might have an effect, fixme - should disjointed be applied first?</span>
        <span class="c1"># to account for this implement #251</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Accounting for net charge limit of </span><span class="si">{</span><span class="n">net_charge_threshold</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">suptop</span><span class="o">.</span><span class="n">apply_net_charge_filter</span><span class="p">(</span><span class="n">net_charge_threshold</span><span class="p">)</span>

            <span class="c1"># remove the suptop from the list if it&#39;s empty</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">suptops</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Display information</span>
            <span class="k">if</span> <span class="n">suptop</span><span class="o">.</span><span class="n">_removed_due_to_net_charge</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SupTop: Removed pairs due to net charge: &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="p">[[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">suptop</span><span class="o">.</span><span class="n">_removed_due_to_net_charge</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_rings_allowed</span><span class="p">:</span>
        <span class="c1"># This is the 3rd check of partial rings. This time they might have been created due to net_charges.</span>
        <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="n">suptop</span><span class="o">.</span><span class="n">enforce_no_partial_rings</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Removed pairs because partial rings are not allowed </span><span class="si">{</span><span class="n">suptop</span><span class="o">.</span><span class="n">_removed_because_unmatched_rings</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># remove the suptops that are empty</span>
    <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">suptops</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">disjoint_components</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Checking for disjoint components in the </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span><span class="si">}</span><span class="s1"> suptops&#39;</span><span class="p">)</span>
        <span class="c1"># ensure that each suptop represents one CC</span>
        <span class="c1"># check if the graph was divided after removing any pairs (e.g. due to charge mismatch)</span>
        <span class="c1"># fixme - add the log about which atoms are removed?</span>
        <span class="p">[</span><span class="n">st</span><span class="o">.</span><span class="n">largest_cc_survives</span><span class="p">()</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Removed disjoint components: &#39;</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">_removed_because_disjointed_cc</span><span class="p">)</span>

        <span class="c1"># fixme</span>
        <span class="c1"># remove the smaller suptop, or one arbitrary if they are equivalent</span>
        <span class="c1"># if len(suptops) &gt; 1:</span>
        <span class="c1">#     max_len = max([len(suptop) for suptop in suptops])</span>
        <span class="c1">#     for suptop in suptops[::-1]:</span>
        <span class="c1">#         if len(suptop) &lt; max_len:</span>
        <span class="c1">#             suptops.remove(suptop)</span>
        <span class="c1">#</span>
        <span class="c1">#     # if there are equal length suptops left, take only the first one</span>
        <span class="c1">#     if len(suptops) &gt; 1:</span>
        <span class="c1">#         suptops = [suptops[0]]</span>
        <span class="c1">#</span>
        <span class="c1"># assert len(suptops) == 1, suptops</span>

    <span class="n">suptop</span> <span class="o">=</span> <span class="n">extract_best_suptop</span><span class="p">(</span><span class="n">suptops</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">,</span> <span class="n">get_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">redistribute_charges_over_unmatched</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_charges_completely</span><span class="p">:</span>
        <span class="c1"># assume that none of the suptops are disjointed</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Assuming that all suptops are separate at this point&#39;</span><span class="p">)</span>
        <span class="c1"># fixme: apply distribution of q only on the first st, that&#39;s the best one anyway,</span>

        <span class="c1"># we only want to apply redistribution once on the largest piece for now</span>
        <span class="n">suptop</span><span class="o">.</span><span class="n">redistribute_charges</span><span class="p">()</span>

    <span class="c1"># atom ID assignment has to come after any removal of atoms due to their mismatching charges</span>
    <span class="n">suptop</span><span class="o">.</span><span class="n">assign_atoms_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># there might be several best solutions, order them according the RMSDs</span>
    <span class="c1"># suptops.sort(key=lambda st: st.rmsd())</span>

    <span class="c1"># fixme - remove the hydrogens without attached heavy atoms</span>

    <span class="c1"># resolve_sup_top_multiple_match(sup_tops_charges)</span>
    <span class="c1"># sup_top_correct_chirality(sup_tops_charges, sup_tops_no_charges, atol=atol)</span>

    <span class="c1"># carry out a check. Each</span>
    <span class="k">if</span> <span class="n">align_molecules</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_coords</span><span class="p">:</span>
        <span class="n">main_rmsd</span> <span class="o">=</span> <span class="n">suptop</span><span class="o">.</span><span class="n">align_ligands_using_mcs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">mirror</span> <span class="ow">in</span> <span class="n">suptop</span><span class="o">.</span><span class="n">mirrors</span><span class="p">:</span>
            <span class="n">mirror_rmsd</span> <span class="o">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">align_ligands_using_mcs</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mirror_rmsd</span> <span class="o">&lt;</span> <span class="n">main_rmsd</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;THE MIRROR RMSD IS LOWER THAN THE MAIN RMSD&#39;</span><span class="p">)</span>
        <span class="n">suptop</span><span class="o">.</span><span class="n">align_ligands_using_mcs</span><span class="p">(</span><span class="n">overwrite_original</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># print a general summary</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;-------- Summary -----------&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of matched pairs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">)</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">)</span><span class="si">}</span><span class="s1">L/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">top2_nodes</span><span class="p">)</span><span class="si">}</span><span class="s1">R&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Disappearing atoms: </span><span class="si">{</span><span class="w"> </span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">%&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Appearing atoms: </span><span class="si">{</span><span class="w"> </span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top2_nodes</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">top2_nodes</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">%&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">suptop</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.extract_best_suptop" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">extract_best_suptop</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">extract_best_suptop</span><span class="p">(</span><span class="n">suptops</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">get_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Assumes that any merging possible already took place.
We now have a set of solutions and have to select the best ones.</p>
<p>:param suptops:
:param ignore_coords:
:return:</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3396</span>
<span class="normal">3397</span>
<span class="normal">3398</span>
<span class="normal">3399</span>
<span class="normal">3400</span>
<span class="normal">3401</span>
<span class="normal">3402</span>
<span class="normal">3403</span>
<span class="normal">3404</span>
<span class="normal">3405</span>
<span class="normal">3406</span>
<span class="normal">3407</span>
<span class="normal">3408</span>
<span class="normal">3409</span>
<span class="normal">3410</span>
<span class="normal">3411</span>
<span class="normal">3412</span>
<span class="normal">3413</span>
<span class="normal">3414</span>
<span class="normal">3415</span>
<span class="normal">3416</span>
<span class="normal">3417</span>
<span class="normal">3418</span>
<span class="normal">3419</span>
<span class="normal">3420</span>
<span class="normal">3421</span>
<span class="normal">3422</span>
<span class="normal">3423</span>
<span class="normal">3424</span>
<span class="normal">3425</span>
<span class="normal">3426</span>
<span class="normal">3427</span>
<span class="normal">3428</span>
<span class="normal">3429</span>
<span class="normal">3430</span>
<span class="normal">3431</span>
<span class="normal">3432</span>
<span class="normal">3433</span>
<span class="normal">3434</span>
<span class="normal">3435</span>
<span class="normal">3436</span>
<span class="normal">3437</span>
<span class="normal">3438</span>
<span class="normal">3439</span>
<span class="normal">3440</span>
<span class="normal">3441</span>
<span class="normal">3442</span>
<span class="normal">3443</span>
<span class="normal">3444</span>
<span class="normal">3445</span>
<span class="normal">3446</span>
<span class="normal">3447</span>
<span class="normal">3448</span>
<span class="normal">3449</span>
<span class="normal">3450</span>
<span class="normal">3451</span>
<span class="normal">3452</span>
<span class="normal">3453</span>
<span class="normal">3454</span>
<span class="normal">3455</span>
<span class="normal">3456</span>
<span class="normal">3457</span>
<span class="normal">3458</span>
<span class="normal">3459</span>
<span class="normal">3460</span>
<span class="normal">3461</span>
<span class="normal">3462</span>
<span class="normal">3463</span>
<span class="normal">3464</span>
<span class="normal">3465</span>
<span class="normal">3466</span>
<span class="normal">3467</span>
<span class="normal">3468</span>
<span class="normal">3469</span>
<span class="normal">3470</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_best_suptop</span><span class="p">(</span><span class="n">suptops</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">get_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assumes that any merging possible already took place.</span>
<span class="sd">    We now have a set of solutions and have to select the best ones.</span>

<span class="sd">    :param suptops:</span>
<span class="sd">    :param ignore_coords:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># fixme - ignore coords currently does not work</span>
    <span class="c1"># multiple different paths to traverse the topologies were found</span>
    <span class="c1"># this means some kind of symmetry in the topologies</span>
    <span class="c1"># For example, in the below drawn case (starting from C1-C11) there are two</span>
    <span class="c1"># solutions: (O1-O11, O2-O12) and (O1-O12, O2-O11).</span>
    <span class="c1">#     LIGAND 1        LIGAND 2</span>
    <span class="c1">#        C1              C11</span>
    <span class="c1">#        \                \</span>
    <span class="c1">#        N1              N11</span>
    <span class="c1">#        /\              / \</span>
    <span class="c1">#     O1    O2        O11   O12</span>
    <span class="c1"># Here we decide which of the mappings is better.</span>
    <span class="c1"># fixme - uses coordinates to decide which mapping is better.</span>
    <span class="c1">#  - Improve: use dihedral angles to decide which mapping is better too</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">item_or_list</span><span class="p">(</span><span class="n">suptops</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">get_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">suptops</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">suptops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cannot decide on the best mapping without any suptops...&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">item_or_list</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span>

    <span class="c1">#candidates = copy.copy(suptops)</span>

    <span class="c1"># sort from largest to smallest</span>
    <span class="n">suptops</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">st</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ignore_coords</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">item_or_list</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span>

    <span class="c1"># when length is the same, take the smaller RMSD</span>
    <span class="c1"># most likely this is about hydrogens</span>
    <span class="n">different_length_suptops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">same_length_suptops</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">suptops</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">st</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)):</span>
        <span class="c1"># order by RMSD</span>
        <span class="n">sorted_by_rmsd</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">same_length_suptops</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">st</span><span class="p">:</span> <span class="n">st</span><span class="o">.</span><span class="n">align_ligands_using_mcs</span><span class="p">())</span>
        <span class="c1"># these have the same lengths and the same RMSD, so they must be mirrors</span>
        <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">sorted_by_rmsd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">suptop</span><span class="o">.</span><span class="n">is_mirror_of</span><span class="p">(</span><span class="n">sorted_by_rmsd</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sorted_by_rmsd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_mirror_suptop</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># add it as a different solution</span>
                <span class="n">different_length_suptops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span>
        <span class="n">different_length_suptops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_by_rmsd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># sort using weights</span>
    <span class="c1"># score = mcs_score * weight - rmsd * weight ;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">score</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
        <span class="c1"># inverse for 0 to be optimal</span>
        <span class="n">mcs_score</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">st</span><span class="o">.</span><span class="n">mcs_score</span><span class="p">())</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># rmsd 0 is best as well</span>
        <span class="n">rmsd_score</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">align_ligands_using_mcs</span><span class="p">()</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">mcs_score</span> <span class="o">+</span> <span class="n">rmsd_score</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="n">different_length_suptops</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">score</span><span class="p">)</span>
    <span class="c1"># if they have a different length, there must be a reason why it is better.</span>
    <span class="c1"># todo</span>

    <span class="k">return</span> <span class="n">item_or_list</span><span class="p">(</span><span class="n">different_length_suptops</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.is_mirror_of_one" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">is_mirror_of_one</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">is_mirror_of_one</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">,</span> <span class="n">suptops</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>"Mirror" in the sense that it is an alternative topological way to traverse the molecule.</p>
<p>Depending on the "better" fit between the two mirrors, we pick the one that is better.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3526</span>
<span class="normal">3527</span>
<span class="normal">3528</span>
<span class="normal">3529</span>
<span class="normal">3530</span>
<span class="normal">3531</span>
<span class="normal">3532</span>
<span class="normal">3533</span>
<span class="normal">3534</span>
<span class="normal">3535</span>
<span class="normal">3536</span>
<span class="normal">3537</span>
<span class="normal">3538</span>
<span class="normal">3539</span>
<span class="normal">3540</span>
<span class="normal">3541</span>
<span class="normal">3542</span>
<span class="normal">3543</span>
<span class="normal">3544</span>
<span class="normal">3545</span>
<span class="normal">3546</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_mirror_of_one</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">,</span> <span class="n">suptops</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;Mirror&quot; in the sense that it is an alternative topological way to traverse the molecule.</span>

<span class="sd">    Depending on the &quot;better&quot; fit between the two mirrors, we pick the one that is better.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">next_suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">next_suptop</span><span class="o">.</span><span class="n">is_mirror_of</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">):</span>
            <span class="c1"># the suptop saved as the mirror should be the suptop</span>
            <span class="c1"># that is judged to be of a lower quality</span>
            <span class="n">best_suptop</span> <span class="o">=</span> <span class="n">extract_best_suptop</span><span class="p">([</span><span class="n">candidate_suptop</span><span class="p">,</span> <span class="n">next_suptop</span><span class="p">],</span> <span class="n">ignore_coords</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">next_suptop</span> <span class="ow">is</span> <span class="n">best_suptop</span><span class="p">:</span>
                <span class="n">next_suptop</span><span class="o">.</span><span class="n">add_mirror_suptop</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">suptops</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">next_suptop</span><span class="p">)</span>
                <span class="n">suptops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.generate_nxg_from_list" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">generate_nxg_from_list</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">generate_nxg_from_list</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Helper function. Generates a graph from a list of atoms
@parameter atoms: follow the internal format for atoms</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3608</span>
<span class="normal">3609</span>
<span class="normal">3610</span>
<span class="normal">3611</span>
<span class="normal">3612</span>
<span class="normal">3613</span>
<span class="normal">3614</span>
<span class="normal">3615</span>
<span class="normal">3616</span>
<span class="normal">3617</span>
<span class="normal">3618</span>
<span class="normal">3619</span>
<span class="normal">3620</span>
<span class="normal">3621</span>
<span class="normal">3622</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_nxg_from_list</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function. Generates a graph from a list of atoms</span>
<span class="sd">    @parameter atoms: follow the internal format for atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="c1"># add attoms</span>
    <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
    <span class="c1"># add all the edges</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="c1"># add the edges from nA</span>
        <span class="k">for</span> <span class="n">a_bonded</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_bonded</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.get_starting_configurations" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">get_starting_configurations</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_starting_configurations</span><span class="p">(</span><span class="n">left_atoms</span><span class="p">,</span> <span class="n">right_atoms</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">filter_ring_c</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <pre><code>Minimise the number of starting configurations to optimise the process speed.
Use:
 * the rarity of the specific atom types,
 * whether the atoms are bottlenecks (so they do not suffer from symmetry).
    The issue with symmetry is that it is impossible to find the proper
    symmetry match if you start from the wrong symmetry.
@parameter fraction: ensure that the number of atoms used to start the traversal is not more
    than the fraction value of the overall number of possible matches, counted as
    a fraction of the maximum possible number of pairs (MIN(LEFTNODES, RIGHTNODES))
@parameter filter_ring_c: filter out the carbon elements in the rings to avoid any issues
    with the symmetry. This assumes that a ring usually has one N element, etc.
</code></pre>
<p>TODO - ignore hydrogens?</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3625</span>
<span class="normal">3626</span>
<span class="normal">3627</span>
<span class="normal">3628</span>
<span class="normal">3629</span>
<span class="normal">3630</span>
<span class="normal">3631</span>
<span class="normal">3632</span>
<span class="normal">3633</span>
<span class="normal">3634</span>
<span class="normal">3635</span>
<span class="normal">3636</span>
<span class="normal">3637</span>
<span class="normal">3638</span>
<span class="normal">3639</span>
<span class="normal">3640</span>
<span class="normal">3641</span>
<span class="normal">3642</span>
<span class="normal">3643</span>
<span class="normal">3644</span>
<span class="normal">3645</span>
<span class="normal">3646</span>
<span class="normal">3647</span>
<span class="normal">3648</span>
<span class="normal">3649</span>
<span class="normal">3650</span>
<span class="normal">3651</span>
<span class="normal">3652</span>
<span class="normal">3653</span>
<span class="normal">3654</span>
<span class="normal">3655</span>
<span class="normal">3656</span>
<span class="normal">3657</span>
<span class="normal">3658</span>
<span class="normal">3659</span>
<span class="normal">3660</span>
<span class="normal">3661</span>
<span class="normal">3662</span>
<span class="normal">3663</span>
<span class="normal">3664</span>
<span class="normal">3665</span>
<span class="normal">3666</span>
<span class="normal">3667</span>
<span class="normal">3668</span>
<span class="normal">3669</span>
<span class="normal">3670</span>
<span class="normal">3671</span>
<span class="normal">3672</span>
<span class="normal">3673</span>
<span class="normal">3674</span>
<span class="normal">3675</span>
<span class="normal">3676</span>
<span class="normal">3677</span>
<span class="normal">3678</span>
<span class="normal">3679</span>
<span class="normal">3680</span>
<span class="normal">3681</span>
<span class="normal">3682</span>
<span class="normal">3683</span>
<span class="normal">3684</span>
<span class="normal">3685</span>
<span class="normal">3686</span>
<span class="normal">3687</span>
<span class="normal">3688</span>
<span class="normal">3689</span>
<span class="normal">3690</span>
<span class="normal">3691</span>
<span class="normal">3692</span>
<span class="normal">3693</span>
<span class="normal">3694</span>
<span class="normal">3695</span>
<span class="normal">3696</span>
<span class="normal">3697</span>
<span class="normal">3698</span>
<span class="normal">3699</span>
<span class="normal">3700</span>
<span class="normal">3701</span>
<span class="normal">3702</span>
<span class="normal">3703</span>
<span class="normal">3704</span>
<span class="normal">3705</span>
<span class="normal">3706</span>
<span class="normal">3707</span>
<span class="normal">3708</span>
<span class="normal">3709</span>
<span class="normal">3710</span>
<span class="normal">3711</span>
<span class="normal">3712</span>
<span class="normal">3713</span>
<span class="normal">3714</span>
<span class="normal">3715</span>
<span class="normal">3716</span>
<span class="normal">3717</span>
<span class="normal">3718</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_starting_configurations</span><span class="p">(</span><span class="n">left_atoms</span><span class="p">,</span> <span class="n">right_atoms</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">filter_ring_c</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Minimise the number of starting configurations to optimise the process speed.</span>
<span class="sd">        Use:</span>
<span class="sd">         * the rarity of the specific atom types,</span>
<span class="sd">         * whether the atoms are bottlenecks (so they do not suffer from symmetry).</span>
<span class="sd">            The issue with symmetry is that it is impossible to find the proper</span>
<span class="sd">            symmetry match if you start from the wrong symmetry.</span>
<span class="sd">        @parameter fraction: ensure that the number of atoms used to start the traversal is not more</span>
<span class="sd">            than the fraction value of the overall number of possible matches, counted as</span>
<span class="sd">            a fraction of the maximum possible number of pairs (MIN(LEFTNODES, RIGHTNODES))</span>
<span class="sd">        @parameter filter_ring_c: filter out the carbon elements in the rings to avoid any issues</span>
<span class="sd">            with the symmetry. This assumes that a ring usually has one N element, etc.</span>

<span class="sd">    TODO - ignore hydrogens?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Superimposition: optimising the search by narrowing down the starting configuration. &#39;</span><span class="p">)</span>
    <span class="n">left_atoms_noh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="n">left_atoms</span><span class="p">))</span>
    <span class="n">right_atoms_noh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="n">right_atoms</span><span class="p">))</span>

    <span class="c1"># find out which atoms types are common across the two molecules</span>
    <span class="c1"># fixme - consider subclassing atom from MDAnalysis class and adding functions for some of these features</span>
    <span class="c1"># first, find the unique types for each molecule</span>
    <span class="n">left_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">left_atom</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">left_atom</span> <span class="ow">in</span> <span class="n">left_atoms_noh</span><span class="p">}</span>
    <span class="n">right_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">right_atom</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">right_atom</span> <span class="ow">in</span> <span class="n">right_atoms_noh</span><span class="p">}</span>
    <span class="n">common_types</span> <span class="o">=</span> <span class="n">left_types</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">right_types</span><span class="p">)</span>

    <span class="c1"># for each atom type, check how many maximum atoms can theoretically be matched</span>
    <span class="n">per_type_max_counter</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="n">common_types</span><span class="p">:</span>
        <span class="n">left_count_by_type</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">left_atom</span> <span class="ow">in</span> <span class="n">left_atoms</span> <span class="k">if</span> <span class="n">left_atom</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">atom_type</span><span class="p">])</span>
        <span class="n">right_count_by_type</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">right_atom</span> <span class="ow">in</span> <span class="n">right_atoms</span> <span class="k">if</span> <span class="n">right_atom</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">atom_type</span><span class="p">])</span>
        <span class="n">per_type_max_counter</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left_count_by_type</span><span class="p">,</span> <span class="n">right_count_by_type</span><span class="p">)</span>
    <span class="n">max_overlap_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">per_type_max_counter</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Largest MCS size: </span><span class="si">{</span><span class="n">max_overlap_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">left_atoms_starting</span> <span class="o">=</span> <span class="n">left_atoms_noh</span><span class="p">[:]</span>
    <span class="n">right_atoms_starting</span> <span class="o">=</span> <span class="n">right_atoms_noh</span><span class="p">[:]</span>

    <span class="c1"># ignore carbons in cycles</span>
    <span class="c1"># fixme - we should not use this for macrocycles, which should be ignored here</span>
    <span class="k">if</span> <span class="n">filter_ring_c</span><span class="p">:</span>
        <span class="n">nxl</span> <span class="o">=</span> <span class="n">generate_nxg_from_list</span><span class="p">(</span><span class="n">left_atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">nxl</span><span class="p">):</span>
            <span class="c1"># ignore the carbons in the cycle</span>
            <span class="n">cycle_carbons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">cycle</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Superimposition of left atoms: Ignoring carbons as starting configurations because &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;they are carbons in a cycle: </span><span class="si">{</span><span class="n">cycle_carbons</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="p">[</span><span class="n">left_atoms_starting</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cycle_carbons</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">left_atoms_starting</span><span class="p">]</span>
        <span class="n">nxr</span> <span class="o">=</span> <span class="n">generate_nxg_from_list</span><span class="p">(</span><span class="n">right_atoms_starting</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">nxr</span><span class="p">):</span>
            <span class="c1"># ignore the carbons in the cycle</span>
            <span class="n">cycle_carbons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">cycle</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Superimposition of right atoms: Ignoring carbons as starting configurations because &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;they are carbons in a cycle: </span><span class="si">{</span><span class="n">cycle_carbons</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="p">[</span><span class="n">right_atoms_starting</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cycle_carbons</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">right_atoms_starting</span><span class="p">]</span>

    <span class="c1"># find out which atoms types are common across the two molecules</span>
    <span class="c1"># fixme - consider subclassing atom from MDAnalysis class and adding functions for some of these features</span>
    <span class="c1"># first, find the unique types for each molecule</span>
    <span class="n">left_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">left_atom</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">left_atom</span> <span class="ow">in</span> <span class="n">left_atoms_starting</span><span class="p">}</span>
    <span class="n">right_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">right_atom</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">right_atom</span> <span class="ow">in</span> <span class="n">right_atoms_starting</span><span class="p">}</span>
    <span class="n">common_types</span> <span class="o">=</span> <span class="n">left_types</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">right_types</span><span class="p">)</span>

    <span class="c1"># for each atom type, check how many maximum atoms can theoretically be matched</span>
    <span class="n">paired_by_type</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_after_cycle_carbons</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="n">common_types</span><span class="p">:</span>
        <span class="n">picked_left</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">left_atoms_starting</span><span class="p">))</span>
        <span class="n">picked_right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">right_atoms_starting</span><span class="p">))</span>
        <span class="n">paired_by_type</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">picked_left</span><span class="p">,</span> <span class="n">picked_right</span><span class="p">])</span>
        <span class="n">max_after_cycle_carbons</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">picked_left</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">picked_right</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Superimposition: simple max match of atoms after cycle carbons exclusion: </span><span class="si">{</span><span class="n">max_after_cycle_carbons</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># sort atom according to their type rarity</span>
    <span class="c1"># use the min across, since 1x4 mapping will give 4 options only, so we count this as one,</span>
    <span class="c1"># but 4x4 would give 16,</span>
    <span class="n">sorted_paired_by_type</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">paired_by_type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

    <span class="c1"># find the atoms in each type and generate appropriate pairs,</span>
    <span class="c1"># use only a fraction of the maximum theoretical match</span>
    <span class="n">desired_number_of_pairs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="n">max_overlap_size</span><span class="p">)</span>

    <span class="n">starting_configurations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">added_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">rare_left_atoms</span><span class="p">,</span> <span class="n">rare_right_atoms</span> <span class="ow">in</span> <span class="n">sorted_paired_by_type</span><span class="p">:</span>
        <span class="c1"># starting_configurations</span>
        <span class="n">starting_configurations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">rare_left_atoms</span><span class="p">,</span> <span class="n">rare_right_atoms</span><span class="p">)))</span>
        <span class="n">added_counter</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rare_left_atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">rare_right_atoms</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">added_counter</span> <span class="o">&gt;</span> <span class="n">desired_number_of_pairs</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Superimposition: initial starting pairs for the search: </span><span class="si">{</span><span class="n">starting_configurations</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">starting_configurations</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer._superimpose_topologies" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">_superimpose_topologies</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">_superimpose_topologies</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">,</span> <span class="n">mda1_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mda2_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">starting_node_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">starting_pairs_heuristics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">starting_pair_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Superimpose two molecules.</p>
<p>@parameter rare_atoms_starting_pair: instead of trying every possible pair for the starting configuration,
    use several information to narrow down the good possible starting configuration. Specifically,
    use two things: 1) the extact atom type, find how rare they are, and use the rarity to make the call,
    2) use the "linkers" and areas that are not parts of the rings to avoid the issue of symmetry in the ring.
    We are striving here to have 5% starting configurations.</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3721</span>
<span class="normal">3722</span>
<span class="normal">3723</span>
<span class="normal">3724</span>
<span class="normal">3725</span>
<span class="normal">3726</span>
<span class="normal">3727</span>
<span class="normal">3728</span>
<span class="normal">3729</span>
<span class="normal">3730</span>
<span class="normal">3731</span>
<span class="normal">3732</span>
<span class="normal">3733</span>
<span class="normal">3734</span>
<span class="normal">3735</span>
<span class="normal">3736</span>
<span class="normal">3737</span>
<span class="normal">3738</span>
<span class="normal">3739</span>
<span class="normal">3740</span>
<span class="normal">3741</span>
<span class="normal">3742</span>
<span class="normal">3743</span>
<span class="normal">3744</span>
<span class="normal">3745</span>
<span class="normal">3746</span>
<span class="normal">3747</span>
<span class="normal">3748</span>
<span class="normal">3749</span>
<span class="normal">3750</span>
<span class="normal">3751</span>
<span class="normal">3752</span>
<span class="normal">3753</span>
<span class="normal">3754</span>
<span class="normal">3755</span>
<span class="normal">3756</span>
<span class="normal">3757</span>
<span class="normal">3758</span>
<span class="normal">3759</span>
<span class="normal">3760</span>
<span class="normal">3761</span>
<span class="normal">3762</span>
<span class="normal">3763</span>
<span class="normal">3764</span>
<span class="normal">3765</span>
<span class="normal">3766</span>
<span class="normal">3767</span>
<span class="normal">3768</span>
<span class="normal">3769</span>
<span class="normal">3770</span>
<span class="normal">3771</span>
<span class="normal">3772</span>
<span class="normal">3773</span>
<span class="normal">3774</span>
<span class="normal">3775</span>
<span class="normal">3776</span>
<span class="normal">3777</span>
<span class="normal">3778</span>
<span class="normal">3779</span>
<span class="normal">3780</span>
<span class="normal">3781</span>
<span class="normal">3782</span>
<span class="normal">3783</span>
<span class="normal">3784</span>
<span class="normal">3785</span>
<span class="normal">3786</span>
<span class="normal">3787</span>
<span class="normal">3788</span>
<span class="normal">3789</span>
<span class="normal">3790</span>
<span class="normal">3791</span>
<span class="normal">3792</span>
<span class="normal">3793</span>
<span class="normal">3794</span>
<span class="normal">3795</span>
<span class="normal">3796</span>
<span class="normal">3797</span>
<span class="normal">3798</span>
<span class="normal">3799</span>
<span class="normal">3800</span>
<span class="normal">3801</span>
<span class="normal">3802</span>
<span class="normal">3803</span>
<span class="normal">3804</span>
<span class="normal">3805</span>
<span class="normal">3806</span>
<span class="normal">3807</span>
<span class="normal">3808</span>
<span class="normal">3809</span>
<span class="normal">3810</span>
<span class="normal">3811</span>
<span class="normal">3812</span>
<span class="normal">3813</span>
<span class="normal">3814</span>
<span class="normal">3815</span>
<span class="normal">3816</span>
<span class="normal">3817</span>
<span class="normal">3818</span>
<span class="normal">3819</span>
<span class="normal">3820</span>
<span class="normal">3821</span>
<span class="normal">3822</span>
<span class="normal">3823</span>
<span class="normal">3824</span>
<span class="normal">3825</span>
<span class="normal">3826</span>
<span class="normal">3827</span>
<span class="normal">3828</span>
<span class="normal">3829</span>
<span class="normal">3830</span>
<span class="normal">3831</span>
<span class="normal">3832</span>
<span class="normal">3833</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_superimpose_topologies</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">,</span> <span class="n">mda1_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mda2_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">starting_node_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">ignore_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">use_general_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">starting_pairs_heuristics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">starting_pair_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Superimpose two molecules.</span>

<span class="sd">    @parameter rare_atoms_starting_pair: instead of trying every possible pair for the starting configuration,</span>
<span class="sd">        use several information to narrow down the good possible starting configuration. Specifically,</span>
<span class="sd">        use two things: 1) the extact atom type, find how rare they are, and use the rarity to make the call,</span>
<span class="sd">        2) use the &quot;linkers&quot; and areas that are not parts of the rings to avoid the issue of symmetry in the ring.</span>
<span class="sd">        We are striving here to have 5% starting configurations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># superimposed topologies</span>
    <span class="n">suptops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># grow the topologies using every combination node1-node2 as the starting point</span>
    <span class="c1"># fixme - Test/Optimisation: create a theoretical maximum of a match between two molecules</span>
    <span class="c1"># - Proposal 1: find junctions and use them to start the search</span>
    <span class="c1"># - Analyse components of the graph (ie rotatable due to a single bond connection) and</span>
    <span class="c1">#   pick a starting point from each component</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">starting_node_pairs</span><span class="p">:</span>
        <span class="c1"># generate each to each nodes</span>
        <span class="k">if</span> <span class="n">starting_pair_seed</span><span class="p">:</span>
            <span class="n">left_atom</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">starting_pair_seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">right_atom</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">top2_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">starting_pair_seed</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">starting_node_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">left_atom</span><span class="p">,</span> <span class="n">right_atom</span><span class="p">),</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="n">starting_pairs_heuristics</span><span class="p">:</span>
            <span class="n">starting_node_pairs</span> <span class="o">=</span> <span class="n">get_starting_configurations</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Using heuristics to select the initial pairs for searching the maximum overlap.&#39;</span>
                  <span class="s1">&#39;Could produce non-optimal results.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">starting_node_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">,</span> <span class="n">top2_nodes</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Checking all possible initial pairs to find the optimal MCS. &#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="ow">in</span> <span class="n">starting_node_pairs</span><span class="p">:</span>
        <span class="c1"># with the given starting two nodes, generate the maximum common component</span>
        <span class="n">suptop</span> <span class="o">=</span> <span class="n">SuperimposedTopology</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">top2_nodes</span><span class="p">),</span> <span class="n">mda1_nodes</span><span class="p">,</span> <span class="n">mda2_nodes</span><span class="p">)</span>
        <span class="c1"># fixme turn into a property</span>
        <span class="n">candidate_suptop</span> <span class="o">=</span> <span class="n">_overlay</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">parent_n1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_n2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bond_types</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                    <span class="n">suptop</span><span class="o">=</span><span class="n">suptop</span><span class="p">,</span>
                                    <span class="n">ignore_coords</span><span class="o">=</span><span class="n">ignore_coords</span><span class="p">,</span>
                                    <span class="n">use_element_type</span><span class="o">=</span><span class="n">use_general_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">candidate_suptop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># there is no overlap, ignore this case</span>
            <span class="k">continue</span>

        <span class="c1"># check if the maximal possible solution was found</span>
        <span class="c1"># Optimise - can you at this point finish the superimposition if the molecules are fully superimposed?</span>
        <span class="c1"># candidate_suptop.is_subgraph_of_global_top()</span>

        <span class="k">if</span> <span class="n">exists_in</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">,</span> <span class="n">suptops</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># ignore if it is a subgraph of another solution</span>
        <span class="k">if</span> <span class="n">subgraph_of</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">,</span> <span class="n">suptops</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># check if this superimposed topology is a mirror of one that already exists</span>
        <span class="c1"># fixme the order matters in this place</span>
        <span class="c1"># fixme - what if the mirror has a lower rmsd match? in that case, pick that mirror here</span>
        <span class="k">if</span> <span class="n">is_mirror_of_one</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">,</span> <span class="n">suptops</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1">#</span>
        <span class="n">remove_candidates_subgraphs</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">,</span> <span class="n">suptops</span><span class="p">)</span>

        <span class="c1"># while comparing partial overlaps, suptops can be modified</span>
        <span class="c1"># and_ignore = solve_partial_overlaps(candidate_suptop, suptops)</span>
        <span class="c1"># if and_ignore:</span>
        <span class="c1">#     continue</span>

        <span class="c1"># fixme - what to do when about the odd pairs randomH-randomH etc? they won&#39;t be found in other graphs</span>
        <span class="c1"># follow a rule: if this node was used before in a larger superimposed topology, than it should</span>
        <span class="c1"># not be in the final list (we guarantee that each node is used only once)</span>
        <span class="n">suptops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_suptop</span><span class="p">)</span>

    <span class="c1"># if there are only hydrogens superimposed without a connection to any heavy atoms, ignore these too</span>
    <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">all_hydrogens</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">node1</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
                <span class="n">all_hydrogens</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">all_hydrogens</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing sup top because only hydrogens found </span><span class="si">{</span><span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">suptops</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">suptop</span><span class="p">)</span>

    <span class="c1"># TEST: check that each node was used only once, fixme use only on the winner</span>
    <span class="c1"># for suptop in suptops:</span>
    <span class="c1">#     [all_nodes.extend([node1, node2]) for node1, node2 in suptop.matched_pairs]</span>
    <span class="c1">#     pair_count += len(suptop.matched_pairs)</span>
    <span class="c1">#     assert len(set(all_nodes)) == 2 * pair_count</span>

    <span class="c1"># TEST: check that the nodes on the left are always from topology 1 and the nodes on the right are always from top2</span>
    <span class="k">for</span> <span class="n">suptop</span> <span class="ow">in</span> <span class="n">suptops</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="ow">in</span> <span class="n">suptop</span><span class="o">.</span><span class="n">matched_pairs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">node1</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">top1_nodes</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">node2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">top2_nodes</span><span class="p">)</span>

    <span class="c1"># clean the overlays by removing sub_overlays.</span>
    <span class="c1"># ie if all atoms in an overlay are found to be a bigger part of another overlay,</span>
    <span class="c1"># then that overlay is better</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found overlays: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">suptops</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># finally, once again, order the suptops and return the best one</span>
    <span class="n">suptops</span> <span class="o">=</span> <span class="n">extract_best_suptop</span><span class="p">(</span><span class="n">suptops</span><span class="p">,</span> <span class="n">ignore_coords</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">get_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># fixme - return other info</span>
    <span class="k">return</span> <span class="n">suptops</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.get_atoms_bonds_from_mol2" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">get_atoms_bonds_from_mol2</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_atoms_bonds_from_mol2</span><span class="p">(</span><span class="n">ref_filename</span><span class="p">,</span> <span class="n">mob_filename</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Use Parmed to load the files.</p>
<h3 id="ties.topology_superimposer.get_atoms_bonds_from_mol2--returns">returns</h3>
<h3 id="ties.topology_superimposer.get_atoms_bonds_from_mol2--1-a-dictionary-with-charges-eg-item-c17-0222903">1) a dictionary with charges, e.g. Item: "C17" : -0.222903</h3>
<h3 id="ties.topology_superimposer.get_atoms_bonds_from_mol2--2-a-list-of-bonds">2) a list of bonds</h3>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4063</span>
<span class="normal">4064</span>
<span class="normal">4065</span>
<span class="normal">4066</span>
<span class="normal">4067</span>
<span class="normal">4068</span>
<span class="normal">4069</span>
<span class="normal">4070</span>
<span class="normal">4071</span>
<span class="normal">4072</span>
<span class="normal">4073</span>
<span class="normal">4074</span>
<span class="normal">4075</span>
<span class="normal">4076</span>
<span class="normal">4077</span>
<span class="normal">4078</span>
<span class="normal">4079</span>
<span class="normal">4080</span>
<span class="normal">4081</span>
<span class="normal">4082</span>
<span class="normal">4083</span>
<span class="normal">4084</span>
<span class="normal">4085</span>
<span class="normal">4086</span>
<span class="normal">4087</span>
<span class="normal">4088</span>
<span class="normal">4089</span>
<span class="normal">4090</span>
<span class="normal">4091</span>
<span class="normal">4092</span>
<span class="normal">4093</span>
<span class="normal">4094</span>
<span class="normal">4095</span>
<span class="normal">4096</span>
<span class="normal">4097</span>
<span class="normal">4098</span>
<span class="normal">4099</span>
<span class="normal">4100</span>
<span class="normal">4101</span>
<span class="normal">4102</span>
<span class="normal">4103</span>
<span class="normal">4104</span>
<span class="normal">4105</span>
<span class="normal">4106</span>
<span class="normal">4107</span>
<span class="normal">4108</span>
<span class="normal">4109</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_atoms_bonds_from_mol2</span><span class="p">(</span><span class="n">ref_filename</span><span class="p">,</span> <span class="n">mob_filename</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use Parmed to load the files.</span>

<span class="sd">    # returns</span>
<span class="sd">    # 1) a dictionary with charges, e.g. Item: &quot;C17&quot; : -0.222903</span>
<span class="sd">    # 2) a list of bonds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">parmed</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ref_filename</span><span class="p">),</span> <span class="n">structure</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mobile</span> <span class="o">=</span> <span class="n">parmed</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mob_filename</span><span class="p">),</span> <span class="n">structure</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">create_atoms</span><span class="p">(</span><span class="n">parmed_atoms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # convert the Parmed atoms into Atom objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parmed_atom</span> <span class="ow">in</span> <span class="n">parmed_atoms</span><span class="p">:</span>
            <span class="n">atom_type</span> <span class="o">=</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">type</span>
            <span class="c1"># atom type might be empty if</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">atom_type</span><span class="p">:</span>
                <span class="c1"># use the atom name as the atom type, e.g. C7</span>
                <span class="n">atom_type</span> <span class="o">=</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">name</span>


            <span class="k">try</span><span class="p">:</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">parmed_atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom_type</span><span class="o">=</span><span class="n">atom_type</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">parmed_atom</span><span class="o">.</span><span class="n">charge</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="n">use_general_type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># most likely the charges were missing, manually set the charges to 0</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">parmed_atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom_type</span><span class="o">=</span><span class="n">atom_type</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">use_general_type</span><span class="o">=</span><span class="n">use_general_type</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;One of the input files is missing charges. Setting the charge to 0&#39;</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">idx</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">parmed_atom</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">xz</span><span class="p">]</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">resname</span> <span class="o">=</span> <span class="n">parmed_atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span>

    <span class="n">universe_ref_atoms</span> <span class="o">=</span> <span class="n">create_atoms</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
    <span class="c1"># note that these coordinate should be superimposed</span>
    <span class="n">universe_mob_atoms</span> <span class="o">=</span> <span class="n">create_atoms</span><span class="p">(</span><span class="n">mobile</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="c1"># fixme - add a check that all the charges come to 0 as declared in the header</span>
    <span class="n">universe_ref_bonds</span> <span class="o">=</span> <span class="p">[(</span><span class="n">b</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span>
    <span class="n">universe_mob_bonds</span> <span class="o">=</span> <span class="p">[(</span><span class="n">b</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">mobile</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">universe_ref_atoms</span><span class="p">,</span> <span class="n">universe_ref_bonds</span><span class="p">,</span> \
           <span class="n">universe_mob_atoms</span><span class="p">,</span> <span class="n">universe_mob_bonds</span><span class="p">,</span> \
           <span class="n">ref</span><span class="p">,</span> <span class="n">mobile</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ties.topology_superimposer.assign_coords_from_pdb" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>            <span class="doc doc-object-name doc-function-name">assign_coords_from_pdb</span>


</h2>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">assign_coords_from_pdb</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">pdb_atoms</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Match the atoms from the ParmEd object based on a .pdb file
and overwrite the coordinates from ParmEd.
:param atoms: internal Atom representation (fixme: refer to it here in docu),
    will have their coordinates overwritten.
:param pdb_atoms: atoms loaded with ParmEd with the coordinates to be used</p>

            <details class="quote">
              <summary>Source code in <code>ties/topology_superimposer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4112</span>
<span class="normal">4113</span>
<span class="normal">4114</span>
<span class="normal">4115</span>
<span class="normal">4116</span>
<span class="normal">4117</span>
<span class="normal">4118</span>
<span class="normal">4119</span>
<span class="normal">4120</span>
<span class="normal">4121</span>
<span class="normal">4122</span>
<span class="normal">4123</span>
<span class="normal">4124</span>
<span class="normal">4125</span>
<span class="normal">4126</span>
<span class="normal">4127</span>
<span class="normal">4128</span>
<span class="normal">4129</span>
<span class="normal">4130</span>
<span class="normal">4131</span>
<span class="normal">4132</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">assign_coords_from_pdb</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">pdb_atoms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Match the atoms from the ParmEd object based on a .pdb file</span>
<span class="sd">    and overwrite the coordinates from ParmEd.</span>
<span class="sd">    :param atoms: internal Atom representation (fixme: refer to it here in docu),</span>
<span class="sd">        will have their coordinates overwritten.</span>
<span class="sd">    :param pdb_atoms: atoms loaded with ParmEd with the coordinates to be used</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="c1"># find the corresponding atom</span>
        <span class="n">found_match</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">pdb_atom</span> <span class="ow">in</span> <span class="n">pdb_atoms</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pdb_atom</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                <span class="c1"># charges?</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="n">pdb_atom</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">pdb_atom</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">pdb_atom</span><span class="o">.</span><span class="n">xz</span><span class="p">)</span>
                <span class="n">found_match</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_match</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not find atom? </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;wait a minute&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../protein/" class="md-footer__link md-footer__link--prev" aria-label="Previous: &lt;code class=&#34;doc-symbol doc-symbol-nav doc-symbol-module&#34;&gt;&lt;/code&gt; protein">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                <code class="doc-symbol doc-symbol-nav doc-symbol-module"></code> protein
              </div>
            </div>
          </a>
        
        
          
          <a href="../../theory/" class="md-footer__link md-footer__link--next" aria-label="Next: Theory">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                Theory
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2025 Mateusz Bieniek
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["announce.dismiss", "content.code.annotate", "content.code.copy", "content.tooltips", "navigation.footer", "navigation.indexes", "navigation.sections", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "search.highlight", "search.suggest", "toc.follow"], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.f1b6f286.min.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>